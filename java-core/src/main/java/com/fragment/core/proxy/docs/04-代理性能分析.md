# 04 代理性能分析

## 性能对比概述

### 调用性能排序（从快到慢）
1. **直接调用** - 基准性能
2. **CGLIB代理** - 约慢1.5-3倍
3. **JDK动态代理** - 约慢10-50倍

## 性能测试方法

### 测试环境要求
- JVM预热：避免JIT编译影响
- 多次测试：取平均值
- 相同条件：相同的方法调用次数

### 测试代码示例
参考 `ProxyPerformanceDemo.java`：
- 直接调用vs代理调用对比
- 内存使用分析
- 不同场景下的性能表现

## JDK代理性能分析

### 性能开销来源
1. **反射调用**：Method.invoke()开销
2. **参数装箱**：基本类型装箱拆箱
3. **异常包装**：InvocationTargetException
4. **方法查找**：动态方法分派

### 优化策略
```java
// 缓存Method对象
private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();

// 使用MethodHandle（Java 7+）
MethodHandle handle = lookup.unreflect(method);
```

## CGLIB代理性能分析

### 性能优势
- 直接方法调用，无反射开销
- FastClass机制避免反射
- 字节码级别优化

### 性能开销
- 代理类生成时间
- 内存占用增加
- 方法拦截器调用开销

## 内存使用分析

### 代理对象内存占用
- JDK代理：较小，主要是InvocationHandler
- CGLIB代理：较大，包含完整的子类结构

### 类加载开销
- JDK代理：动态生成类较小
- CGLIB代理：生成的类文件较大

## 优化建议

### 1. 选择合适的代理类型
- 有接口且性能要求不高：JDK代理
- 无接口或性能敏感：CGLIB代理

### 2. 缓存策略
```java
// 缓存代理对象
Map<Class<?>, Object> proxyCache = new ConcurrentHashMap<>();
```

### 3. 减少拦截逻辑
- 避免复杂的拦截器逻辑
- 使用条件拦截，只处理必要的方法

## 实际应用建议

### 高性能场景
- 考虑编译时代理（APT）
- 使用字节码增强（Javassist、ByteBuddy）
- 直接继承或组合模式

### 框架开发
- 提供代理类型选择
- 实现代理对象池
- 支持代理缓存机制

## 示例代码位置
- `ProxyPerformanceDemo.java`：完整性能测试
