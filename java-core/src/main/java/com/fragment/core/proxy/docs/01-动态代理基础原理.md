# 01 动态代理基础原理

## 什么是动态代理

动态代理是在运行时动态创建代理对象的技术，它允许在不修改原有代码的情况下，为对象添加额外的功能。

## 代理模式的核心概念

### 静态代理 vs 动态代理

**静态代理：**
- 编译时确定代理类
- 需要为每个接口手动编写代理类
- 代码冗余，维护困难

**动态代理：**
- 运行时动态生成代理类
- 一套代码可以代理多个接口
- 灵活性高，易于维护

### 代理模式的组成

1. **Subject（抽象主题）**：定义代理和真实对象的共同接口
2. **RealSubject（真实主题）**：实现抽象主题的具体类
3. **Proxy（代理）**：持有真实对象的引用，控制对真实对象的访问

## Java中的动态代理实现

### 1. JDK动态代理
- **原理**：基于接口，使用反射机制
- **限制**：只能代理实现了接口的类
- **核心类**：`java.lang.reflect.Proxy`、`InvocationHandler`

### 2. CGLIB动态代理
- **原理**：基于继承，使用字节码生成技术
- **优势**：可以代理没有接口的类
- **限制**：不能代理final类和final方法

## JDK动态代理的实现原理

### 核心API

```java
// 创建代理对象
Object proxy = Proxy.newProxyInstance(
    ClassLoader loader,     // 类加载器
    Class<?>[] interfaces,  // 被代理类实现的接口
    InvocationHandler h     // 调用处理器
);
```

### InvocationHandler接口

```java
public interface InvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

参数说明：
- `proxy`：代理对象本身
- `method`：被调用的方法
- `args`：方法参数

### 代理类生成过程

1. **验证接口**：检查传入的接口是否有效
2. **查找缓存**：检查是否已经生成过相同的代理类
3. **生成字节码**：动态生成代理类的字节码
4. **加载类**：将生成的字节码加载到JVM
5. **创建实例**：通过反射创建代理对象实例

### 生成的代理类特点

```java
// JDK生成的代理类大致结构
public final class $Proxy0 extends Proxy implements UserService {
    private static Method m1;
    private static Method m2;
    private static Method m3; // findById方法
    
    public $Proxy0(InvocationHandler h) {
        super(h);
    }
    
    public User findById(Long id) throws Throwable {
        return (User) super.h.invoke(this, m3, new Object[]{id});
    }
}
```

## CGLIB代理的实现原理

### 核心概念
- 使用ASM字节码生成框架
- 创建目标类的子类
- 重写父类方法实现代理逻辑

### 关键类
- `Enhancer`：代理类生成器
- `MethodInterceptor`：方法拦截器
- `MethodProxy`：方法代理

### 生成的代理类特点

```java
// CGLIB生成的代理类大致结构
public class Calculator$$EnhancerByCGLIB$$12345 extends Calculator {
    private MethodInterceptor interceptor;
    
    public int add(int a, int b) {
        if (interceptor != null) {
            return (Integer) interceptor.intercept(this, 
                Calculator.class.getMethod("add", int.class, int.class),
                new Object[]{a, b},
                methodProxy);
        }
        return super.add(a, b);
    }
}
```

## 动态代理的应用场景

1. **AOP（面向切面编程）**
   - 日志记录
   - 性能监控
   - 事务管理
   - 权限控制

2. **框架开发**
   - Spring的Bean代理
   - MyBatis的Mapper接口
   - RPC框架的远程调用

3. **设计模式实现**
   - 装饰器模式
   - 适配器模式
   - 外观模式

## 优缺点分析

### 优点
- **灵活性**：运行时动态创建代理
- **复用性**：一套代码可以代理多个类
- **解耦性**：代理逻辑与业务逻辑分离
- **扩展性**：易于添加新的代理功能

### 缺点
- **性能开销**：反射调用比直接调用慢
- **复杂性**：增加了系统的复杂度
- **调试困难**：代理类是动态生成的
- **限制性**：JDK代理只能代理接口

## 示例代码位置

- `JdkProxyDemo.java`：JDK动态代理完整演示
- `CglibProxyDemo.java`：CGLIB代理概念演示
- `UserService.java`、`UserServiceImpl.java`：被代理的接口和实现
- `Calculator.java`：用于CGLIB代理的普通类
