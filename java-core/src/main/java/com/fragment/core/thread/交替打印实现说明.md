# 两个线程交替打印1到100 - 实现说明

## 📝 需求说明

实现两个线程交替打印1到100的数字：
- 线程1打印奇数：1, 3, 5, 7, ..., 99
- 线程2打印偶数：2, 4, 6, 8, ..., 100
- 两个线程必须交替执行，按顺序打印

## ✅ 已完成的工作

### 1. 代码实现

在 `ThreadCooperationDemo.java` 中添加了两种实现方案：

#### 方案1：使用wait/notify实现
- 使用共享变量 `currentNumber` 记录当前数字
- 奇数线程和偶数线程通过判断 `currentNumber % 2` 来决定是否打印
- 使用 `wait()` 等待，使用 `notify()` 唤醒另一个线程

#### 方案2：使用标志位实现
- 创建 `AlternatePrinter` 辅助类
- 使用布尔标志位 `isOddTurn` 控制轮次
- 每个线程负责打印固定的数字序列（奇数或偶数）
- 通过 `wait()/notify()` 实现线程间协作

### 2. 关键技术点

#### ✅ 使用while而不是if检查条件
```java
// ✅ 正确
while (!isMyTurn) {
    lock.wait(); // 防止虚假唤醒
}

// ❌ 错误
if (!isMyTurn) {
    lock.wait(); // 虚假唤醒时不会重新检查
}
```

#### ✅ 正确处理中断
```java
try {
    lock.wait();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // 恢复中断状态
    return;
}
```

#### ✅ 边界条件检查
```java
if (currentNumber <= MAX) {
    System.out.println("线程: " + currentNumber);
    currentNumber++;
    lock.notify();
}
```

### 3. 文档更新

#### 更新了 `README.md`
- 在"运行线程协作机制演示"部分添加了新功能说明
- 列出了"两个线程交替打印1到100（经典面试题）"

#### 更新了 `02_线程协作机制详解.md`
- 添加了第6章：经典面试题：两个线程交替打印1到100
- 详细讲解了两种实现方案
- 解释了为什么要用while而不是if
- 对比了notify()和notifyAll()的使用场景
- 提供了扩展案例：三个线程交替打印ABC

## 🎯 代码特点

### 1. JDK 1.8兼容
- ✅ 没有使用 `var` 关键字（Java 10+）
- ✅ 没有使用 `String.repeat()`（Java 11+）
- ✅ 使用 `StringBuilder` 构建分隔线
- ✅ 所有语法都符合JDK 1.8标准

### 2. 线程安全
- ✅ 使用 `synchronized` 保证同步
- ✅ 使用 `wait()/notify()` 实现线程协作
- ✅ 正确处理中断异常
- ✅ 避免虚假唤醒（使用while循环）

### 3. 代码质量
- ✅ 清晰的注释说明
- ✅ 完整的JavaDoc文档
- ✅ 符合阿里巴巴Java开发规范
- ✅ 易于理解和维护

## 📚 运行方式

### 编译
```bash
javac -d target/classes src/main/java/com/fragment/core/thread/demo/ThreadCooperationDemo.java
```

### 运行
```bash
java -cp target/classes com.fragment.core.thread.demo.ThreadCooperationDemo
```

### 预期输出
```
========== 线程协作机制演示 ==========

1. sleep()演示
...

5. 两个线程交替打印1到100（经典面试题）
特点: 使用wait/notify实现线程交替执行

方案1: 使用wait/notify实现
奇数线程: 1
偶数线程: 2
奇数线程: 3
偶数线程: 4
...
奇数线程: 99
偶数线程: 100

==================================================

方案2: 使用synchronized + 标志位实现
线程1: 1
线程2: 2
线程1: 3
线程2: 4
...
线程1: 99
线程2: 100

关键点:
1. 必须保证线程间的同步
2. 使用标志位判断轮到哪个线程
3. wait/notify是最常用的实现方式
4. 注意避免虚假唤醒（使用while而不是if）
```

## 💡 学习要点

### 1. wait/notify机制
- `wait()` 必须在 `synchronized` 块中调用
- `wait()` 会释放锁，让其他线程有机会执行
- `notify()` 唤醒一个等待线程，但不会立即释放锁
- `notifyAll()` 唤醒所有等待线程

### 2. 虚假唤醒
- 操作系统可能在没有 `notify()` 的情况下唤醒线程
- 必须使用 `while` 循环检查条件，而不是 `if`
- 被唤醒后重新检查条件是否满足

### 3. 线程协作模式
- 使用标志位控制线程执行顺序
- 通过 `wait()/notify()` 实现线程间通信
- 确保线程安全和正确的同步

## 🔍 扩展思考

### 1. 如果要实现三个线程交替打印ABC怎么办？
- 使用状态变量（0, 1, 2）控制轮次
- 每个线程只在特定状态下执行
- 必须使用 `notifyAll()` 而不是 `notify()`

### 2. 能否使用其他方式实现？
- ✅ 使用 `Semaphore`（信号量）
- ✅ 使用 `ReentrantLock` + `Condition`
- ✅ 使用 `CountDownLatch`
- ✅ 使用 `CyclicBarrier`

### 3. 性能优化
- 减少锁的持有时间
- 使用 `notify()` 而不是 `notifyAll()`（如果只有两个线程）
- 避免不必要的同步

## 📖 相关文档

- [ThreadCooperationDemo.java](./demo/ThreadCooperationDemo.java) - 完整代码实现
- [02_线程协作机制详解.md](./docs/02_线程协作机制详解.md) - 详细理论讲解
- [README.md](./README.md) - 模块总览

## ✨ 总结

这个实现展示了：
1. ✅ 如何使用 `wait/notify` 实现线程协作
2. ✅ 如何避免虚假唤醒
3. ✅ 如何正确处理线程中断
4. ✅ 如何设计清晰的线程协作模式
5. ✅ 符合JDK 1.8语法规范

这是一道经典的Java多线程面试题，掌握它可以帮助你：
- 深入理解 `wait/notify` 机制
- 掌握线程间协作的基本模式
- 提高多线程编程能力
- 应对面试中的类似问题

---

**Happy Coding! 🚀**
