# ç¬¬äº”ç« ï¼šæºç åˆ†æä¸æœ€ä½³å®è·µ

## å¼•è¨€

æœ¬ç« å°†æ·±å…¥Threadç±»çš„æ ¸å¿ƒæºç ï¼Œåˆ†æwait/notifyçš„åº•å±‚å®ç°ï¼Œæ€»ç»“å®é™…ç¼–ç ä¸­å¯ä»¥å€Ÿé‰´çš„è®¾è®¡æ€æƒ³å’Œæœ€ä½³å®è·µã€‚

---

## 1. Threadç±»æ ¸å¿ƒæºç åˆ†æ

### 1.1 é—®é¢˜1ï¼šThread.start()çš„æºç å®ç°æ˜¯ä»€ä¹ˆï¼Ÿ

**Javaå±‚æºç **ï¼š

```java
public synchronized void start() {
    // 1. æ£€æŸ¥çº¿ç¨‹çŠ¶æ€
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    
    // 2. å°†çº¿ç¨‹åŠ å…¥çº¿ç¨‹ç»„
    group.add(this);
    
    boolean started = false;
    try {
        // 3. è°ƒç”¨nativeæ–¹æ³•å¯åŠ¨çº¿ç¨‹
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        }
    }
}

// nativeæ–¹æ³•
private native void start0();
```

**å…³é”®è®¾è®¡**ï¼š

1. **synchronizedä¿è¯çº¿ç¨‹å®‰å…¨**ï¼šé˜²æ­¢å¹¶å‘å¯åŠ¨
2. **çŠ¶æ€æ£€æŸ¥**ï¼šé˜²æ­¢é‡å¤å¯åŠ¨
3. **çº¿ç¨‹ç»„ç®¡ç†**ï¼šç»Ÿä¸€ç®¡ç†çº¿ç¨‹
4. **å¼‚å¸¸å¤„ç†**ï¼šå¯åŠ¨å¤±è´¥æ—¶æ¸…ç†

**å¯å€Ÿé‰´çš„è®¾è®¡**ï¼š

```java
// å€Ÿé‰´ï¼šçŠ¶æ€æ£€æŸ¥ + å¼‚å¸¸å¤„ç†
public class StatefulService {
    private volatile boolean started = false;
    
    public synchronized void start() {
        if (started) {
            throw new IllegalStateException("Service already started");
        }
        
        boolean success = false;
        try {
            doStart();
            success = true;
            started = true;
        } finally {
            if (!success) {
                cleanup();
            }
        }
    }
    
    private void doStart() {
        // å¯åŠ¨é€»è¾‘
    }
    
    private void cleanup() {
        // æ¸…ç†é€»è¾‘
    }
}
```

---

### 1.2 é—®é¢˜2ï¼šThread.interrupt()çš„æºç å®ç°æ˜¯ä»€ä¹ˆï¼Ÿ

**Javaå±‚æºç **ï¼š

```java
public void interrupt() {
    if (this != Thread.currentThread())
        checkAccess(); // æƒé™æ£€æŸ¥
    
    synchronized (blockerLock) {
        Interruptible b = blocker;
        if (b != null) {
            interrupt0();  // è®¾ç½®ä¸­æ–­æ ‡å¿—
            b.interrupt(this); // ä¸­æ–­IOæ“ä½œ
            return;
        }
    }
    interrupt0();
}

// nativeæ–¹æ³•
private native void interrupt0();
```

**å…³é”®è®¾è®¡**ï¼š

1. **æƒé™æ£€æŸ¥**ï¼šå®‰å…¨æ€§è€ƒè™‘
2. **blockeræœºåˆ¶**ï¼šæ”¯æŒä¸­æ–­IOæ“ä½œ
3. **synchronizedä¿æŠ¤**ï¼šé˜²æ­¢å¹¶å‘é—®é¢˜

**ä¸­æ–­æ ‡å¿—çš„å®ç°**ï¼š

```c++
// JVMå±‚å®ç°ï¼ˆC++ï¼‰
void Thread::interrupt() {
    // è®¾ç½®ä¸­æ–­æ ‡å¿—
    _interrupted = true;
    
    // å¦‚æœçº¿ç¨‹åœ¨wait/sleep/joinï¼Œå”¤é†’å®ƒ
    if (_state == WAITING || _state == TIMED_WAITING) {
        unpark();
    }
}
```

---

### 1.3 é—®é¢˜3ï¼šThread.sleep()çš„æºç å®ç°æ˜¯ä»€ä¹ˆï¼Ÿ

**Javaå±‚æºç **ï¼š

```java
public static native void sleep(long millis) throws InterruptedException;

public static void sleep(long millis, int nanos) throws InterruptedException {
    if (millis < 0) {
        throw new IllegalArgumentException("timeout value is negative");
    }
    
    if (nanos < 0 || nanos > 999999) {
        throw new IllegalArgumentException("nanosecond timeout value out of range");
    }
    
    if (nanos >= 500000 || (nanos != 0 && millis == 0)) {
        millis++;
    }
    
    sleep(millis);
}
```

**JVMå±‚å®ç°é€»è¾‘**ï¼š

```c++
// JVMå±‚å®ç°ï¼ˆä¼ªä»£ç ï¼‰
void Thread::sleep(long millis) {
    // 1. æ£€æŸ¥ä¸­æ–­æ ‡å¿—
    if (is_interrupted()) {
        throw InterruptedException();
    }
    
    // 2. è®¾ç½®çº¿ç¨‹çŠ¶æ€ä¸ºTIMED_WAITING
    set_state(TIMED_WAITING);
    
    // 3. è°ƒç”¨æ“ä½œç³»ç»Ÿsleep
    os::sleep(millis);
    
    // 4. æ¢å¤çº¿ç¨‹çŠ¶æ€ä¸ºRUNNABLE
    set_state(RUNNABLE);
    
    // 5. å†æ¬¡æ£€æŸ¥ä¸­æ–­æ ‡å¿—
    if (is_interrupted()) {
        throw InterruptedException();
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **ä¸¤æ¬¡ä¸­æ–­æ£€æŸ¥**ï¼šsleepå‰åéƒ½æ£€æŸ¥
2. **çŠ¶æ€è½¬æ¢**ï¼šRUNNABLE â†’ TIMED_WAITING â†’ RUNNABLE
3. **æ¸…é™¤ä¸­æ–­æ ‡å¿—**ï¼šæŠ›å‡ºå¼‚å¸¸æ—¶æ¸…é™¤

---

## 2. wait/notifyæºç åˆ†æ

### 2.1 é—®é¢˜4ï¼šObject.wait()çš„æºç å®ç°æ˜¯ä»€ä¹ˆï¼Ÿ

**Javaå±‚æºç **ï¼š

```java
public final native void wait(long timeout) throws InterruptedException;

public final void wait() throws InterruptedException {
    wait(0);
}
```

**JVMå±‚å®ç°é€»è¾‘**ï¼š

```c++
// JVMå±‚å®ç°ï¼ˆä¼ªä»£ç ï¼‰
void Object::wait(long timeout) {
    // 1. æ£€æŸ¥æ˜¯å¦æŒæœ‰é”
    if (!current_thread_owns_monitor(this)) {
        throw IllegalMonitorStateException();
    }
    
    // 2. ä¿å­˜é”çš„é‡å…¥æ¬¡æ•°
    int save_recursion = monitor->recursion_count();
    
    // 3. å®Œå…¨é‡Šæ”¾é”
    monitor->exit(save_recursion);
    
    // 4. å°†çº¿ç¨‹åŠ å…¥ç­‰å¾…é˜Ÿåˆ—
    monitor->wait_queue.add(current_thread);
    
    // 5. è®¾ç½®çº¿ç¨‹çŠ¶æ€
    current_thread->set_state(WAITING);
    
    // 6. é˜»å¡çº¿ç¨‹
    park(timeout);
    
    // 7. è¢«å”¤é†’åï¼Œé‡æ–°ç«äº‰é”
    monitor->enter(save_recursion);
    
    // 8. æ£€æŸ¥ä¸­æ–­æ ‡å¿—
    if (current_thread->is_interrupted()) {
        throw InterruptedException();
    }
}
```

**å…³é”®è®¾è®¡**ï¼š

1. **å¿…é¡»æŒæœ‰é”**ï¼šå¦åˆ™æŠ›å‡ºIllegalMonitorStateException
2. **å®Œå…¨é‡Šæ”¾é”**ï¼šåŒ…æ‹¬é‡å…¥æ¬¡æ•°
3. **ç­‰å¾…é˜Ÿåˆ—**ï¼šFIFOé˜Ÿåˆ—
4. **é‡æ–°è·å–é”**ï¼šè¢«å”¤é†’åéœ€è¦ç«äº‰é”

**ç­‰å¾…é˜Ÿåˆ—ç»“æ„**ï¼š

```
Monitorå¯¹è±¡ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Object                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Monitor               â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Entry Queue     â”‚  â”‚  â”‚  â† synchronizedç­‰å¾…é˜Ÿåˆ—
â”‚  â”‚  â”‚  [T1][T2][T3]    â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚  â”‚  Wait Queue      â”‚  â”‚  â”‚  â† waitç­‰å¾…é˜Ÿåˆ—
â”‚  â”‚  â”‚  [T4][T5]        â”‚  â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚  Owner: T0            â”‚  â”‚  â”‚  â† å½“å‰æŒæœ‰é”çš„çº¿ç¨‹
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 2.2 é—®é¢˜5ï¼šObject.notify()çš„æºç å®ç°æ˜¯ä»€ä¹ˆï¼Ÿ

**Javaå±‚æºç **ï¼š

```java
public final native void notify();
public final native void notifyAll();
```

**JVMå±‚å®ç°é€»è¾‘**ï¼š

```c++
// notify()å®ç°
void Object::notify() {
    // 1. æ£€æŸ¥æ˜¯å¦æŒæœ‰é”
    if (!current_thread_owns_monitor(this)) {
        throw IllegalMonitorStateException();
    }
    
    // 2. ä»ç­‰å¾…é˜Ÿåˆ—ç§»é™¤ä¸€ä¸ªçº¿ç¨‹
    Thread* t = monitor->wait_queue.remove_first();
    
    if (t != null) {
        // 3. å°†çº¿ç¨‹åŠ å…¥åŒæ­¥é˜Ÿåˆ—
        monitor->entry_queue.add(t);
        
        // 4. å”¤é†’çº¿ç¨‹
        unpark(t);
    }
}

// notifyAll()å®ç°
void Object::notifyAll() {
    // 1. æ£€æŸ¥æ˜¯å¦æŒæœ‰é”
    if (!current_thread_owns_monitor(this)) {
        throw IllegalMonitorStateException();
    }
    
    // 2. ç§»é™¤æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
    while (!monitor->wait_queue.is_empty()) {
        Thread* t = monitor->wait_queue.remove_first();
        
        // 3. å°†çº¿ç¨‹åŠ å…¥åŒæ­¥é˜Ÿåˆ—
        monitor->entry_queue.add(t);
        
        // 4. å”¤é†’çº¿ç¨‹
        unpark(t);
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **å¿…é¡»æŒæœ‰é”**ï¼šå¦åˆ™æŠ›å‡ºå¼‚å¸¸
2. **ç§»åŠ¨åˆ°åŒæ­¥é˜Ÿåˆ—**ï¼šä»waité˜Ÿåˆ—ç§»åˆ°entryé˜Ÿåˆ—
3. **ç«äº‰é”**ï¼šè¢«å”¤é†’çš„çº¿ç¨‹éœ€è¦ç«äº‰é”

**å”¤é†’æµç¨‹å›¾**ï¼š

```
notify()è°ƒç”¨
    â†“
ä»Wait Queueç§»é™¤T4
    â†“
T4åŠ å…¥Entry Queue
    â†“
unpark(T4)
    â†“
T4çŠ¶æ€: WAITING â†’ BLOCKED
    â†“
ç­‰å¾…è·å–é”
    â†“
è·å¾—é”å
    â†“
T4çŠ¶æ€: BLOCKED â†’ RUNNABLE
    â†“
wait()è¿”å›
```

---

## 3. çº¿ç¨‹çŠ¶æ€è½¬æ¢çš„æºç å®ç°

### 3.1 é—®é¢˜6ï¼šçº¿ç¨‹çŠ¶æ€æ˜¯å¦‚ä½•ç®¡ç†çš„ï¼Ÿ

**Threadç±»çš„çŠ¶æ€å®šä¹‰**ï¼š

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}

// è·å–çº¿ç¨‹çŠ¶æ€
public State getState() {
    return sun.misc.VM.toThreadState(threadStatus);
}
```

**threadStatusçš„ç¼–ç **ï¼š

```java
// JVMå†…éƒ¨ä½¿ç”¨ä½æ ‡å¿—è¡¨ç¤ºçŠ¶æ€
private volatile int threadStatus = 0;

// çŠ¶æ€å€¼ï¼ˆJVMå†…éƒ¨ï¼‰
static final int JVMTI_THREAD_STATE_ALIVE = 0x0001;
static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002;
static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;
static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;
static final int JVMTI_THREAD_STATE_WAITING = 0x0080;
static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020;
```

**çŠ¶æ€è½¬æ¢å®ç°**ï¼š

```c++
// JVMå±‚å®ç°
void Thread::set_state(ThreadState new_state) {
    ThreadState old_state = _state;
    _state = new_state;
    
    // æ›´æ–°threadStatus
    update_thread_status();
    
    // è§¦å‘çŠ¶æ€è½¬æ¢äº‹ä»¶
    fire_state_change_event(old_state, new_state);
}
```

---

## 4. å®é™…ç¼–ç ä¸­å¯å€Ÿé‰´çš„è®¾è®¡

### 4.1 é—®é¢˜7ï¼šThreadç±»æœ‰å“ªäº›å€¼å¾—å€Ÿé‰´çš„è®¾è®¡æ¨¡å¼ï¼Ÿ

#### è®¾è®¡1ï¼šæ¨¡æ¿æ–¹æ³•æ¨¡å¼

```java
// Threadç±»çš„è®¾è®¡
public class Thread implements Runnable {
    // æ¨¡æ¿æ–¹æ³•
    public void run() {
        if (target != null) {
            target.run();
        }
    }
    
    // å­ç±»å¯ä»¥é‡å†™
    @Override
    public void run() {
        // è‡ªå®šä¹‰é€»è¾‘
    }
}

// å€Ÿé‰´ï¼šå®šä¹‰ç®—æ³•éª¨æ¶
public abstract class TaskExecutor {
    // æ¨¡æ¿æ–¹æ³•
    public final void execute() {
        beforeExecute();
        try {
            doExecute();
        } finally {
            afterExecute();
        }
    }
    
    protected void beforeExecute() {
        // é’©å­æ–¹æ³•
    }
    
    protected abstract void doExecute();
    
    protected void afterExecute() {
        // é’©å­æ–¹æ³•
    }
}
```

---

#### è®¾è®¡2ï¼šçŠ¶æ€æ¨¡å¼

```java
// Threadçš„çŠ¶æ€ç®¡ç†
public enum State {
    NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
}

// å€Ÿé‰´ï¼šçŠ¶æ€æœºè®¾è®¡
public class Connection {
    private enum State {
        DISCONNECTED, CONNECTING, CONNECTED, DISCONNECTING
    }
    
    private volatile State state = State.DISCONNECTED;
    
    public synchronized void connect() {
        if (state != State.DISCONNECTED) {
            throw new IllegalStateException("Cannot connect from state: " + state);
        }
        state = State.CONNECTING;
        try {
            doConnect();
            state = State.CONNECTED;
        } catch (Exception e) {
            state = State.DISCONNECTED;
            throw e;
        }
    }
    
    public synchronized void disconnect() {
        if (state != State.CONNECTED) {
            throw new IllegalStateException("Cannot disconnect from state: " + state);
        }
        state = State.DISCONNECTING;
        try {
            doDisconnect();
        } finally {
            state = State.DISCONNECTED;
        }
    }
    
    private void doConnect() {
        // è¿æ¥é€»è¾‘
    }
    
    private void doDisconnect() {
        // æ–­å¼€é€»è¾‘
    }
}
```

---

#### è®¾è®¡3ï¼šä¸­æ–­æœºåˆ¶

```java
// Threadçš„ä¸­æ–­è®¾è®¡
public void interrupt() {
    // è®¾ç½®æ ‡å¿—
    interrupted = true;
    // å”¤é†’é˜»å¡çº¿ç¨‹
    unpark();
}

// å€Ÿé‰´ï¼šä¼˜é›…åœæ­¢æœºåˆ¶
public class GracefulService {
    private volatile boolean running = true;
    private final CountDownLatch shutdownLatch = new CountDownLatch(1);
    
    public void start() {
        new Thread(() -> {
            while (running) {
                try {
                    doWork();
                } catch (InterruptedException e) {
                    break;
                }
            }
            cleanup();
            shutdownLatch.countDown();
        }).start();
    }
    
    public void shutdown() {
        running = false;
    }
    
    public void awaitShutdown(long timeout, TimeUnit unit) throws InterruptedException {
        shutdownLatch.await(timeout, unit);
    }
    
    private void doWork() throws InterruptedException {
        // å·¥ä½œé€»è¾‘
    }
    
    private void cleanup() {
        // æ¸…ç†é€»è¾‘
    }
}
```

---

#### è®¾è®¡4ï¼šwait/notifyçš„ç­‰å¾…-é€šçŸ¥æ¨¡å¼

```java
// Objectçš„wait/notifyè®¾è®¡
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
    // æ‰§è¡Œæ“ä½œ
}

// å€Ÿé‰´ï¼šæ¡ä»¶ç­‰å¾…æ¨¡å¼
public class BoundedBuffer<T> {
    private final Queue<T> queue = new LinkedList<>();
    private final int capacity;
    private final Object lock = new Object();
    
    public BoundedBuffer(int capacity) {
        this.capacity = capacity;
    }
    
    public void put(T item) throws InterruptedException {
        synchronized (lock) {
            while (queue.size() == capacity) {
                lock.wait(); // ç­‰å¾…ç©ºé—´
            }
            queue.offer(item);
            lock.notifyAll(); // é€šçŸ¥æ¶ˆè´¹è€…
        }
    }
    
    public T take() throws InterruptedException {
        synchronized (lock) {
            while (queue.isEmpty()) {
                lock.wait(); // ç­‰å¾…æ•°æ®
            }
            T item = queue.poll();
            lock.notifyAll(); // é€šçŸ¥ç”Ÿäº§è€…
            return item;
        }
    }
}
```

---

## 5. æœ€ä½³å®è·µæ€»ç»“

### 5.1 é—®é¢˜8ï¼šçº¿ç¨‹ä½¿ç”¨çš„æœ€ä½³å®è·µæœ‰å“ªäº›ï¼Ÿ

#### å®è·µ1ï¼šä¼˜å…ˆä½¿ç”¨é«˜å±‚å¹¶å‘å·¥å…·

```java
// âŒ ä¸æ¨èï¼šæ‰‹åŠ¨wait/notify
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
}

// âœ… æ¨èï¼šä½¿ç”¨CountDownLatch
CountDownLatch latch = new CountDownLatch(1);
latch.await();

// âœ… æ¨èï¼šä½¿ç”¨BlockingQueue
BlockingQueue<Task> queue = new LinkedBlockingQueue<>();
Task task = queue.take();

// âœ… æ¨èï¼šä½¿ç”¨Semaphore
Semaphore semaphore = new Semaphore(10);
semaphore.acquire();
```

---

#### å®è·µ2ï¼šæ­£ç¡®å¤„ç†ä¸­æ–­

```java
// âœ… æ­£ç¡®å¤„ç†ä¸­æ–­
public void run() {
    try {
        while (!Thread.currentThread().isInterrupted()) {
            doWork();
        }
    } catch (InterruptedException e) {
        // æ¢å¤ä¸­æ–­çŠ¶æ€
        Thread.currentThread().interrupt();
        // æ¸…ç†èµ„æº
        cleanup();
    }
}
```

---

#### å®è·µ3ï¼šé¿å…åœ¨å¾ªç¯ä¸­ä½¿ç”¨wait

```java
// âŒ é”™è¯¯ï¼šä½¿ç”¨if
synchronized (lock) {
    if (!condition) {
        lock.wait();
    }
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨while
synchronized (lock) {
    while (!condition) {
        lock.wait();
    }
}
```

---

#### å®è·µ4ï¼šä½¿ç”¨çº¿ç¨‹æ± è€Œéæ‰‹åŠ¨åˆ›å»ºçº¿ç¨‹

```java
// âŒ ä¸æ¨è
for (int i = 0; i < 1000; i++) {
    new Thread(() -> {
        doWork();
    }).start();
}

// âœ… æ¨è
ExecutorService executor = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    executor.execute(() -> {
        doWork();
    });
}
executor.shutdown();
```

---

#### å®è·µ5ï¼šè®¾ç½®æœ‰æ„ä¹‰çš„çº¿ç¨‹å

```java
// âœ… è®¾ç½®çº¿ç¨‹å
Thread t = new Thread(() -> {
    // ä»»åŠ¡
}, "MyTask-Worker");

// âœ… ä½¿ç”¨ThreadFactory
ThreadFactory factory = new ThreadFactoryBuilder()
    .setNameFormat("worker-%d")
    .build();
```

---

#### å®è·µ6ï¼šå¤„ç†æœªæ•è·å¼‚å¸¸

```java
// âœ… è®¾ç½®å¼‚å¸¸å¤„ç†å™¨
Thread t = new Thread(() -> {
    // ä»»åŠ¡
});
t.setUncaughtExceptionHandler((thread, throwable) -> {
    System.err.println("çº¿ç¨‹ " + thread.getName() + " å¼‚å¸¸:");
    throwable.printStackTrace();
});
```

---

#### å®è·µ7ï¼šThreadLocalä½¿ç”¨åå¿…é¡»remove

```java
// âœ… æ­£ç¡®ä½¿ç”¨ThreadLocal
public void process() {
    try {
        threadLocal.set(value);
        doWork();
    } finally {
        threadLocal.remove(); // å¿…é¡»æ¸…ç†
    }
}
```

---

## 6. æ ¸å¿ƒé—®é¢˜æ€»ç»“

### Q1: Thread.start()çš„æ ¸å¿ƒè®¾è®¡æ˜¯ä»€ä¹ˆï¼Ÿ
**A**: çŠ¶æ€æ£€æŸ¥ + çº¿ç¨‹ç»„ç®¡ç† + å¼‚å¸¸å¤„ç†ï¼Œä¿è¯çº¿ç¨‹å®‰å…¨å¯åŠ¨ã€‚

### Q2: wait()ä¸ºä»€ä¹ˆå¿…é¡»åœ¨synchronizedå—ä¸­ï¼Ÿ
**A**: é˜²æ­¢ç«æ€æ¡ä»¶ï¼Œä¿è¯åŸå­æ€§æ£€æŸ¥æ¡ä»¶å’Œè¿›å…¥ç­‰å¾…ã€‚

### Q3: notify()å”¤é†’çº¿ç¨‹åï¼Œçº¿ç¨‹ç«‹å³æ‰§è¡Œå—ï¼Ÿ
**A**: ä¸æ˜¯ï¼Œçº¿ç¨‹ä»waité˜Ÿåˆ—ç§»åˆ°entryé˜Ÿåˆ—ï¼Œéœ€è¦ç«äº‰é”ã€‚

### Q4: Threadç±»æœ‰å“ªäº›å€¼å¾—å€Ÿé‰´çš„è®¾è®¡ï¼Ÿ
**A**: æ¨¡æ¿æ–¹æ³•æ¨¡å¼ã€çŠ¶æ€æ¨¡å¼ã€ä¸­æ–­æœºåˆ¶ã€ç­‰å¾…-é€šçŸ¥æ¨¡å¼ã€‚

### Q5: çº¿ç¨‹ä½¿ç”¨çš„æœ€é‡è¦å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ
**A**: ä¼˜å…ˆä½¿ç”¨é«˜å±‚å¹¶å‘å·¥å…·ï¼Œæ­£ç¡®å¤„ç†ä¸­æ–­ï¼Œä½¿ç”¨çº¿ç¨‹æ± ã€‚

### Q6: ThreadLocalæœ€å®¹æ˜“çŠ¯çš„é”™è¯¯æ˜¯ä»€ä¹ˆï¼Ÿ
**A**: ä½¿ç”¨åä¸removeï¼Œå¯¼è‡´å†…å­˜æ³„æ¼ï¼Œç‰¹åˆ«æ˜¯åœ¨çº¿ç¨‹æ± ä¸­ã€‚

---

## æ€»ç»“

é€šè¿‡æœ¬ç³»åˆ—çš„å­¦ä¹ ï¼Œæˆ‘ä»¬æ·±å…¥ç†è§£äº†ï¼š

1. **çº¿ç¨‹åŸºç¡€**ï¼šç”Ÿå‘½å‘¨æœŸã€çŠ¶æ€è½¬æ¢ã€åˆ›å»ºæ–¹å¼
2. **åä½œæœºåˆ¶**ï¼šsleepã€joinã€yieldã€wait/notify
3. **ä¸­æ–­æœºåˆ¶**ï¼šinterruptã€å®ˆæŠ¤çº¿ç¨‹ã€ä¼˜å…ˆçº§ã€ThreadLocal
4. **å¯¹æ¯”åˆ†æ**ï¼šæ‰‹åŠ¨ç®¡ç† vs çº¿ç¨‹æ± 
5. **æºç åˆ†æ**ï¼šThreadã€Objectçš„æ ¸å¿ƒå®ç°
6. **æœ€ä½³å®è·µ**ï¼šå®é™…ç¼–ç ä¸­çš„æ³¨æ„äº‹é¡¹

**æ ¸å¿ƒæ”¶è·**ï¼š

- âœ… ç†è§£çº¿ç¨‹çš„æœ¬è´¨å’Œå·¥ä½œåŸç†
- âœ… æŒæ¡çº¿ç¨‹åä½œçš„å„ç§æœºåˆ¶
- âœ… çŸ¥é“ä½•æ—¶ä½¿ç”¨çº¿ç¨‹æ± ï¼Œä½•æ—¶æ‰‹åŠ¨ç®¡ç†
- âœ… å­¦ä¼šä»æºç ä¸­å€Ÿé‰´ä¼˜ç§€è®¾è®¡
- âœ… æŒæ¡çº¿ç¨‹ä½¿ç”¨çš„æœ€ä½³å®è·µ

**ç»§ç»­å­¦ä¹ **ï¼š

- æ·±å…¥å­¦ä¹ JUCå¹¶å‘åŒ…
- ç ”ç©¶AQSçš„å®ç°åŸç†
- å­¦ä¹ æ— é”ç¼–ç¨‹ï¼ˆCASï¼‰
- äº†è§£Javaå†…å­˜æ¨¡å‹ï¼ˆJMMï¼‰

ğŸš€ çº¿ç¨‹ç³»åˆ—å®Œç»“ï¼
