# 位运算进阶技巧

## 1. 十五个常用位运算技巧

### 技巧1：判断奇偶

```java
// 传统方法
boolean isEven = (num % 2 == 0);

// 位运算（更快）
boolean isEven = (num & 1) == 0;
```

**原理**：
- 偶数的二进制最后一位是0
- 奇数的二进制最后一位是1

```
5:  0101  → 最后一位是1 → 奇数
6:  0110  → 最后一位是0 → 偶数
```

---

### 技巧2：交换两个数（不用临时变量）

```java
// 传统方法
int temp = a;
a = b;
b = temp;

// 位运算
a = a ^ b;
b = a ^ b;  // b = (a ^ b) ^ b = a
a = a ^ b;  // a = (a ^ b) ^ a = b
```

**原理**：异或的特性
- `a ^ a = 0`
- `a ^ 0 = a`
- `a ^ b ^ b = a`

**注意**：这个技巧只是炫技，实际开发中不推荐（可读性差）

---

### 技巧3：判断是否为2的幂次

```java
boolean isPowerOfTwo = (num > 0) && ((num & (num - 1)) == 0);
```

**原理**：2的幂次的二进制只有一个1

```
1:   0001  →  0:  0000  →  1 & 0 = 0  ✓
2:   0010  →  1:  0001  →  2 & 1 = 0  ✓
4:   0100  →  3:  0011  →  4 & 3 = 0  ✓
8:   1000  →  7:  0111  →  8 & 7 = 0  ✓
6:   0110  →  5:  0101  →  6 & 5 = 4  ✗
```

---

### 技巧4：计算二进制中1的个数

```java
// 方法1：逐位检查
int count = 0;
while (num != 0) {
    count += num & 1;
    num >>= 1;
}

// 方法2：Brian Kernighan算法（更快）
int count = 0;
while (num != 0) {
    num &= (num - 1);  // 每次消除最右边的1
    count++;
}
```

**原理**：`num & (num - 1)` 会消除最右边的1

```
12:  1100
11:  1011
12 & 11 = 1000  （消除了最右边的1）

8:   1000
7:   0111
8 & 7 = 0000  （消除了最右边的1）
```

---

### 技巧5：获取最右边的1

```java
int rightmostOne = num & (-num);
```

**原理**：负数是补码表示

```
12:   00001100
-12:  11110100  （补码）
12 & -12 = 00000100 = 4  （最右边的1）
```

**应用**：树状数组（Fenwick Tree）的核心操作

---

### 技巧6：消除最右边的1

```java
int result = num & (num - 1);
```

**原理**：

```
12:  1100
11:  1011
12 & 11 = 1000  （消除了最右边的1）
```

**应用**：
- 计算1的个数
- 判断是否为2的幂次

---

### 技巧7：获取第n位的值

```java
// 获取第n位（从右往左，从0开始）
int bit = (num >> n) & 1;
```

**原理**：

```
num = 13 = 1101
获取第2位：
  1101 >> 2 = 0011
  0011 & 1 = 1
```

---

### 技巧8：设置第n位为1

```java
num |= (1 << n);
```

**原理**：

```
num = 5 = 0101
设置第1位为1：
  1 << 1 = 0010
  0101 | 0010 = 0111 = 7
```

---

### 技巧9：设置第n位为0

```java
num &= ~(1 << n);
```

**原理**：

```
num = 7 = 0111
设置第1位为0：
  1 << 1 = 0010
  ~0010 = 1101
  0111 & 1101 = 0101 = 5
```

---

### 技巧10：切换第n位（0变1，1变0）

```java
num ^= (1 << n);
```

**原理**：

```
num = 5 = 0101
切换第1位：
  1 << 1 = 0010
  0101 ^ 0010 = 0111 = 7

再切换第1位：
  0111 ^ 0010 = 0101 = 5
```

---

### 技巧11：快速乘除2的幂次

```java
// 乘法
int result = num * 8;    // 传统
int result = num << 3;   // 位运算（更快）

// 除法
int result = num / 8;    // 传统
int result = num >> 3;   // 位运算（更快）
```

**注意**：
- 左移：`num << n` = `num × 2ⁿ`
- 右移：`num >> n` = `num ÷ 2ⁿ`（向下取整）

---

### 技巧12：取绝对值（不用if）

```java
// 传统方法
int abs = (num < 0) ? -num : num;

// 位运算
int mask = num >> 31;  // 负数为-1，正数为0
int abs = (num + mask) ^ mask;
```

**原理**：
- 正数：`mask = 0`，`(num + 0) ^ 0 = num`
- 负数：`mask = -1`，`(num - 1) ^ -1 = -num`

**注意**：这个技巧只是炫技，实际开发中用 `Math.abs()` 更好

---

### 技巧13：求两个数的平均值（防溢出）

```java
// 传统方法（可能溢出）
int avg = (a + b) / 2;

// 位运算（不会溢出）
int avg = (a & b) + ((a ^ b) >> 1);
```

**原理**：
- `a & b`：两个数都是1的位
- `a ^ b`：两个数不同的位
- `(a ^ b) >> 1`：不同位的平均值

---

### 技巧14：判断符号是否相同

```java
boolean sameSign = (a ^ b) >= 0;
```

**原理**：
- 符号相同：最高位相同，异或后最高位为0（正数）
- 符号不同：最高位不同，异或后最高位为1（负数）

---

### 技巧15：找出唯一的数（其他数都出现两次）

```java
int findUnique(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}
```

**原理**：
- `a ^ a = 0`
- `a ^ 0 = a`
- 所有出现两次的数异或后为0，剩下的就是唯一的数

**例子**：

```
nums = [1, 2, 3, 2, 1]
result = 0 ^ 1 ^ 2 ^ 3 ^ 2 ^ 1
       = (1 ^ 1) ^ (2 ^ 2) ^ 3
       = 0 ^ 0 ^ 3
       = 3
```

---

## 2. 位掩码（Bitmask）

### 2.1 什么是位掩码？

**位掩码**就是用一个整数的每一位来表示一个状态或选项。

**类比**：想象一个筛子，每个孔代表一个选项，孔开着（1）表示选中，孔关着（0）表示未选中。

---

### 2.2 权限管理示例

```java
// 定义权限（每个权限占一位）
int READ    = 1 << 0;  // 0001 = 1
int WRITE   = 1 << 1;  // 0010 = 2
int EXECUTE = 1 << 2;  // 0100 = 4
int DELETE  = 1 << 3;  // 1000 = 8

// 授予权限（使用 |）
int permission = 0;
permission |= READ;     // 0001
permission |= WRITE;    // 0011（可读可写）

// 检查权限（使用 &）
boolean canRead = (permission & READ) != 0;     // true
boolean canExecute = (permission & EXECUTE) != 0;  // false

// 撤销权限（使用 &~）
permission &= ~WRITE;   // 0001（只剩读权限）

// 切换权限（使用 ^）
permission ^= READ;     // 0000（关闭读权限）
permission ^= READ;     // 0001（重新打开读权限）
```

---

### 2.3 状态管理示例

```java
// 定义状态（每个状态占一位）
int BOLD      = 1 << 0;  // 0001 = 1（粗体）
int ITALIC    = 1 << 1;  // 0010 = 2（斜体）
int UNDERLINE = 1 << 2;  // 0100 = 4（下划线）
int STRIKEOUT = 1 << 3;  // 1000 = 8（删除线）

// 设置样式
int style = BOLD | ITALIC;  // 0011（粗体 + 斜体）

// 检查样式
boolean isBold = (style & BOLD) != 0;  // true
boolean isUnderline = (style & UNDERLINE) != 0;  // false

// 添加样式
style |= UNDERLINE;  // 0111（粗体 + 斜体 + 下划线）

// 移除样式
style &= ~ITALIC;  // 0101（粗体 + 下划线）
```

---

### 2.4 集合操作

用位掩码表示集合，可以高效地进行集合运算。

```java
// 集合A = {1, 3, 5}
int setA = (1 << 1) | (1 << 3) | (1 << 5);  // 0101010

// 集合B = {2, 3, 4}
int setB = (1 << 2) | (1 << 3) | (1 << 4);  // 0011100

// 并集（A ∪ B）
int union = setA | setB;  // 0111110 = {1, 2, 3, 4, 5}

// 交集（A ∩ B）
int intersection = setA & setB;  // 0001000 = {3}

// 差集（A - B）
int difference = setA & ~setB;  // 0100010 = {1, 5}

// 对称差集（A △ B）
int symmetricDiff = setA ^ setB;  // 0110110 = {1, 2, 4, 5}
```

---

## 3. 位运算优化技巧

### 3.1 用位运算代替模运算

```java
// 传统方法
int remainder = num % 8;

// 位运算（仅适用于2的幂次）
int remainder = num & 7;  // 7 = 8 - 1 = 0111
```

**原理**：`num % 2ⁿ` = `num & (2ⁿ - 1)`

**注意**：只适用于除数是2的幂次的情况

---

### 3.2 用位运算代替乘除法

```java
// 乘法
int result = num * 8;
int result = num << 3;  // 更快

// 除法
int result = num / 8;
int result = num >> 3;  // 更快
```

**注意**：
- 现代编译器会自动优化，手动优化意义不大
- 可读性更重要

---

### 3.3 循环展开

```java
// 传统方法
for (int i = 0; i < 8; i++) {
    if ((num & (1 << i)) != 0) {
        // 处理第i位
    }
}

// 展开（更快，但代码更长）
if ((num & 0x01) != 0) { /* 处理第0位 */ }
if ((num & 0x02) != 0) { /* 处理第1位 */ }
if ((num & 0x04) != 0) { /* 处理第2位 */ }
// ...
```

---

## 4. 位运算的性能分析

### 4.1 性能对比

| 操作 | 传统方法 | 位运算 | 性能提升 |
|------|----------|--------|----------|
| 判断奇偶 | `num % 2` | `num & 1` | ~2倍 |
| 乘以2 | `num * 2` | `num << 1` | ~1.5倍 |
| 除以2 | `num / 2` | `num >> 1` | ~2倍 |
| 取模 | `num % 8` | `num & 7` | ~3倍 |

**注意**：
- 现代编译器会自动优化，性能差距不大
- 可读性 > 性能（除非在性能关键路径上）

---

### 4.2 何时使用位运算？

**推荐使用**：
1. **权限管理**：用位掩码管理权限
2. **状态管理**：用位掩码管理状态
3. **算法题**：LeetCode等算法题
4. **底层开发**：操作系统、驱动、嵌入式

**不推荐使用**：
1. **业务逻辑**：可读性差，容易出错
2. **过早优化**：先保证正确性，再考虑性能

---

## 5. 常见陷阱

### 陷阱1：优先级问题

```java
// 错误写法
if (num & 1 == 0) {  // 实际是: num & (1 == 0)
    // ...
}

// 正确写法
if ((num & 1) == 0) {
    // ...
}
```

**建议**：位运算时多加括号！

---

### 陷阱2：移位超过位数

```java
int num = 1;
System.out.println(num << 32);  // 1（不是0！）
System.out.println(num << 33);  // 2（相当于 << 1）
```

**原因**：Java会对移位数取模
- `int` 类型：`n % 32`
- `long` 类型：`n % 64`

---

### 陷阱3：负数的右移

```java
int num = -10;
System.out.println(num >> 1);   // -5（算术右移，补1）
System.out.println(num >>> 1);  // 2147483643（逻辑右移，补0）
```

**建议**：
- 对负数右移时，明确使用 `>>` 还是 `>>>`
- 通常用 `>>` 保持符号

---

### 陷阱4：位运算不适用于浮点数

```java
// 错误！位运算只能用于整数
double num = 3.14;
// num & 1;  // 编译错误
```

---

## 6. 实战练习

### 练习1：反转二进制位

```java
// 例如：00000010100101000001111010011100
// 反转后：00111001011110000010100101000000

public int reverseBits(int n) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
        result <<= 1;           // 左移一位
        result |= (n & 1);      // 取出最后一位，加到result
        n >>= 1;                // n右移一位
    }
    return result;
}
```

---

### 练习2：汉明距离

```java
// 计算两个数的二进制中不同位的个数
// 例如：1 (0001) 和 4 (0100) 的汉明距离是 2

public int hammingDistance(int x, int y) {
    int xor = x ^ y;  // 不同的位为1
    int count = 0;
    while (xor != 0) {
        xor &= (xor - 1);  // 消除最右边的1
        count++;
    }
    return count;
}
```

---

### 练习3：只出现一次的数字

```java
// 数组中除了一个数字只出现一次，其他都出现两次，找出这个数字
// 例如：[2, 2, 1] → 1

public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}
```

---

## 7. 总结

### 7.1 核心技巧

1. **判断奇偶**：`num & 1`
2. **判断2的幂次**：`num & (num - 1) == 0`
3. **计算1的个数**：`num &= (num - 1)`
4. **获取最右边的1**：`num & (-num)`
5. **设置第n位为1**：`num |= (1 << n)`
6. **设置第n位为0**：`num &= ~(1 << n)`
7. **切换第n位**：`num ^= (1 << n)`

### 7.2 位掩码应用

1. **权限管理**：用位表示权限
2. **状态管理**：用位表示状态
3. **集合操作**：用位表示集合

### 7.3 注意事项

1. **多加括号**：位运算符优先级低
2. **注意移位范围**：不要超过位数
3. **注意负数**：右移时区分 `>>` 和 `>>>`
4. **可读性优先**：不要过度优化

---

## 8. 下一步

学完进阶技巧后，可以继续学习：
- **03_位运算实战应用.md**：权限管理、状态管理等实际应用
- **BitwiseSkillsDemo.java**：运行代码，观察效果
