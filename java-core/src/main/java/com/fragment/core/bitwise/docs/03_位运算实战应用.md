# 位运算实战应用

## 1. 权限管理系统

### 1.1 场景描述

在实际项目中，我们经常需要管理用户权限，比如：
- 文件系统：读、写、执行
- 后台管理：查看、编辑、删除、审核
- 社交应用：发帖、评论、点赞、分享

传统方法是用多个布尔字段，但这样会导致：
- 字段太多，难以维护
- 查询效率低
- 扩展性差

**位运算方案**：用一个整数的每一位表示一个权限。

---

### 1.2 基础实现

```java
public class PermissionManager {
    // 定义权限（每个权限占一位）
    public static final int READ    = 1 << 0;  // 0001 = 1
    public static final int WRITE   = 1 << 1;  // 0010 = 2
    public static final int EXECUTE = 1 << 2;  // 0100 = 4
    public static final int DELETE  = 1 << 3;  // 1000 = 8
    
    private int permission = 0;  // 用户的权限
    
    // 授予权限
    public void grant(int perm) {
        permission |= perm;
    }
    
    // 撤销权限
    public void revoke(int perm) {
        permission &= ~perm;
    }
    
    // 检查权限
    public boolean hasPermission(int perm) {
        return (permission & perm) == perm;
    }
    
    // 切换权限
    public void toggle(int perm) {
        permission ^= perm;
    }
    
    // 清空所有权限
    public void clear() {
        permission = 0;
    }
    
    // 获取所有权限
    public int getPermission() {
        return permission;
    }
}
```

**使用示例**：

```java
PermissionManager pm = new PermissionManager();

// 授予读和写权限
pm.grant(PermissionManager.READ | PermissionManager.WRITE);

// 检查权限
System.out.println(pm.hasPermission(PermissionManager.READ));    // true
System.out.println(pm.hasPermission(PermissionManager.EXECUTE)); // false

// 撤销写权限
pm.revoke(PermissionManager.WRITE);
System.out.println(pm.hasPermission(PermissionManager.WRITE));   // false
```

---

### 1.3 进阶实现：角色权限

```java
public class RolePermissionManager {
    // 定义权限
    public static final int VIEW   = 1 << 0;  // 查看
    public static final int EDIT   = 1 << 1;  // 编辑
    public static final int DELETE = 1 << 2;  // 删除
    public static final int AUDIT  = 1 << 3;  // 审核
    public static final int EXPORT = 1 << 4;  // 导出
    
    // 定义角色（角色是权限的组合）
    public static final int ROLE_GUEST  = VIEW;                           // 访客
    public static final int ROLE_USER   = VIEW | EDIT;                    // 普通用户
    public static final int ROLE_ADMIN  = VIEW | EDIT | DELETE | EXPORT;  // 管理员
    public static final int ROLE_SUPER  = VIEW | EDIT | DELETE | AUDIT | EXPORT;  // 超级管理员
    
    private int permission;
    
    public RolePermissionManager(int role) {
        this.permission = role;
    }
    
    // 检查是否有某个权限
    public boolean can(int perm) {
        return (permission & perm) == perm;
    }
    
    // 添加额外权限
    public void addPermission(int perm) {
        permission |= perm;
    }
    
    // 移除权限
    public void removePermission(int perm) {
        permission &= ~perm;
    }
    
    // 打印权限
    public void printPermissions() {
        System.out.println("当前权限：");
        if (can(VIEW))   System.out.println("- 查看");
        if (can(EDIT))   System.out.println("- 编辑");
        if (can(DELETE)) System.out.println("- 删除");
        if (can(AUDIT))  System.out.println("- 审核");
        if (can(EXPORT)) System.out.println("- 导出");
    }
}
```

**使用示例**：

```java
// 创建一个管理员
RolePermissionManager admin = new RolePermissionManager(RolePermissionManager.ROLE_ADMIN);
admin.printPermissions();
// 输出：
// 当前权限：
// - 查看
// - 编辑
// - 删除
// - 导出

// 给管理员添加审核权限
admin.addPermission(RolePermissionManager.AUDIT);
System.out.println(admin.can(RolePermissionManager.AUDIT));  // true
```

---

### 1.4 数据库存储

在数据库中，只需要一个整数字段存储权限：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    permission INT  -- 用一个整数存储所有权限
);

-- 插入数据
INSERT INTO users VALUES (1, 'admin', 31);  -- 31 = 11111（所有权限）
INSERT INTO users VALUES (2, 'user', 3);    -- 3 = 00011（查看+编辑）

-- 查询有删除权限的用户
SELECT * FROM users WHERE (permission & 4) = 4;
```

---

## 2. 状态管理

### 2.1 场景描述

在实际项目中，一个对象可能有多个状态，比如：
- 订单状态：待支付、已支付、已发货、已完成、已取消
- 任务状态：未开始、进行中、已暂停、已完成
- 文本样式：粗体、斜体、下划线、删除线

**位运算方案**：用一个整数的每一位表示一个状态。

---

### 2.2 文本样式管理

```java
public class TextStyle {
    // 定义样式
    public static final int BOLD      = 1 << 0;  // 粗体
    public static final int ITALIC    = 1 << 1;  // 斜体
    public static final int UNDERLINE = 1 << 2;  // 下划线
    public static final int STRIKEOUT = 1 << 3;  // 删除线
    
    private int style = 0;
    
    // 应用样式
    public void applyStyle(int s) {
        style |= s;
    }
    
    // 移除样式
    public void removeStyle(int s) {
        style &= ~s;
    }
    
    // 切换样式
    public void toggleStyle(int s) {
        style ^= s;
    }
    
    // 检查样式
    public boolean hasStyle(int s) {
        return (style & s) == s;
    }
    
    // 清空样式
    public void clearStyle() {
        style = 0;
    }
    
    // 获取HTML标签
    public String toHtml(String text) {
        StringBuilder sb = new StringBuilder(text);
        if (hasStyle(BOLD))      sb.insert(0, "<b>").append("</b>");
        if (hasStyle(ITALIC))    sb.insert(0, "<i>").append("</i>");
        if (hasStyle(UNDERLINE)) sb.insert(0, "<u>").append("</u>");
        if (hasStyle(STRIKEOUT)) sb.insert(0, "<s>").append("</s>");
        return sb.toString();
    }
}
```

**使用示例**：

```java
TextStyle style = new TextStyle();
style.applyStyle(TextStyle.BOLD | TextStyle.ITALIC);
System.out.println(style.toHtml("Hello"));  // <i><b>Hello</b></i>

style.toggleStyle(TextStyle.ITALIC);  // 关闭斜体
System.out.println(style.toHtml("Hello"));  // <b>Hello</b>
```

---

### 2.3 订单状态管理

```java
public class OrderStatus {
    // 定义状态
    public static final int UNPAID    = 1 << 0;  // 待支付
    public static final int PAID      = 1 << 1;  // 已支付
    public static final int SHIPPED   = 1 << 2;  // 已发货
    public static final int COMPLETED = 1 << 3;  // 已完成
    public static final int CANCELLED = 1 << 4;  // 已取消
    
    private int status;
    
    public OrderStatus() {
        this.status = UNPAID;  // 初始状态：待支付
    }
    
    // 支付
    public void pay() {
        if (hasStatus(UNPAID)) {
            status &= ~UNPAID;  // 移除待支付状态
            status |= PAID;     // 添加已支付状态
        }
    }
    
    // 发货
    public void ship() {
        if (hasStatus(PAID)) {
            status |= SHIPPED;
        }
    }
    
    // 完成
    public void complete() {
        if (hasStatus(SHIPPED)) {
            status |= COMPLETED;
        }
    }
    
    // 取消
    public void cancel() {
        status = CANCELLED;
    }
    
    // 检查状态
    public boolean hasStatus(int s) {
        return (status & s) == s;
    }
    
    // 获取状态描述
    public String getStatusDescription() {
        if (hasStatus(CANCELLED)) return "已取消";
        if (hasStatus(COMPLETED)) return "已完成";
        if (hasStatus(SHIPPED))   return "已发货";
        if (hasStatus(PAID))      return "已支付";
        if (hasStatus(UNPAID))    return "待支付";
        return "未知状态";
    }
}
```

---

## 3. 数据压缩

### 3.1 布尔数组压缩

如果有大量布尔值需要存储，可以用位运算压缩。

```java
public class BitArray {
    private int[] data;
    private int size;
    
    public BitArray(int size) {
        this.size = size;
        this.data = new int[(size + 31) / 32];  // 每个int存32位
    }
    
    // 设置第i位为true
    public void set(int i) {
        if (i < 0 || i >= size) throw new IndexOutOfBoundsException();
        int index = i / 32;      // 在哪个int中
        int bit = i % 32;        // 在int的哪一位
        data[index] |= (1 << bit);
    }
    
    // 设置第i位为false
    public void clear(int i) {
        if (i < 0 || i >= size) throw new IndexOutOfBoundsException();
        int index = i / 32;
        int bit = i % 32;
        data[index] &= ~(1 << bit);
    }
    
    // 获取第i位
    public boolean get(int i) {
        if (i < 0 || i >= size) throw new IndexOutOfBoundsException();
        int index = i / 32;
        int bit = i % 32;
        return (data[index] & (1 << bit)) != 0;
    }
    
    // 切换第i位
    public void toggle(int i) {
        if (i < 0 || i >= size) throw new IndexOutOfBoundsException();
        int index = i / 32;
        int bit = i % 32;
        data[index] ^= (1 << bit);
    }
}
```

**内存节省**：
- 传统方法：1000个布尔值 = 1000字节
- 位运算方法：1000个布尔值 = 125字节（节省87.5%）

---

### 3.2 Java内置的BitSet

Java提供了 `BitSet` 类，功能更强大：

```java
import java.util.BitSet;

BitSet bitSet = new BitSet(100);

// 设置
bitSet.set(5);
bitSet.set(10);
bitSet.set(15);

// 获取
System.out.println(bitSet.get(5));   // true
System.out.println(bitSet.get(6));   // false

// 清除
bitSet.clear(5);

// 位运算
BitSet bs1 = new BitSet();
bs1.set(1);
bs1.set(3);

BitSet bs2 = new BitSet();
bs2.set(2);
bs2.set(3);

bs1.and(bs2);  // 交集
bs1.or(bs2);   // 并集
bs1.xor(bs2);  // 异或
```

---

## 4. 算法优化

### 4.1 子集枚举

用位运算枚举一个集合的所有子集。

```java
public class SubsetEnumerator {
    // 枚举集合 {0, 1, 2, ..., n-1} 的所有子集
    public static void enumerateSubsets(int n) {
        int total = 1 << n;  // 总共有 2^n 个子集
        
        for (int mask = 0; mask < total; mask++) {
            System.out.print("{ ");
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) != 0) {
                    System.out.print(i + " ");
                }
            }
            System.out.println("}");
        }
    }
}
```

**例子**：枚举 {0, 1, 2} 的所有子集

```
mask = 0 (000): { }
mask = 1 (001): { 0 }
mask = 2 (010): { 1 }
mask = 3 (011): { 0 1 }
mask = 4 (100): { 2 }
mask = 5 (101): { 0 2 }
mask = 6 (110): { 1 2 }
mask = 7 (111): { 0 1 2 }
```

---

### 4.2 状态压缩DP

在动态规划中，用位运算压缩状态。

**例子**：旅行商问题（TSP）

```java
public class TSP {
    // dp[mask][i] 表示：已访问的城市集合为mask，当前在城市i的最短路径
    public int tsp(int[][] dist) {
        int n = dist.length;
        int[][] dp = new int[1 << n][n];
        
        // 初始化
        for (int[] row : dp) {
            Arrays.fill(row, Integer.MAX_VALUE / 2);
        }
        dp[1][0] = 0;  // 从城市0出发
        
        // 状态转移
        for (int mask = 1; mask < (1 << n); mask++) {
            for (int i = 0; i < n; i++) {
                if ((mask & (1 << i)) == 0) continue;  // 城市i未访问
                
                for (int j = 0; j < n; j++) {
                    if ((mask & (1 << j)) != 0) continue;  // 城市j已访问
                    
                    int newMask = mask | (1 << j);
                    dp[newMask][j] = Math.min(dp[newMask][j], dp[mask][i] + dist[i][j]);
                }
            }
        }
        
        // 找最小值
        int result = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            result = Math.min(result, dp[(1 << n) - 1][i] + dist[i][0]);
        }
        return result;
    }
}
```

---

## 5. LeetCode经典题目

### 5.1 只出现一次的数字

**题目**：数组中除了一个数字只出现一次，其他都出现两次，找出这个数字。

```java
public int singleNumber(int[] nums) {
    int result = 0;
    for (int num : nums) {
        result ^= num;
    }
    return result;
}
```

**原理**：`a ^ a = 0`，`a ^ 0 = a`

---

### 5.2 只出现一次的数字 II

**题目**：数组中除了一个数字只出现一次，其他都出现三次，找出这个数字。

```java
public int singleNumber(int[] nums) {
    int ones = 0, twos = 0;
    for (int num : nums) {
        ones = (ones ^ num) & ~twos;
        twos = (twos ^ num) & ~ones;
    }
    return ones;
}
```

---

### 5.3 汉明距离

**题目**：计算两个数的二进制中不同位的个数。

```java
public int hammingDistance(int x, int y) {
    int xor = x ^ y;
    int count = 0;
    while (xor != 0) {
        xor &= (xor - 1);  // 消除最右边的1
        count++;
    }
    return count;
}
```

---

### 5.4 比特位计数

**题目**：给定一个非负整数 num，对于 0 ≤ i ≤ num 范围中的每个数字 i，计算其二进制数中的 1 的数目。

```java
public int[] countBits(int num) {
    int[] result = new int[num + 1];
    for (int i = 1; i <= num; i++) {
        result[i] = result[i >> 1] + (i & 1);
    }
    return result;
}
```

**原理**：
- `i >> 1` 是 `i` 除以2
- `i & 1` 是 `i` 的最后一位
- `result[i] = result[i/2] + i的最后一位`

---

### 5.5 颠倒二进制位

**题目**：颠倒给定的 32 位无符号整数的二进制位。

```java
public int reverseBits(int n) {
    int result = 0;
    for (int i = 0; i < 32; i++) {
        result <<= 1;
        result |= (n & 1);
        n >>= 1;
    }
    return result;
}
```

---

## 6. 实际项目应用

### 6.1 布隆过滤器（Bloom Filter）

布隆过滤器用于快速判断一个元素是否在集合中，常用于：
- 网页URL去重
- 垃圾邮件过滤
- 缓存穿透防护

```java
import java.util.BitSet;

public class BloomFilter {
    private BitSet bitSet;
    private int size;
    private int hashFunctionCount;
    
    public BloomFilter(int size, int hashFunctionCount) {
        this.size = size;
        this.hashFunctionCount = hashFunctionCount;
        this.bitSet = new BitSet(size);
    }
    
    // 添加元素
    public void add(String element) {
        for (int i = 0; i < hashFunctionCount; i++) {
            int hash = hash(element, i);
            bitSet.set(hash % size);
        }
    }
    
    // 检查元素是否存在
    public boolean mightContain(String element) {
        for (int i = 0; i < hashFunctionCount; i++) {
            int hash = hash(element, i);
            if (!bitSet.get(hash % size)) {
                return false;  // 一定不存在
            }
        }
        return true;  // 可能存在
    }
    
    // 哈希函数
    private int hash(String element, int seed) {
        int hash = 0;
        for (char c : element.toCharArray()) {
            hash = hash * 31 + c + seed;
        }
        return Math.abs(hash);
    }
}
```

---

### 6.2 IP地址黑名单

用位运算快速判断IP是否在黑名单中。

```java
public class IPBlacklist {
    private BitSet blacklist = new BitSet(1 << 24);  // 支持 16777216 个IP
    
    // 添加IP到黑名单
    public void add(String ip) {
        int index = ipToInt(ip);
        blacklist.set(index);
    }
    
    // 检查IP是否在黑名单中
    public boolean contains(String ip) {
        int index = ipToInt(ip);
        return blacklist.get(index);
    }
    
    // IP转整数
    private int ipToInt(String ip) {
        String[] parts = ip.split("\\.");
        int result = 0;
        for (int i = 0; i < 4; i++) {
            result = (result << 8) | Integer.parseInt(parts[i]);
        }
        return result;
    }
}
```

---

## 7. 总结

### 7.1 位运算的应用场景

| 场景 | 优势 | 示例 |
|------|------|------|
| 权限管理 | 节省空间，查询快 | 文件权限、用户权限 |
| 状态管理 | 多状态并存 | 订单状态、文本样式 |
| 数据压缩 | 节省内存 | 布尔数组、位图 |
| 算法优化 | 提高效率 | 子集枚举、状态压缩DP |
| 去重过滤 | 快速判断 | 布隆过滤器、IP黑名单 |

### 7.2 何时使用位运算？

**推荐使用**：
1. 权限和状态管理
2. 大量布尔值存储
3. 算法竞赛和面试
4. 性能关键路径

**不推荐使用**：
1. 业务逻辑复杂时（可读性差）
2. 团队成员不熟悉时
3. 过早优化

### 7.3 最佳实践

1. **用常量定义位掩码**：提高可读性
2. **添加注释**：说明每一位的含义
3. **封装操作**：提供清晰的API
4. **单元测试**：确保正确性

---

## 8. 下一步

学完实战应用后，可以：
1. 运行 `BitwisePracticalDemo.java`，观察实际效果
2. 在LeetCode上练习位运算题目
3. 在实际项目中应用位运算
