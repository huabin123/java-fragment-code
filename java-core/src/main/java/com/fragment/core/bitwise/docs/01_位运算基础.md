# 位运算基础

## 1. 什么是位运算？

### 1.1 生活中的类比

想象你家里有8个灯泡，每个灯泡有两种状态：**开（1）** 或 **关（0）**

```
灯泡编号:  7    6    5    4    3    2    1    0
状态:     💡   ⚫   💡   ⚫   💡   💡   ⚫   💡
二进制:    1    0    1    0    1    1    0    1
```

这就是一个8位的二进制数：`10101101`，转换成十进制就是 `173`

**位运算**就是直接操作这些"灯泡"的开关状态。

---

## 2. 二进制基础

### 2.1 什么是二进制？

我们平时用的是**十进制**（0-9），计算机用的是**二进制**（0-1）

**十进制转二进制**：不断除以2，取余数

```
13 ÷ 2 = 6 ... 余 1  ↑
 6 ÷ 2 = 3 ... 余 0  |
 3 ÷ 2 = 1 ... 余 1  |
 1 ÷ 2 = 0 ... 余 1  |

从下往上读：1101
所以 13(十进制) = 1101(二进制)
```

**二进制转十进制**：每一位乘以2的幂次

```
1101(二进制) = 1×2³ + 1×2² + 0×2¹ + 1×2⁰
            = 8 + 4 + 0 + 1
            = 13(十进制)
```

### 2.2 Java中如何查看二进制？

```java
int num = 13;
String binary = Integer.toBinaryString(num);
System.out.println(binary);  // 输出: 1101

// 补齐32位（int是32位）
String binary32 = String.format("%32s", binary).replace(' ', '0');
System.out.println(binary32);  // 输出: 00000000000000000000000000001101
```

---

## 3. 六种基本位运算符

### 3.1 按位与（&）- 两个都是1才是1

**类比**：两个开关**串联**，都打开灯才亮

```
  5:  0101
& 3:  0011
-----------
  1:  0001
```

**规则**：
- 1 & 1 = 1
- 1 & 0 = 0
- 0 & 1 = 0
- 0 & 0 = 0

**用途**：
1. **判断奇偶**：`num & 1 == 0` 表示偶数
2. **取出某一位**：`num & (1 << n)` 取出第n位
3. **清零某些位**：`num & ~mask` 清零mask对应的位

```java
// 判断奇偶
int num = 5;
if ((num & 1) == 0) {
    System.out.println("偶数");
} else {
    System.out.println("奇数");  // 输出这个
}
```

---

### 3.2 按位或（|）- 有一个是1就是1

**类比**：两个开关**并联**，任意一个打开灯就亮

```
  5:  0101
| 3:  0011
-----------
  7:  0111
```

**规则**：
- 1 | 1 = 1
- 1 | 0 = 1
- 0 | 1 = 1
- 0 | 0 = 0

**用途**：
1. **设置某一位为1**：`num | (1 << n)` 设置第n位为1
2. **合并权限**：`READ | WRITE | EXECUTE`

```java
// 权限管理
int READ = 1;      // 0001
int WRITE = 2;     // 0010
int EXECUTE = 4;   // 0100

int permission = READ | WRITE;  // 0011 = 3（可读可写）
```

---

### 3.3 按位异或（^）- 相同为0，不同为1

**类比**：两个开关控制一个灯，状态不同时灯亮

```
  5:  0101
^ 3:  0011
-----------
  6:  0110
```

**规则**：
- 1 ^ 1 = 0
- 1 ^ 0 = 1
- 0 ^ 1 = 1
- 0 ^ 0 = 0

**特性**：
- `a ^ a = 0`（自己和自己异或等于0）
- `a ^ 0 = a`（和0异或等于自己）
- `a ^ b ^ b = a`（异或两次等于没异或）

**用途**：
1. **交换两个数**（不用临时变量）
2. **找出唯一的数**（其他数都出现两次）
3. **简单加密**

```java
// 交换两个数（不用临时变量）
int a = 5, b = 3;
a = a ^ b;  // a = 5 ^ 3 = 6
b = a ^ b;  // b = 6 ^ 3 = 5
a = a ^ b;  // a = 6 ^ 5 = 3
System.out.println("a=" + a + ", b=" + b);  // a=3, b=5
```

---

### 3.4 按位取反（~）- 0变1，1变0

**类比**：开关反转，开变关，关变开

```
  5:  00000000000000000000000000000101
~ 5:  11111111111111111111111111111010  = -6
```

**规则**：
- ~1 = 0
- ~0 = 1

**注意**：Java中int是32位，取反后最高位是符号位！

**用途**：
1. **快速计算 -n-1**：`~n = -n-1`
2. **位掩码取反**：`~mask`

```java
int num = 5;
System.out.println(~num);  // 输出: -6
// 因为 ~5 = -6
```

---

### 3.5 左移（<<）- 向左移动，右边补0

**类比**：数字乘以2

```
  5:     0101
5 << 1:  1010  = 10（乘以2）
5 << 2: 10100  = 20（乘以4）
```

**规则**：
- `a << n` = `a × 2ⁿ`

**用途**：
1. **快速乘以2的幂次**：`num << 3` 等于 `num × 8`
2. **构造位掩码**：`1 << n` 得到第n位为1的数

```java
int num = 5;
System.out.println(num << 1);  // 10（5 × 2）
System.out.println(num << 2);  // 20（5 × 4）
System.out.println(num << 3);  // 40（5 × 8）

// 构造位掩码
int mask = 1 << 3;  // 0001000 = 8（第3位为1）
```

---

### 3.6 右移（>>）- 向左移动，左边补符号位

**类比**：数字除以2

```
  10:     1010
10 >> 1:  0101  = 5（除以2）
10 >> 2:  0010  = 2（除以4）
```

**规则**：
- `a >> n` = `a ÷ 2ⁿ`（向下取整）

**注意**：
- `>>`：**算术右移**，左边补符号位（正数补0，负数补1）
- `>>>`：**逻辑右移**，左边补0（无论正负）

```java
int num = 10;
System.out.println(num >> 1);  // 5（10 ÷ 2）
System.out.println(num >> 2);  // 2（10 ÷ 4）

// 负数的右移
int neg = -10;
System.out.println(neg >> 1);   // -5（算术右移，补1）
System.out.println(neg >>> 1);  // 2147483643（逻辑右移，补0）
```

---

## 4. 负数的二进制表示（补码）

### 4.1 为什么需要补码？

计算机中，负数用**补码**表示，这样可以统一加减法运算。

### 4.2 补码的计算方法

**原码** → **反码** → **补码**

1. **原码**：符号位 + 绝对值的二进制
2. **反码**：符号位不变，其他位取反
3. **补码**：反码 + 1

**例子：-5的补码**

```
5的原码:  00000000000000000000000000000101
5的反码:  11111111111111111111111111111010（符号位不变，其他位取反）
5的补码:  11111111111111111111111111111011（反码 + 1）
```

所以 `-5` 的二进制是 `11111111111111111111111111111011`

### 4.3 为什么这样设计？

这样设计的好处是：**加法和减法可以统一处理**

```
  5:  00000000000000000000000000000101
+ -5: 11111111111111111111111111111011
-------------------------------------
  0: 100000000000000000000000000000000（溢出的1被丢弃）
```

### 4.4 快速判断正负

- 最高位是0：正数
- 最高位是1：负数

---

## 5. 常见误区和陷阱

### 5.1 误区1：移位运算符的优先级很低

```java
// 错误写法
if (num & 1 << 2 == 4) {  // 实际是: num & (1 << (2 == 4))
    // ...
}

// 正确写法
if ((num & (1 << 2)) == 4) {
    // ...
}
```

**建议**：位运算时多加括号！

---

### 5.2 误区2：负数的右移

```java
int num = -10;
System.out.println(num >> 1);   // -5（算术右移，补1）
System.out.println(num >>> 1);  // 2147483643（逻辑右移，补0）
```

**建议**：
- 对负数右移时，明确使用 `>>` 还是 `>>>`
- 通常用 `>>` 保持符号

---

### 5.3 误区3：移位超过32位

```java
int num = 1;
System.out.println(num << 32);  // 1（不是0！）
System.out.println(num << 33);  // 2（相当于 << 1）
```

**原因**：Java会对移位数取模
- `int` 类型：`n % 32`
- `long` 类型：`n % 64`

**建议**：移位数不要超过类型的位数

---

### 5.4 误区4：~运算符的结果

```java
int num = 5;
System.out.println(~num);  // -6（不是-5！）
```

**原因**：`~n = -n - 1`

---

## 6. 位运算符优先级

从高到低：

1. `~`（取反）
2. `<<`、`>>`、`>>>`（移位）
3. `&`（与）
4. `^`（异或）
5. `|`（或）

**建议**：不要依赖优先级，多加括号！

---

## 7. 实用小技巧

### 7.1 判断奇偶

```java
// 传统方法
if (num % 2 == 0) { /* 偶数 */ }

// 位运算（更快）
if ((num & 1) == 0) { /* 偶数 */ }
```

---

### 7.2 交换两个数

```java
// 传统方法（需要临时变量）
int temp = a;
a = b;
b = temp;

// 位运算（不需要临时变量）
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

---

### 7.3 快速乘除2的幂次

```java
// 乘法
int result = num * 8;    // 传统方法
int result = num << 3;   // 位运算（更快）

// 除法
int result = num / 8;    // 传统方法
int result = num >> 3;   // 位运算（更快）
```

---

### 7.4 判断2的幂次

```java
// 2的幂次的特点：二进制只有一个1
// 例如：8 = 1000, 16 = 10000

boolean isPowerOfTwo = (num > 0) && ((num & (num - 1)) == 0);
```

**原理**：
- `8`:  1000
- `7`:  0111
- `8 & 7 = 0`

---

## 8. 总结

### 8.1 六种运算符速记

| 运算符 | 名称 | 作用 | 类比 |
|--------|------|------|------|
| `&` | 按位与 | 都是1才是1 | 串联开关 |
| `|` | 按位或 | 有1就是1 | 并联开关 |
| `^` | 按位异或 | 不同为1 | 双控开关 |
| `~` | 按位取反 | 0变1，1变0 | 开关反转 |
| `<<` | 左移 | 乘以2 | 数字放大 |
| `>>` | 右移 | 除以2 | 数字缩小 |

### 8.2 学习建议

1. **多画图**：遇到不理解的，画出二进制的变化过程
2. **多运行代码**：通过观察输出理解原理
3. **多练习**：LeetCode上有很多位运算的题目

---

## 9. 下一步

学完基础后，可以继续学习：
- **02_位运算进阶技巧.md**：15个实用技巧
- **03_位运算实战应用.md**：权限管理、状态管理等实际应用
