# 第二章：注解的定义与元注解

## 问题1：如何定义一个注解？

### 1.1 最简单的注解

```java
public @interface MyAnnotation {
}
```

**使用**：
```java
@MyAnnotation
public class MyClass {
}
```

**关键点**：
- 使用 `@interface` 关键字定义注解
- 注解名称遵循类的命名规范（首字母大写）
- 注解本质上是一个接口，继承自 `java.lang.annotation.Annotation`

### 1.2 带属性的注解

```java
public @interface MyAnnotation {
    String value();  // 定义一个属性
}
```

**使用**：
```java
@MyAnnotation(value = "hello")
public class MyClass {
}

// 如果属性名是value，可以省略属性名
@MyAnnotation("hello")
public class MyClass {
}
```

### 1.3 带默认值的注解

```java
public @interface MyAnnotation {
    String value() default "default value";
    int count() default 0;
    boolean enabled() default true;
}
```

**使用**：
```java
// 使用默认值
@MyAnnotation
public class MyClass1 {
}

// 覆盖默认值
@MyAnnotation(value = "custom", count = 10, enabled = false)
public class MyClass2 {
}

// 只覆盖部分值
@MyAnnotation(count = 5)
public class MyClass3 {
}
```

## 问题2：注解的属性可以是哪些类型？

### 2.1 支持的类型

注解的属性只能是以下8种类型：

1. **基本类型**：`int`, `long`, `short`, `byte`, `char`, `double`, `float`, `boolean`
2. **String**
3. **Class**
4. **枚举（Enum）**
5. **注解**
6. **以上类型的数组**

### 2.2 类型示例

```java
public enum Priority {
    LOW, MEDIUM, HIGH
}

public @interface Task {
    // 1. 基本类型
    int priority() default 0;
    long timeout() default 3000L;
    boolean async() default false;
    
    // 2. String
    String description() default "";
    
    // 3. Class
    Class<?> handlerClass() default Object.class;
    
    // 4. 枚举
    Priority level() default Priority.MEDIUM;
    
    // 5. 注解
    Retry retry() default @Retry;
    
    // 6. 数组
    String[] tags() default {};
    Class<?>[] excludes() default {};
}

public @interface Retry {
    int maxAttempts() default 3;
    long delay() default 1000L;
}
```

**使用示例**：
```java
@Task(
    priority = 1,
    timeout = 5000L,
    async = true,
    description = "处理订单",
    handlerClass = OrderHandler.class,
    level = Priority.HIGH,
    retry = @Retry(maxAttempts = 5, delay = 2000L),
    tags = {"order", "payment"},
    excludes = {TestHandler.class, MockHandler.class}
)
public void processOrder() {
    // 方法实现
}
```

### 2.3 不支持的类型

```java
public @interface InvalidAnnotation {
    // ❌ 不支持Object
    Object value();  // 编译错误
    
    // ❌ 不支持集合
    List<String> items();  // 编译错误
    
    // ❌ 不支持Map
    Map<String, String> properties();  // 编译错误
    
    // ❌ 不支持自定义对象
    User user();  // 编译错误
}
```

## 问题3：什么是元注解？

### 3.1 元注解的定义

**元注解（Meta-Annotation）**：用于注解其他注解的注解。

Java提供了5个标准元注解：
1. `@Retention` - 定义注解的生命周期
2. `@Target` - 定义注解可以用在哪些地方
3. `@Documented` - 定义注解是否包含在JavaDoc中
4. `@Inherited` - 定义注解是否可以被继承
5. `@Repeatable`（Java 8+）- 定义注解是否可以重复使用

## 问题4：@Retention - 注解的生命周期

### 4.1 三种保留策略

```java
public enum RetentionPolicy {
    SOURCE,    // 源码级别，编译后丢弃
    CLASS,     // 字节码级别，运行时不可见（默认）
    RUNTIME    // 运行时级别，可以通过反射读取
}
```

### 4.2 SOURCE - 源码级别

**特点**：
- 只在源代码中存在
- 编译后被丢弃
- 运行时无法获取

**用途**：
- 编译期检查
- 代码生成（APT）

**示例**：
```java
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}

// 使用
public class Child extends Parent {
    @Override  // 编译器检查是否真的覆盖了父类方法
    public void method() {
        // 编译后@Override注解会被丢弃
    }
}
```

**常见的SOURCE级注解**：
- `@Override` - 检查方法覆盖
- `@SuppressWarnings` - 抑制编译警告
- Lombok的注解（`@Data`, `@Getter`, `@Setter`等）

### 4.3 CLASS - 字节码级别

**特点**：
- 保留在字节码中
- 运行时不可见（不能通过反射获取）
- 这是默认的保留策略

**用途**：
- 字节码增强
- APT（Annotation Processing Tool）

**示例**：
```java
@Retention(RetentionPolicy.CLASS)  // 可以省略，这是默认值
public @interface ProcessedBy {
    String value();
}
```

**为什么需要CLASS级别？**

虽然运行时无法获取，但可以在编译时或类加载时处理：

```java
// 字节码增强工具（如ASM、Javassist）可以读取CLASS级注解
// 在类加载时修改字节码
public class BytecodeEnhancer {
    public void enhance(Class<?> clazz) {
        // 读取字节码中的注解
        // 修改字节码
        // 重新加载类
    }
}
```

### 4.4 RUNTIME - 运行时级别

**特点**：
- 保留在字节码中
- 运行时可以通过反射获取
- 这是最常用的保留策略

**用途**：
- 运行时处理
- 依赖注入
- ORM映射
- 单元测试

**示例**：
```java
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();
}

// 使用
@MyAnnotation("test")
public class MyClass {
}

// 运行时读取
public class AnnotationReader {
    public static void main(String[] args) {
        MyAnnotation annotation = MyClass.class.getAnnotation(MyAnnotation.class);
        System.out.println(annotation.value());  // 输出: test
    }
}
```

**常见的RUNTIME级注解**：
- Spring的注解（`@Component`, `@Autowired`, `@Transactional`等）
- JPA的注解（`@Entity`, `@Table`, `@Column`等）
- JUnit的注解（`@Test`, `@Before`, `@After`等）

### 4.5 三种策略的对比

| 保留策略 | 源码 | 字节码 | 运行时 | 用途 | 示例 |
|---------|------|--------|--------|------|------|
| SOURCE | ✅ | ❌ | ❌ | 编译期检查、代码生成 | @Override, @SuppressWarnings |
| CLASS | ✅ | ✅ | ❌ | 字节码增强 | 很少使用 |
| RUNTIME | ✅ | ✅ | ✅ | 运行时处理 | @Component, @Entity, @Test |

### 4.6 如何选择保留策略？

**决策树**：

```
需要在运行时通过反射读取吗？
├─ 是 → 使用 RUNTIME
└─ 否 → 只在编译期使用吗？
    ├─ 是 → 使用 SOURCE
    └─ 否 → 使用 CLASS（很少见）
```

**实际建议**：
- 99%的情况下，选择 `RUNTIME` 或 `SOURCE`
- 如果需要运行时处理（依赖注入、ORM等），使用 `RUNTIME`
- 如果只是编译期检查或代码生成，使用 `SOURCE`

## 问题5：@Target - 注解的使用位置

### 5.1 ElementType枚举

```java
public enum ElementType {
    TYPE,               // 类、接口、枚举
    FIELD,              // 字段
    METHOD,             // 方法
    PARAMETER,          // 方法参数
    CONSTRUCTOR,        // 构造函数
    LOCAL_VARIABLE,     // 局部变量
    ANNOTATION_TYPE,    // 注解
    PACKAGE,            // 包
    TYPE_PARAMETER,     // 类型参数（Java 8+）
    TYPE_USE            // 任何类型使用（Java 8+）
}
```

### 5.2 单个目标

```java
// 只能用在类上
@Target(ElementType.TYPE)
public @interface Entity {
}

// 只能用在方法上
@Target(ElementType.METHOD)
public @interface Test {
}

// 只能用在字段上
@Target(ElementType.FIELD)
public @interface Autowired {
}
```

### 5.3 多个目标

```java
// 可以用在类、方法、字段上
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
public @interface MyAnnotation {
}

// 使用
@MyAnnotation  // 用在类上
public class MyClass {
    
    @MyAnnotation  // 用在字段上
    private String field;
    
    @MyAnnotation  // 用在方法上
    public void method() {
    }
}
```

### 5.4 不指定Target

```java
// 不使用@Target，默认可以用在任何地方
public @interface MyAnnotation {
}
```

### 5.5 各种ElementType的示例

```java
// TYPE - 类、接口、枚举
@Target(ElementType.TYPE)
public @interface Entity {
}

@Entity
public class User {
}

@Entity
public interface UserService {
}

@Entity
public enum UserType {
}

// FIELD - 字段
@Target(ElementType.FIELD)
public @interface Column {
}

public class User {
    @Column
    private String name;
}

// METHOD - 方法
@Target(ElementType.METHOD)
public @interface Test {
}

public class UserTest {
    @Test
    public void testMethod() {
    }
}

// PARAMETER - 方法参数
@Target(ElementType.PARAMETER)
public @interface PathVariable {
}

public void getUser(@PathVariable Long id) {
}

// CONSTRUCTOR - 构造函数
@Target(ElementType.CONSTRUCTOR)
public @interface Inject {
}

public class UserService {
    @Inject
    public UserService(UserDao userDao) {
    }
}

// LOCAL_VARIABLE - 局部变量
@Target(ElementType.LOCAL_VARIABLE)
public @interface NonNull {
}

public void method() {
    @NonNull String name = "test";
}

// ANNOTATION_TYPE - 注解
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}

@Documented  // 用在注解上
public @interface MyAnnotation {
}

// TYPE_PARAMETER - 类型参数（Java 8+）
@Target(ElementType.TYPE_PARAMETER)
public @interface NonEmpty {
}

public class Container<@NonEmpty T> {
}

// TYPE_USE - 任何类型使用（Java 8+）
@Target(ElementType.TYPE_USE)
public @interface NotNull {
}

public class Example {
    private @NotNull String name;  // 字段类型
    
    public @NotNull String getName() {  // 返回值类型
        return name;
    }
    
    public void setName(@NotNull String name) {  // 参数类型
        this.name = name;
    }
    
    public void method() {
        @NotNull String local = "test";  // 局部变量类型
        List<@NotNull String> list = new ArrayList<>();  // 泛型类型
    }
}
```

### 5.6 TYPE_USE的强大之处

`TYPE_USE` 是Java 8引入的，可以用在任何类型使用的地方：

```java
@Target(ElementType.TYPE_USE)
public @interface NotNull {
}

public class Example {
    // 1. 字段类型
    private @NotNull String name;
    
    // 2. 方法返回值类型
    public @NotNull String getName() {
        return name;
    }
    
    // 3. 方法参数类型
    public void setName(@NotNull String name) {
        this.name = name;
    }
    
    // 4. 泛型类型
    List<@NotNull String> list;
    Map<@NotNull String, @NotNull Integer> map;
    
    // 5. 数组类型
    @NotNull String[] array;
    String @NotNull [] array2;
    
    // 6. 类型转换
    String s = (@NotNull String) obj;
    
    // 7. instanceof
    if (obj instanceof @NotNull String) {
    }
    
    // 8. 异常
    public void method() throws @NotNull IOException {
    }
    
    // 9. 继承
    public class Child extends @NotNull Parent {
    }
    
    // 10. 实现接口
    public class Impl implements @NotNull Interface {
    }
}
```

## 问题6：@Documented - 是否包含在JavaDoc中

### 6.1 作用

`@Documented` 表示该注解应该被JavaDoc工具记录。

### 6.2 示例

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
}

// 使用
public class MyClass {
    /**
     * 这是一个测试方法
     */
    @MyAnnotation
    public void testMethod() {
    }
}
```

**生成的JavaDoc中会包含@MyAnnotation**

### 6.3 对比

**不使用@Documented**：
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
}
```
生成的JavaDoc中不会显示@MyAnnotation

**使用@Documented**：
```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface MyAnnotation {
}
```
生成的JavaDoc中会显示@MyAnnotation

## 问题7：@Inherited - 是否可以被继承

### 7.1 作用

`@Inherited` 表示该注解可以被子类继承。

**注意**：只对类有效，对方法、字段等无效。

### 7.2 示例

**使用@Inherited**：
```java
@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
    String value();
}

@MyAnnotation("parent")
public class Parent {
}

// 子类自动继承@MyAnnotation
public class Child extends Parent {
}

// 测试
public class Test {
    public static void main(String[] args) {
        MyAnnotation annotation = Child.class.getAnnotation(MyAnnotation.class);
        System.out.println(annotation.value());  // 输出: parent
    }
}
```

**不使用@Inherited**：
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
    String value();
}

@MyAnnotation("parent")
public class Parent {
}

public class Child extends Parent {
}

// 测试
public class Test {
    public static void main(String[] args) {
        MyAnnotation annotation = Child.class.getAnnotation(MyAnnotation.class);
        System.out.println(annotation);  // 输出: null
    }
}
```

### 7.3 注意事项

1. **只对类继承有效**：
```java
@Inherited
@Target(ElementType.METHOD)
public @interface MyAnnotation {
}

public class Parent {
    @MyAnnotation
    public void method() {
    }
}

public class Child extends Parent {
    @Override
    public void method() {
        // 子类的method方法不会继承@MyAnnotation
    }
}
```

2. **接口不会继承**：
```java
@Inherited
@Target(ElementType.TYPE)
public @interface MyAnnotation {
}

@MyAnnotation
public interface MyInterface {
}

// 实现类不会继承@MyAnnotation
public class MyClass implements MyInterface {
}
```

## 问题8：@Repeatable - 可重复注解（Java 8+）

### 8.1 为什么需要可重复注解？

**Java 8之前的问题**：
```java
// 想要添加多个@Schedule注解
@Schedule(day = "Monday")
@Schedule(day = "Friday")  // 编译错误：重复的注解
public void task() {
}
```

**Java 8之前的解决方案**：使用数组
```java
@Schedules({
    @Schedule(day = "Monday"),
    @Schedule(day = "Friday")
})
public void task() {
}
```

**Java 8的解决方案**：`@Repeatable`
```java
@Schedule(day = "Monday")
@Schedule(day = "Friday")  // 可以重复使用
public void task() {
}
```

### 8.2 如何定义可重复注解

**步骤1**：定义容器注解
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Schedules {
    Schedule[] value();  // 必须是数组
}
```

**步骤2**：定义可重复注解
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Schedules.class)  // 指定容器注解
public @interface Schedule {
    String day();
    String time() default "00:00";
}
```

**步骤3**：使用
```java
public class TaskScheduler {
    
    @Schedule(day = "Monday", time = "09:00")
    @Schedule(day = "Wednesday", time = "14:00")
    @Schedule(day = "Friday", time = "18:00")
    public void backupDatabase() {
        // 备份数据库
    }
}
```

**步骤4**：读取
```java
public class ScheduleReader {
    public static void main(String[] args) throws Exception {
        Method method = TaskScheduler.class.getMethod("backupDatabase");
        
        // 方式1：读取容器注解
        Schedules schedules = method.getAnnotation(Schedules.class);
        if (schedules != null) {
            for (Schedule schedule : schedules.value()) {
                System.out.println(schedule.day() + " " + schedule.time());
            }
        }
        
        // 方式2：读取可重复注解（推荐）
        Schedule[] scheduleArray = method.getAnnotationsByType(Schedule.class);
        for (Schedule schedule : scheduleArray) {
            System.out.println(schedule.day() + " " + schedule.time());
        }
    }
}
```

### 8.3 完整示例

```java
// 容器注解
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Filters {
    Filter[] value();
}

// 可重复注解
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@Repeatable(Filters.class)
public @interface Filter {
    String name();
    String pattern();
}

// 使用
public class WebController {
    
    @Filter(name = "auth", pattern = "/api/*")
    @Filter(name = "log", pattern = "/**")
    @Filter(name = "cors", pattern = "/api/*")
    public void handleRequest() {
        // 处理请求
    }
}

// 读取
public class FilterReader {
    public static void main(String[] args) throws Exception {
        Method method = WebController.class.getMethod("handleRequest");
        Filter[] filters = method.getAnnotationsByType(Filter.class);
        
        for (Filter filter : filters) {
            System.out.println("Filter: " + filter.name() + ", Pattern: " + filter.pattern());
        }
    }
}
```

## 问题9：元注解的组合使用

### 9.1 完整的注解定义

```java
@Documented                          // 包含在JavaDoc中
@Retention(RetentionPolicy.RUNTIME)  // 运行时可见
@Target({                            // 可以用在类和方法上
    ElementType.TYPE,
    ElementType.METHOD
})
@Inherited                           // 可以被继承
public @interface MyAnnotation {
    String value() default "";
    int priority() default 0;
}
```

### 9.2 实际案例：Spring的@Service

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component  // 组合其他注解
public @interface Service {
    @AliasFor(annotation = Component.class)
    String value() default "";
}
```

## 总结

### 核心问题回答

**Q1: 如何定义注解？**
- 使用 `@interface` 关键字
- 定义属性（方法形式）
- 可以设置默认值

**Q2: 注解的属性可以是哪些类型？**
- 8种基本类型
- String
- Class
- 枚举
- 注解
- 以上类型的数组

**Q3: 什么是元注解？**
- 用于注解其他注解的注解
- Java提供5个标准元注解

**Q4: @Retention的三种策略？**
- SOURCE：源码级别，编译后丢弃
- CLASS：字节码级别，运行时不可见
- RUNTIME：运行时级别，可以反射读取

**Q5: @Target的作用？**
- 定义注解可以用在哪些地方
- 10种ElementType

**Q6: @Documented的作用？**
- 控制是否包含在JavaDoc中

**Q7: @Inherited的作用？**
- 控制注解是否可以被子类继承
- 只对类有效

**Q8: @Repeatable的作用？**
- 允许在同一位置重复使用注解
- 需要定义容器注解

### 下一章预告

在理解了注解的定义和元注解之后，下一章我们将探讨：

- 注解是如何工作的？
- 如何通过反射读取注解？
- 如何处理注解？
- 注解处理器的工作原理？

让我们继续深入探索！
