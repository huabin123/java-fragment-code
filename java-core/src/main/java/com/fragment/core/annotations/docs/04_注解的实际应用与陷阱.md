# 第四章：注解的实际应用与陷阱

## 问题1：如何实现一个简单的依赖注入框架？

### 1.1 需求分析

我们要实现类似Spring的 `@Autowired` 功能：

```java
@Component
public class UserService {
    @Autowired
    private UserDao userDao;
    
    public void createUser(User user) {
        userDao.save(user);
    }
}
```

### 1.2 实现步骤

**步骤1：定义注解**

```java
// 标记为组件
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Component {
    String value() default "";
}

// 标记需要注入
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Autowired {
}
```

**步骤2：实现容器**

```java
public class SimpleContainer {
    // 存储所有Bean
    private Map<Class<?>, Object> beans = new ConcurrentHashMap<>();
    
    /**
     * 扫描包，创建所有Bean
     */
    public void scan(String packageName) throws Exception {
        // 1. 获取包下所有类
        List<Class<?>> classes = getClasses(packageName);
        
        // 2. 筛选有@Component注解的类
        for (Class<?> clazz : classes) {
            if (clazz.isAnnotationPresent(Component.class)) {
                // 3. 创建实例
                Object bean = clazz.newInstance();
                beans.put(clazz, bean);
            }
        }
        
        // 4. 处理依赖注入
        for (Object bean : beans.values()) {
            injectDependencies(bean);
        }
    }
    
    /**
     * 注入依赖
     */
    private void injectDependencies(Object bean) throws Exception {
        Class<?> clazz = bean.getClass();
        
        // 遍历所有字段
        for (Field field : clazz.getDeclaredFields()) {
            // 检查是否有@Autowired注解
            if (field.isAnnotationPresent(Autowired.class)) {
                // 获取字段类型
                Class<?> fieldType = field.getType();
                
                // 从容器中获取依赖
                Object dependency = getBean(fieldType);
                if (dependency == null) {
                    throw new RuntimeException("找不到类型为 " + fieldType + " 的Bean");
                }
                
                // 注入依赖
                field.setAccessible(true);
                field.set(bean, dependency);
            }
        }
    }
    
    /**
     * 获取Bean
     */
    public <T> T getBean(Class<T> clazz) {
        return (T) beans.get(clazz);
    }
}
```

**步骤3：使用**

```java
public class DIDemo {
    public static void main(String[] args) throws Exception {
        // 创建容器
        SimpleContainer container = new SimpleContainer();
        
        // 扫描包
        container.scan("com.example");
        
        // 获取Bean
        UserService userService = container.getBean(UserService.class);
        
        // 使用Bean
        userService.createUser(new User("张三"));
    }
}
```

## 问题2：如何实现一个简单的ORM框架？

### 2.1 需求分析

我们要实现类似JPA的功能：

```java
@Entity
@Table(name = "t_user")
public class User {
    @Id
    @Column(name = "id")
    private Long id;
    
    @Column(name = "user_name")
    private String username;
}
```

### 2.2 实现步骤

**步骤1：定义注解**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Entity {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Table {
    String name();
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Id {
}

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Column {
    String name();
    boolean nullable() default true;
}
```

**步骤2：实现SQL生成器**

```java
public class SqlGenerator {
    
    /**
     * 生成INSERT语句
     */
    public static String generateInsertSql(Object entity) throws Exception {
        Class<?> clazz = entity.getClass();
        
        // 获取表名
        String tableName = getTableName(clazz);
        
        // 获取所有列
        List<String> columns = new ArrayList<>();
        List<String> values = new ArrayList<>();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                columns.add(column.name());
                
                field.setAccessible(true);
                Object value = field.get(entity);
                values.add(formatValue(value));
            }
        }
        
        // 生成SQL
        String sql = String.format("INSERT INTO %s (%s) VALUES (%s)",
            tableName,
            String.join(", ", columns),
            String.join(", ", values)
        );
        
        return sql;
    }
    
    /**
     * 生成UPDATE语句
     */
    public static String generateUpdateSql(Object entity) throws Exception {
        Class<?> clazz = entity.getClass();
        String tableName = getTableName(clazz);
        
        List<String> sets = new ArrayList<>();
        String idColumn = null;
        Object idValue = null;
        
        for (Field field : clazz.getDeclaredFields()) {
            field.setAccessible(true);
            Object value = field.get(entity);
            
            if (field.isAnnotationPresent(Id.class)) {
                Column column = field.getAnnotation(Column.class);
                idColumn = column.name();
                idValue = value;
            } else if (field.isAnnotationPresent(Column.class)) {
                Column column = field.getAnnotation(Column.class);
                sets.add(column.name() + " = " + formatValue(value));
            }
        }
        
        String sql = String.format("UPDATE %s SET %s WHERE %s = %s",
            tableName,
            String.join(", ", sets),
            idColumn,
            formatValue(idValue)
        );
        
        return sql;
    }
    
    /**
     * 生成SELECT语句
     */
    public static String generateSelectSql(Class<?> clazz, Object id) {
        String tableName = getTableName(clazz);
        String idColumn = getIdColumn(clazz);
        
        return String.format("SELECT * FROM %s WHERE %s = %s",
            tableName, idColumn, formatValue(id));
    }
    
    /**
     * 生成DELETE语句
     */
    public static String generateDeleteSql(Class<?> clazz, Object id) {
        String tableName = getTableName(clazz);
        String idColumn = getIdColumn(clazz);
        
        return String.format("DELETE FROM %s WHERE %s = %s",
            tableName, idColumn, formatValue(id));
    }
    
    // 辅助方法
    private static String getTableName(Class<?> clazz) {
        if (clazz.isAnnotationPresent(Table.class)) {
            Table table = clazz.getAnnotation(Table.class);
            return table.name();
        }
        return clazz.getSimpleName().toLowerCase();
    }
    
    private static String getIdColumn(Class<?> clazz) {
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Id.class)) {
                Column column = field.getAnnotation(Column.class);
                return column.name();
            }
        }
        return "id";
    }
    
    private static String formatValue(Object value) {
        if (value == null) {
            return "NULL";
        }
        if (value instanceof String) {
            return "'" + value + "'";
        }
        return value.toString();
    }
}
```

**步骤3：使用**

```java
public class ORMDemo {
    public static void main(String[] args) throws Exception {
        User user = new User();
        user.setId(1L);
        user.setUsername("张三");
        
        // 生成INSERT语句
        String insertSql = SqlGenerator.generateInsertSql(user);
        System.out.println(insertSql);
        // 输出: INSERT INTO t_user (id, user_name) VALUES (1, '张三')
        
        // 生成UPDATE语句
        String updateSql = SqlGenerator.generateUpdateSql(user);
        System.out.println(updateSql);
        // 输出: UPDATE t_user SET user_name = '张三' WHERE id = 1
        
        // 生成SELECT语句
        String selectSql = SqlGenerator.generateSelectSql(User.class, 1L);
        System.out.println(selectSql);
        // 输出: SELECT * FROM t_user WHERE id = 1
        
        // 生成DELETE语句
        String deleteSql = SqlGenerator.generateDeleteSql(User.class, 1L);
        System.out.println(deleteSql);
        // 输出: DELETE FROM t_user WHERE id = 1
    }
}
```

## 问题3：注解使用中的常见陷阱

### 陷阱1：注解的保留策略错误

**问题**：
```java
// 错误：使用了SOURCE级别
@Retention(RetentionPolicy.SOURCE)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
}

// 运行时无法获取
public class Test {
    public static void main(String[] args) {
        MyAnnotation annotation = MyClass.class.getAnnotation(MyAnnotation.class);
        System.out.println(annotation);  // 输出: null
    }
}
```

**解决方案**：
```java
// 正确：使用RUNTIME级别
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
}
```

### 陷阱2：忘记设置字段可访问

**问题**：
```java
public class User {
    @Autowired
    private UserDao userDao;  // private字段
}

// 注入时会报错
public void inject(Object bean) throws Exception {
    Field field = bean.getClass().getDeclaredField("userDao");
    field.set(bean, dependency);  // IllegalAccessException
}
```

**解决方案**：
```java
public void inject(Object bean) throws Exception {
    Field field = bean.getClass().getDeclaredField("userDao");
    field.setAccessible(true);  // 设置可访问
    field.set(bean, dependency);
}
```

### 陷阱3：注解继承的误解

**问题**：
```java
@Inherited
@Target(ElementType.METHOD)  // 注意：是METHOD
public @interface MyAnnotation {
}

public class Parent {
    @MyAnnotation
    public void method() {
    }
}

public class Child extends Parent {
    @Override
    public void method() {
        // 子类的method方法不会继承@MyAnnotation
        // 因为@Inherited只对类有效，对方法无效
    }
}
```

**正确理解**：
```java
@Inherited
@Target(ElementType.TYPE)  // 必须是TYPE
public @interface MyAnnotation {
}

@MyAnnotation
public class Parent {
}

// 子类会继承@MyAnnotation
public class Child extends Parent {
}
```

### 陷阱4：注解属性的默认值陷阱

**问题**：
```java
public @interface MyAnnotation {
    String[] value();  // 没有默认值
}

// 使用时必须指定值
@MyAnnotation  // 编译错误：必须指定value
public class MyClass {
}
```

**解决方案**：
```java
public @interface MyAnnotation {
    String[] value() default {};  // 提供默认值
}

// 可以不指定值
@MyAnnotation
public class MyClass {
}
```

### 陷阱5：注解属性类型限制

**问题**：
```java
public @interface MyAnnotation {
    List<String> items();  // 编译错误：不支持List
    Map<String, String> properties();  // 编译错误：不支持Map
}
```

**解决方案**：
```java
public @interface MyAnnotation {
    String[] items();  // 使用数组
}
```

### 陷阱6：循环依赖

**问题**：
```java
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA;  // 循环依赖
}
```

**解决方案**：
1. 使用setter注入而不是字段注入
2. 使用`@Lazy`延迟加载
3. 重新设计，避免循环依赖

### 陷阱7：注解在接口上的继承

**问题**：
```java
@MyAnnotation
public interface MyInterface {
}

// 实现类不会继承@MyAnnotation
public class MyClass implements MyInterface {
}
```

**原因**：
- `@Inherited` 只对类继承有效
- 接口的实现不会继承注解

### 陷阱8：注解的equals和hashCode

**问题**：
```java
@MyAnnotation("test")
public class MyClass1 {
}

@MyAnnotation("test")
public class MyClass2 {
}

// 比较注解
MyAnnotation ann1 = MyClass1.class.getAnnotation(MyAnnotation.class);
MyAnnotation ann2 = MyClass2.class.getAnnotation(MyAnnotation.class);

System.out.println(ann1 == ann2);  // false（不同的代理对象）
System.out.println(ann1.equals(ann2));  // true（值相同）
```

**正确做法**：
- 使用 `equals()` 比较注解，不要使用 `==`

### 陷阱9：泛型擦除

**问题**：
```java
public class Container<T> {
    @Autowired
    private T item;  // 运行时无法知道T的实际类型
}
```

**原因**：
- Java的泛型是编译时特性
- 运行时泛型信息被擦除
- 无法通过反射获取T的实际类型

**解决方案**：
```java
public class Container<T> {
    @Autowired
    private T item;
    
    private Class<T> itemClass;
    
    public Container(Class<T> itemClass) {
        this.itemClass = itemClass;
    }
}
```

### 陷阱10：注解处理的性能问题

**问题**：
```java
// 每次都通过反射获取注解
public void process(Object obj) {
    MyAnnotation annotation = obj.getClass().getAnnotation(MyAnnotation.class);
    // 处理注解
}
```

**解决方案**：缓存注解
```java
private static final Map<Class<?>, MyAnnotation> cache = new ConcurrentHashMap<>();

public void process(Object obj) {
    Class<?> clazz = obj.getClass();
    MyAnnotation annotation = cache.computeIfAbsent(clazz, 
        k -> k.getAnnotation(MyAnnotation.class));
    // 处理注解
}
```

## 问题4：注解的最佳实践

### 实践1：注解命名规范

```java
// ✅ 好的命名
@Entity          // 名词
@Transactional   // 形容词
@Override        // 动词

// ❌ 不好的命名
@E
@Trans
@OVR
```

### 实践2：提供合理的默认值

```java
// ✅ 好的设计
@RequestMapping(
    value = "/user",
    method = RequestMethod.GET,  // 有默认值
    produces = "application/json"  // 有默认值
)

// ❌ 不好的设计
@RequestMapping(
    value = "/user",
    method = RequestMethod.GET,
    produces = "application/json",
    consumes = "application/json",  // 必须指定，但大多数情况下都一样
    headers = {},
    params = {}
)
```

### 实践3：使用组合注解

```java
// 定义组合注解
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Controller
@ResponseBody
public @interface RestController {
}

// 使用组合注解
@RestController  // 等价于 @Controller + @ResponseBody
public class UserController {
}
```

### 实践4：注解文档化

```java
/**
 * 标记一个类为服务层组件
 * 
 * <p>被此注解标记的类会被Spring容器自动扫描并注册为Bean</p>
 * 
 * <p>使用示例：</p>
 * <pre>
 * {@code
 * @Service
 * public class UserService {
 *     // 服务实现
 * }
 * }
 * </pre>
 * 
 * @see Component
 * @see Repository
 * @see Controller
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Service {
    /**
     * Bean的名称
     * @return Bean名称，默认为类名首字母小写
     */
    String value() default "";
}
```

### 实践5：注解的单一职责

```java
// ✅ 好的设计：每个注解只做一件事
@Entity
@Table(name = "t_user")
public class User {
}

// ❌ 不好的设计：一个注解做太多事
@EntityAndTable(tableName = "t_user", schema = "public", catalog = "mydb")
public class User {
}
```

### 实践6：使用枚举而不是字符串

```java
// ✅ 好的设计
public enum HttpMethod {
    GET, POST, PUT, DELETE
}

@RequestMapping(method = HttpMethod.GET)
public void getUser() {
}

// ❌ 不好的设计
@RequestMapping(method = "GET")  // 字符串，容易拼写错误
public void getUser() {
}
```

### 实践7：注解的版本兼容性

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();
    
    // 新增属性时提供默认值，保持向后兼容
    int priority() default 0;  // 新增属性
    
    // 不要删除已有属性
    // String oldProperty();  // 不要删除
}
```

## 问题5：注解 vs 其他方案的对比

### 方案1：XML配置

**优点**：
- ✅ 配置集中
- ✅ 不侵入代码
- ✅ 可以在不重新编译的情况下修改配置

**缺点**：
- ❌ 代码和配置分离
- ❌ 类型不安全
- ❌ IDE支持差
- ❌ 重构困难

### 方案2：编程式配置

**优点**：
- ✅ 类型安全
- ✅ IDE支持好
- ✅ 灵活性高

**缺点**：
- ❌ 代码量大
- ❌ 样板代码多
- ❌ 不够声明式

### 方案3：约定优于配置

**优点**：
- ✅ 零配置
- ✅ 简洁

**缺点**：
- ❌ 不够灵活
- ❌ 需要遵循约定
- ❌ 学习成本

### 方案4：注解（推荐）

**优点**：
- ✅ 代码和配置合一
- ✅ 类型安全
- ✅ IDE支持好
- ✅ 声明式编程

**缺点**：
- ❌ 侵入性强
- ❌ 修改需要重新编译

### 最佳实践：混合使用

```java
// 1. 使用注解定义结构
@Entity
@Table(name = "t_user")
public class User {
    @Id
    private Long id;
}

// 2. 使用配置文件定义环境相关配置
# application.yml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/test
    username: root
    password: 123456

// 3. 使用编程式配置处理复杂逻辑
@Configuration
public class DatabaseConfig {
    @Bean
    public DataSource dataSource() {
        // 复杂的DataSource配置逻辑
    }
}
```

## 总结

### 核心问题回答

**Q1: 如何实现依赖注入？**
1. 定义 `@Component` 和 `@Autowired` 注解
2. 扫描包，创建所有Bean
3. 通过反射注入依赖

**Q2: 如何实现ORM？**
1. 定义 `@Entity`, `@Table`, `@Column` 等注解
2. 通过反射读取注解
3. 生成SQL语句

**Q3: 常见陷阱有哪些？**
1. 保留策略错误
2. 忘记设置字段可访问
3. 注解继承的误解
4. 循环依赖
5. 泛型擦除
6. 性能问题

**Q4: 最佳实践有哪些？**
1. 合理命名
2. 提供默认值
3. 使用组合注解
4. 注解文档化
5. 单一职责
6. 使用枚举
7. 版本兼容性

**Q5: 注解 vs 其他方案？**
- XML：配置集中但类型不安全
- 编程式：灵活但代码量大
- 约定：简洁但不够灵活
- 注解：平衡各方面，推荐使用

### 下一章预告

下一章我们将探讨：
- 注解处理器（APT）的原理和实现
- 如何编写自己的注解处理器
- Lombok的实现原理
- 编译时代码生成

让我们继续深入！
