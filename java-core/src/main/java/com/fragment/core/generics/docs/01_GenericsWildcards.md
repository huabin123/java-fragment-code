# Java 泛型通配符详解

## 1. 泛型通配符概述

Java 泛型中的通配符主要有两种形式：
- `<? extends T>`: 上界通配符，表示类型参数是 T 或 T 的子类
- `<? super T>`: 下界通配符，表示类型参数是 T 或 T 的父类

## 2. `<? extends T>` 上界通配符

### 特点
- 可以从集合中**读取**元素，并且保证读取的元素是 T 类型或其子类型
- 不能向集合中**添加**元素（除了 null），因为无法确保添加的元素符合通配符的未知类型

### 使用场景
- 频繁从集合中读取数据的场景
- 当你只需要读取集合元素并且不需要修改集合时
- 作为方法的返回类型或参数类型，表示接受任何 T 或 T 的子类型的集合

## 3. `<? super T>` 下界通配符

### 特点
- 可以向集合中**添加** T 类型或 T 的子类型的元素
- 从集合中读取元素时，只能将其视为 Object 类型，因为无法确定具体是哪个父类

### 使用场景
- 频繁向集合中添加数据的场景
- 当你需要写入特定类型的元素到集合中时
- 作为方法的参数类型，表示接受任何 T 或 T 的父类型的集合

## 4. PECS 原则 (Producer Extends, Consumer Super)

- **Producer Extends**: 如果你需要从集合中读取类型 T 的数据，使用 `<? extends T>`
- **Consumer Super**: 如果你需要向集合中写入类型 T 的数据，使用 `<? super T>`

## 5. 无界通配符 `<?>`

- 表示可以是任何类型
- 通常用于与泛型类型无关的操作，如检查集合是否为空

## 6. 类型擦除与安全转换

在使用无泛型限制的集合赋值给有泛型限制的集合时，需要注意：
- 编译器无法在运行时检查元素类型（类型擦除）
- 使用集合元素前应进行 `instanceof` 判断，避免 `ClassCastException` 异常

## 7. 最佳实践

1. 明确方法的用途：是读取数据还是写入数据
2. 读取数据优先使用 `<? extends T>`
3. 写入数据优先使用 `<? super T>`
4. 既读又写时，不使用通配符，直接使用具体类型 `<T>`
5. 在转换不同泛型类型的集合时，注意进行类型检查

## 8. 与里氏替换原则（LSP）的关系

- 定义：里氏替换原则要求子类型必须能替换其父类型而不破坏程序行为。
- `<? extends T>` 支持协变读取：当方法参数为 `List<? extends Animal>` 时，`List<Dog>`、`List<Husky>` 等子类型集合均可被替换传入，符合 LSP 对"在需要父类型的地方可使用子类型"的要求；限制"只读不写"正是为了保持替换后的类型安全。
- `<? super T>` 支持逆变写入：当方法参数为 `List<? super Husky>` 时，`List<Dog>`、`List<Animal>` 等父类型集合均可被替换传入；此时只能安全地向其中写入 `Husky`（或其子类），读取则退化为 `Object`，以避免破坏替换后的行为。
- 示例（见 `java-core/src/main/java/com/fragment/core/generics/PECSPrincipleDemo.java`）：
  - `printAnimals(List<? extends Animal>)`：仅读取，展示协变。
  - `addHuskies(List<? super Husky>)`：仅写入，展示逆变。
  - `copy(List<? super T>, List<? extends T>)`：读写两端同时遵循上述原则。
- 小结：PECS 是在 Java 泛型层面将 LSP 的可替换性通过协变/逆变具体化，从而在编译期获得更强的类型安全与 API 兼容性。
