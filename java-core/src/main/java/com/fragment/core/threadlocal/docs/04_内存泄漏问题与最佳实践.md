# ç¬¬å››ç« ï¼šå†…å­˜æ³„æ¼é—®é¢˜ä¸æœ€ä½³å®è·µ

## å¼•è¨€

æœ¬ç« å°†æ·±å…¥åˆ†æThreadLocalå†…å­˜æ³„æ¼çš„å®Œæ•´æ¡ˆä¾‹ï¼Œæ€»ç»“æœ€ä½³å®è·µï¼Œå¸®åŠ©ä½ åœ¨å®é™…é¡¹ç›®ä¸­æ­£ç¡®ä½¿ç”¨ThreadLocalï¼Œé¿å…å†…å­˜æ³„æ¼é™·é˜±ã€‚

---

## 1. å†…å­˜æ³„æ¼å®Œæ•´æ¡ˆä¾‹åˆ†æ

### 1.1 é—®é¢˜1ï¼šå…¸å‹çš„å†…å­˜æ³„æ¼åœºæ™¯æ˜¯ä»€ä¹ˆï¼Ÿ

**æ¡ˆä¾‹1ï¼šWebåº”ç”¨ä¸­çš„ç”¨æˆ·ä¸Šä¸‹æ–‡**

```java
public class UserContextHolder {
    private static final ThreadLocal<User> userHolder = new ThreadLocal<>();
    
    public static void setUser(User user) {
        userHolder.set(user);
    }
    
    public static User getUser() {
        return userHolder.get();
    }
    
    public static void clear() {
        userHolder.remove();
    }
}

// Servletå®¹å™¨ä½¿ç”¨çº¿ç¨‹æ± å¤„ç†è¯·æ±‚
public class UserServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        try {
            // 1. è®¾ç½®ç”¨æˆ·ä¸Šä¸‹æ–‡
            User user = getUserFromSession(req);
            UserContextHolder.setUser(user);
            
            // 2. å¤„ç†ä¸šåŠ¡é€»è¾‘
            processRequest();
            
        } finally {
            // âŒ å¦‚æœå¿˜è®°æ¸…ç†ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼
            // UserContextHolder.clear();
        }
    }
}
```

**å†…å­˜æ³„æ¼åˆ†æ**ï¼š

```
Tomcatçº¿ç¨‹æ± ï¼ˆé»˜è®¤200ä¸ªçº¿ç¨‹ï¼‰ï¼š

ç¬¬1ä¸ªè¯·æ±‚ï¼ˆThread-1ï¼‰ï¼š
UserContextHolder.set(user1)
â†’ Thread-1.threadLocals.put(UserContextHolder, user1)

ç¬¬2ä¸ªè¯·æ±‚ï¼ˆThread-2ï¼‰ï¼š
UserContextHolder.set(user2)
â†’ Thread-2.threadLocals.put(UserContextHolder, user2)

...

ç¬¬201ä¸ªè¯·æ±‚ï¼ˆå¤ç”¨Thread-1ï¼‰ï¼š
UserContextHolder.set(user201)
â†’ Thread-1.threadLocals.put(UserContextHolder, user201)
â†’ user1ä»ç„¶åœ¨å†…å­˜ä¸­ï¼ˆæœªè¢«æ¸…ç†ï¼‰

é—®é¢˜ï¼š
- 200ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªçº¿ç¨‹æŒæœ‰ä¸€ä¸ªUserå¯¹è±¡
- å¦‚æœUserå¯¹è±¡å¾ˆå¤§ï¼ˆåŒ…å«å¤§é‡æ•°æ®ï¼‰ï¼Œå†…å­˜å ç”¨ä¸¥é‡
- çº¿ç¨‹æ± çš„çº¿ç¨‹æ°¸è¿œä¸ç»“æŸï¼ŒUserå¯¹è±¡æ°¸è¿œæ— æ³•è¢«GC
```

---

**æ¡ˆä¾‹2ï¼šæ•°æ®åº“è¿æ¥æ³„æ¼**

```java
public class ConnectionManager {
    private static final ThreadLocal<Connection> connHolder = new ThreadLocal<>();
    
    public static Connection getConnection() throws SQLException {
        Connection conn = connHolder.get();
        if (conn == null) {
            conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/db");
            connHolder.set(conn);
        }
        return conn;
    }
    
    public static void closeConnection() {
        Connection conn = connHolder.get();
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
            // âŒ å¿˜è®°remove
            // connHolder.remove();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class UserService {
    public void updateUser(User user) {
        try {
            Connection conn = ConnectionManager.getConnection();
            // æ‰§è¡ŒSQL
            PreparedStatement ps = conn.prepareStatement("UPDATE users SET name = ?");
            ps.setString(1, user.getName());
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            ConnectionManager.closeConnection();
        }
    }
}
```

**å†…å­˜æ³„æ¼åˆ†æ**ï¼š

```
é—®é¢˜ï¼š
1. Connectionå¯¹è±¡è¢«close()ï¼Œä½†ä»ç„¶è¢«ThreadLocalæŒæœ‰
2. æ•°æ®åº“è¿æ¥æ± æ— æ³•å›æ”¶è¿™äº›è¿æ¥
3. æœ€ç»ˆå¯¼è‡´è¿æ¥æ± è€—å°½

æ­£ç¡®åšæ³•ï¼š
finally {
    ConnectionManager.closeConnection();
    connHolder.remove(); // å¿…é¡»remove
}
```

---

### 1.2 é—®é¢˜2ï¼šå¦‚ä½•æ£€æµ‹ThreadLocalå†…å­˜æ³„æ¼ï¼Ÿ

**æ–¹æ³•1ï¼šä½¿ç”¨JProfiler/VisualVM**

```
æ­¥éª¤ï¼š
1. å¯åŠ¨åº”ç”¨ï¼Œæ‰§è¡Œä¸€äº›è¯·æ±‚
2. ä½¿ç”¨JProfilerè¿æ¥åˆ°JVM
3. æŸ¥çœ‹Heap Dump
4. æœç´¢ThreadLocalMap$Entry
5. æŸ¥çœ‹Entryçš„valueå¼•ç”¨é“¾

å¦‚æœå‘ç°ï¼š
- Entry.keyä¸ºnullï¼ˆè¿‡æœŸEntryï¼‰
- Entry.valueä»ç„¶å­˜åœ¨
- valueå ç”¨å¤§é‡å†…å­˜
â†’ è¯´æ˜å­˜åœ¨å†…å­˜æ³„æ¼
```

---

**æ–¹æ³•2ï¼šä»£ç ç›‘æ§**

```java
public class ThreadLocalMonitor {
    /**
     * è·å–å½“å‰çº¿ç¨‹çš„ThreadLocalæ•°é‡
     */
    public static int getThreadLocalCount() {
        try {
            Thread thread = Thread.currentThread();
            Field field = Thread.class.getDeclaredField("threadLocals");
            field.setAccessible(true);
            
            Object threadLocalMap = field.get(thread);
            if (threadLocalMap == null) {
                return 0;
            }
            
            Field tableField = threadLocalMap.getClass().getDeclaredField("table");
            tableField.setAccessible(true);
            Object[] table = (Object[]) tableField.get(threadLocalMap);
            
            int count = 0;
            for (Object entry : table) {
                if (entry != null) {
                    count++;
                }
            }
            return count;
        } catch (Exception e) {
            return -1;
        }
    }
    
    /**
     * æ‰“å°ThreadLocalä¿¡æ¯
     */
    public static void printThreadLocalInfo() {
        int count = getThreadLocalCount();
        System.out.println("å½“å‰çº¿ç¨‹ThreadLocalæ•°é‡: " + count);
        System.out.println("çº¿ç¨‹åç§°: " + Thread.currentThread().getName());
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class MonitorDemo {
    private static ThreadLocal<byte[]> holder = new ThreadLocal<>();
    
    public static void main(String[] args) {
        ThreadLocalMonitor.printThreadLocalInfo(); // 0
        
        holder.set(new byte[1024 * 1024]); // 1MB
        ThreadLocalMonitor.printThreadLocalInfo(); // 1
        
        holder.remove();
        ThreadLocalMonitor.printThreadLocalInfo(); // 0
    }
}
```

---

**æ–¹æ³•3ï¼šä½¿ç”¨Arthasè¯Šæ–­**

```bash
# è¿æ¥åˆ°Javaè¿›ç¨‹
arthas-boot

# æŸ¥çœ‹ThreadLocal
thread -n 10

# æŸ¥çœ‹æŸä¸ªçº¿ç¨‹çš„ThreadLocal
thread <thread-id>

# æŸ¥çœ‹å †å†…å­˜
heapdump /tmp/heap.hprof
```

---

## 2. ThreadLocalæœ€ä½³å®è·µ

### 2.1 é—®é¢˜3ï¼šå¦‚ä½•æ­£ç¡®ä½¿ç”¨ThreadLocalï¼Ÿ

**æœ€ä½³å®è·µ1ï¼šä½¿ç”¨try-finallyä¿è¯remove**

```java
// âœ… æ­£ç¡®ç¤ºä¾‹
public class BestPractice1 {
    private static final ThreadLocal<User> userHolder = new ThreadLocal<>();
    
    public void handleRequest(User user) {
        try {
            // è®¾ç½®å€¼
            userHolder.set(user);
            
            // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
            doSomething();
            
        } finally {
            // å¿…é¡»åœ¨finallyä¸­remove
            userHolder.remove();
        }
    }
}
```

---

**æœ€ä½³å®è·µ2ï¼šä½¿ç”¨withInitialæä¾›é»˜è®¤å€¼**

```java
// âœ… æ¨èï¼šä½¿ç”¨withInitial
public class BestPractice2 {
    private static final ThreadLocal<SimpleDateFormat> sdfHolder = 
        ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd"));
    
    public static String format(Date date) {
        return sdfHolder.get().format(date);
    }
}

// âŒ ä¸æ¨èï¼šé‡å†™initialValue
public class OldWay {
    private static final ThreadLocal<SimpleDateFormat> sdfHolder = 
        new ThreadLocal<SimpleDateFormat>() {
            @Override
            protected SimpleDateFormat initialValue() {
                return new SimpleDateFormat("yyyy-MM-dd");
            }
        };
}
```

---

**æœ€ä½³å®è·µ3ï¼šå°è£…ThreadLocalå·¥å…·ç±»**

```java
public class ThreadLocalUtil {
    /**
     * åˆ›å»ºå¸¦è‡ªåŠ¨æ¸…ç†çš„ThreadLocal
     */
    public static <T> ThreadLocal<T> createAutoCleanThreadLocal() {
        return new ThreadLocal<T>() {
            @Override
            public void set(T value) {
                super.set(value);
                // æ³¨å†Œæ¸…ç†é’©å­
                registerCleanupHook();
            }
        };
    }
    
    /**
     * æ³¨å†Œæ¸…ç†é’©å­ï¼ˆåœ¨è¯·æ±‚ç»“æŸæ—¶è‡ªåŠ¨æ¸…ç†ï¼‰
     */
    private static void registerCleanupHook() {
        // å®ç°è‡ªåŠ¨æ¸…ç†é€»è¾‘
        // ä¾‹å¦‚ï¼šåœ¨Servlet Filterä¸­ç»Ÿä¸€æ¸…ç†
    }
}
```

---

**æœ€ä½³å®è·µ4ï¼šä½¿ç”¨Servlet Filterç»Ÿä¸€ç®¡ç†**

```java
public class ThreadLocalCleanupFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        try {
            // æ‰§è¡Œè¯·æ±‚
            chain.doFilter(request, response);
        } finally {
            // ç»Ÿä¸€æ¸…ç†æ‰€æœ‰ThreadLocal
            UserContextHolder.clear();
            TraceContextHolder.clear();
            // ... æ¸…ç†å…¶ä»–ThreadLocal
        }
    }
}
```

---

**æœ€ä½³å®è·µ5ï¼šé¿å…å­˜å‚¨å¤§å¯¹è±¡**

```java
// âŒ é”™è¯¯ï¼šå­˜å‚¨å¤§å¯¹è±¡
public class BadPractice {
    private static ThreadLocal<byte[]> holder = new ThreadLocal<>();
    
    public void process() {
        // å­˜å‚¨10MBæ•°æ®
        holder.set(new byte[10 * 1024 * 1024]);
    }
}

// âœ… æ­£ç¡®ï¼šåªå­˜å‚¨å¿…è¦çš„å°å¯¹è±¡
public class GoodPractice {
    private static ThreadLocal<Long> userIdHolder = new ThreadLocal<>();
    
    public void process(User user) {
        // åªå­˜å‚¨ç”¨æˆ·ID
        userIdHolder.set(user.getId());
        
        // éœ€è¦æ—¶å†æŸ¥è¯¢å®Œæ•´ç”¨æˆ·ä¿¡æ¯
        User fullUser = userService.getById(userIdHolder.get());
    }
}
```

---

### 2.2 é—®é¢˜4ï¼šçº¿ç¨‹æ± åœºæ™¯ä¸‹çš„ç‰¹æ®Šæ³¨æ„äº‹é¡¹ï¼Ÿ

**é—®é¢˜ï¼šçº¿ç¨‹å¤ç”¨å¯¼è‡´çš„æ•°æ®æ±¡æŸ“**

```java
public class ThreadPoolProblem {
    private static ThreadLocal<String> holder = new ThreadLocal<>();
    private static ExecutorService executor = Executors.newFixedThreadPool(2);
    
    public static void main(String[] args) throws InterruptedException {
        // ä»»åŠ¡1ï¼šè®¾ç½®å€¼
        executor.execute(() -> {
            holder.set("task1 value");
            System.out.println("Task1: " + holder.get());
            // å¿˜è®°remove
        });
        
        Thread.sleep(100);
        
        // ä»»åŠ¡2ï¼šæœŸæœ›æ˜¯nullï¼Œä½†å¯èƒ½è·å–åˆ°task1çš„å€¼
        executor.execute(() -> {
            String value = holder.get();
            System.out.println("Task2: " + value); // å¯èƒ½è¾“å‡º"task1 value"
        });
    }
}
```

**è¾“å‡º**ï¼š

```
Task1: task1 value
Task2: task1 value  â† é”™è¯¯ï¼è·å–åˆ°äº†ä¸Šä¸€ä¸ªä»»åŠ¡çš„å€¼
```

---

**è§£å†³æ–¹æ¡ˆ1ï¼šæ¯ä¸ªä»»åŠ¡å¼€å§‹æ—¶é‡ç½®**

```java
public class Solution1 {
    private static ThreadLocal<String> holder = new ThreadLocal<>();
    
    public void executeTask() {
        try {
            // å¼€å§‹æ—¶é‡ç½®
            holder.remove();
            
            // è®¾ç½®æ–°å€¼
            holder.set("new value");
            
            // æ‰§è¡Œä¸šåŠ¡é€»è¾‘
            doSomething();
            
        } finally {
            // ç»“æŸæ—¶æ¸…ç†
            holder.remove();
        }
    }
}
```

---

**è§£å†³æ–¹æ¡ˆ2ï¼šä½¿ç”¨TransmittableThreadLocalï¼ˆé˜¿é‡Œå¼€æºï¼‰**

```java
// å¼•å…¥ä¾èµ–
// <dependency>
//     <groupId>com.alibaba</groupId>
//     <artifactId>transmittable-thread-local</artifactId>
//     <version>2.14.2</version>
// </dependency>

public class Solution2 {
    private static TransmittableThreadLocal<String> holder = new TransmittableThreadLocal<>();
    
    public void executeTask() {
        holder.set("value");
        
        // ä½¿ç”¨TtlExecutorsåŒ…è£…çº¿ç¨‹æ± 
        ExecutorService executor = TtlExecutors.getTtlExecutorService(
            Executors.newFixedThreadPool(10)
        );
        
        executor.execute(() -> {
            // è‡ªåŠ¨ä¼ é€’çˆ¶çº¿ç¨‹çš„å€¼
            System.out.println(holder.get());
        });
    }
}
```

---

## 3. å¸¸è§é™·é˜±ä¸è§£å†³æ–¹æ¡ˆ

### 3.1 é—®é¢˜5ï¼šThreadLocalçš„å¸¸è§é™·é˜±æœ‰å“ªäº›ï¼Ÿ

**é™·é˜±1ï¼šçˆ¶å­çº¿ç¨‹æ— æ³•ä¼ é€’å€¼**

```java
// âŒ é”™è¯¯ï¼šå­çº¿ç¨‹æ— æ³•è·å–çˆ¶çº¿ç¨‹çš„ThreadLocal
public class Trap1 {
    private static ThreadLocal<String> holder = new ThreadLocal<>();
    
    public static void main(String[] args) {
        holder.set("parent value");
        
        new Thread(() -> {
            System.out.println(holder.get()); // null
        }).start();
    }
}

// âœ… è§£å†³ï¼šä½¿ç”¨InheritableThreadLocal
public class Solution {
    private static InheritableThreadLocal<String> holder = new InheritableThreadLocal<>();
    
    public static void main(String[] args) {
        holder.set("parent value");
        
        new Thread(() -> {
            System.out.println(holder.get()); // "parent value"
        }).start();
    }
}
```

---

**é™·é˜±2ï¼šåœ¨staticä»£ç å—ä¸­åˆå§‹åŒ–ThreadLocal**

```java
// âŒ é”™è¯¯ï¼šstaticä»£ç å—ä¸­åˆå§‹åŒ–
public class Trap2 {
    private static ThreadLocal<Connection> connHolder;
    
    static {
        try {
            Connection conn = DriverManager.getConnection("...");
            connHolder = new ThreadLocal<>();
            connHolder.set(conn); // é”™è¯¯ï¼åªåœ¨ä¸»çº¿ç¨‹è®¾ç½®
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}

// âœ… æ­£ç¡®ï¼šä½¿ç”¨withInitial
public class Solution {
    private static ThreadLocal<Connection> connHolder = 
        ThreadLocal.withInitial(() -> {
            try {
                return DriverManager.getConnection("...");
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        });
}
```

---

**é™·é˜±3ï¼šåœ¨å¼‚æ­¥å›è°ƒä¸­ä½¿ç”¨ThreadLocal**

```java
// âŒ é”™è¯¯ï¼šå¼‚æ­¥å›è°ƒä¸­ThreadLocalå¤±æ•ˆ
public class Trap3 {
    private static ThreadLocal<String> holder = new ThreadLocal<>();
    
    public void asyncProcess() {
        holder.set("value");
        
        CompletableFuture.runAsync(() -> {
            // åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­æ‰§è¡Œ
            System.out.println(holder.get()); // null
        });
    }
}

// âœ… è§£å†³ï¼šæ‰‹åŠ¨ä¼ é€’å€¼
public class Solution {
    private static ThreadLocal<String> holder = new ThreadLocal<>();
    
    public void asyncProcess() {
        String value = holder.get();
        
        CompletableFuture.runAsync(() -> {
            holder.set(value); // æ‰‹åŠ¨è®¾ç½®
            try {
                doSomething();
            } finally {
                holder.remove(); // è®°å¾—æ¸…ç†
            }
        });
    }
}
```

---

**é™·é˜±4ï¼šåœ¨å•ä¾‹Beanä¸­ä½¿ç”¨ThreadLocal**

```java
// âŒ æ½œåœ¨é—®é¢˜ï¼šSpringå•ä¾‹Beanä¸­çš„ThreadLocal
@Service
public class UserService {
    // å•ä¾‹Beançš„å­—æ®µï¼Œè¢«æ‰€æœ‰çº¿ç¨‹å…±äº«
    private ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public void processUser(User user) {
        try {
            currentUser.set(user);
            doSomething();
        } finally {
            currentUser.remove(); // å¿…é¡»æ¸…ç†
        }
    }
}

// âœ… æ›´å¥½çš„æ–¹å¼ï¼šä½¿ç”¨static
@Service
public class UserService {
    // staticå­—æ®µï¼Œæ˜ç¡®è¡¨ç¤ºæ˜¯çº¿ç¨‹çº§åˆ«çš„
    private static ThreadLocal<User> currentUser = new ThreadLocal<>();
    
    public void processUser(User user) {
        try {
            currentUser.set(user);
            doSomething();
        } finally {
            currentUser.remove();
        }
    }
}
```

---

## 4. ThreadLocalä½¿ç”¨æ£€æŸ¥æ¸…å•

### 4.1 é—®é¢˜6ï¼šå¦‚ä½•ç¡®ä¿æ­£ç¡®ä½¿ç”¨ThreadLocalï¼Ÿ

**ä½¿ç”¨å‰æ£€æŸ¥æ¸…å•**ï¼š

```
â–¡ 1. æ˜¯å¦çœŸçš„éœ€è¦ThreadLocalï¼Ÿ
   - èƒ½å¦é€šè¿‡å‚æ•°ä¼ é€’è§£å†³ï¼Ÿ
   - èƒ½å¦ä½¿ç”¨å…¶ä»–æ–¹å¼ï¼ˆå¦‚Request Scopeï¼‰ï¼Ÿ

â–¡ 2. æ˜¯å¦ä½¿ç”¨äº†try-finallyï¼Ÿ
   - set()åæ˜¯å¦åœ¨finallyä¸­remove()ï¼Ÿ
   - å³ä½¿å‘ç”Ÿå¼‚å¸¸ä¹Ÿèƒ½ä¿è¯remove()ï¼Ÿ

â–¡ 3. æ˜¯å¦é¿å…äº†å¤§å¯¹è±¡ï¼Ÿ
   - å­˜å‚¨çš„å¯¹è±¡æ˜¯å¦è¶³å¤Ÿå°ï¼Ÿ
   - èƒ½å¦åªå­˜å‚¨IDè€Œéå®Œæ•´å¯¹è±¡ï¼Ÿ

â–¡ 4. æ˜¯å¦è€ƒè™‘äº†çº¿ç¨‹æ± åœºæ™¯ï¼Ÿ
   - çº¿ç¨‹å¤ç”¨æ—¶æ˜¯å¦ä¼šæ•°æ®æ±¡æŸ“ï¼Ÿ
   - æ˜¯å¦åœ¨ä»»åŠ¡å¼€å§‹æ—¶é‡ç½®ï¼Ÿ

â–¡ 5. æ˜¯å¦è€ƒè™‘äº†çˆ¶å­çº¿ç¨‹ä¼ é€’ï¼Ÿ
   - æ˜¯å¦éœ€è¦InheritableThreadLocalï¼Ÿ
   - æ˜¯å¦éœ€è¦TransmittableThreadLocalï¼Ÿ

â–¡ 6. æ˜¯å¦æ·»åŠ äº†ç›‘æ§ï¼Ÿ
   - æ˜¯å¦èƒ½æ£€æµ‹å†…å­˜æ³„æ¼ï¼Ÿ
   - æ˜¯å¦èƒ½ç»Ÿè®¡ThreadLocalæ•°é‡ï¼Ÿ

â–¡ 7. æ˜¯å¦ç¼–å†™äº†å•å…ƒæµ‹è¯•ï¼Ÿ
   - æ˜¯å¦æµ‹è¯•äº†remove()é€»è¾‘ï¼Ÿ
   - æ˜¯å¦æµ‹è¯•äº†å¼‚å¸¸æƒ…å†µï¼Ÿ
```

---

**ä»£ç å®¡æŸ¥æ£€æŸ¥æ¸…å•**ï¼š

```java
// âŒ ä»£ç å®¡æŸ¥æ—¶éœ€è¦è­¦æƒ•çš„æ¨¡å¼
public class CodeReviewChecklist {
    
    // 1. æ²¡æœ‰åœ¨finallyä¸­remove
    public void bad1() {
        threadLocal.set(value);
        doSomething();
        threadLocal.remove(); // âŒ å¦‚æœdoSomething()æŠ›å¼‚å¸¸ï¼Œä¸ä¼šæ‰§è¡Œ
    }
    
    // 2. å­˜å‚¨å¤§å¯¹è±¡
    private static ThreadLocal<byte[]> bad2 = new ThreadLocal<>(); // âŒ
    
    // 3. åœ¨å¾ªç¯ä¸­ä½¿ç”¨ThreadLocal
    public void bad3() {
        for (int i = 0; i < 1000; i++) {
            threadLocal.set(value);
            doSomething();
            // âŒ æ²¡æœ‰removeï¼Œå¯èƒ½å¯¼è‡´å†…å­˜ç´¯ç§¯
        }
    }
    
    // 4. åœ¨å¼‚æ­¥å›è°ƒä¸­ä½¿ç”¨
    public void bad4() {
        threadLocal.set(value);
        CompletableFuture.runAsync(() -> {
            threadLocal.get(); // âŒ è·å–ä¸åˆ°å€¼
        });
    }
}
```

---

## 5. æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 5.1 é—®é¢˜7ï¼šå¦‚ä½•ä¼˜åŒ–ThreadLocalçš„æ€§èƒ½ï¼Ÿ

**ä¼˜åŒ–1ï¼šå‡å°‘ThreadLocalæ•°é‡**

```java
// âŒ ä¸æ¨èï¼šå¤šä¸ªThreadLocal
public class MultipleThreadLocal {
    private static ThreadLocal<String> userId = new ThreadLocal<>();
    private static ThreadLocal<String> userName = new ThreadLocal<>();
    private static ThreadLocal<String> userRole = new ThreadLocal<>();
}

// âœ… æ¨èï¼šä½¿ç”¨ä¸€ä¸ªThreadLocalå­˜å‚¨ä¸Šä¸‹æ–‡å¯¹è±¡
public class SingleThreadLocal {
    private static ThreadLocal<UserContext> context = new ThreadLocal<>();
    
    public static class UserContext {
        private String userId;
        private String userName;
        private String userRole;
        // getters and setters
    }
}
```

---

**ä¼˜åŒ–2ï¼šå»¶è¿Ÿåˆå§‹åŒ–**

```java
// âŒ ä¸æ¨èï¼šç«‹å³åˆå§‹åŒ–
public class EagerInit {
    private static ThreadLocal<Connection> connHolder = 
        ThreadLocal.withInitial(() -> {
            // å³ä½¿ä¸ä½¿ç”¨ï¼Œä¹Ÿä¼šåˆ›å»ºè¿æ¥
            return createConnection();
        });
}

// âœ… æ¨èï¼šæŒ‰éœ€åˆå§‹åŒ–
public class LazyInit {
    private static ThreadLocal<Connection> connHolder = new ThreadLocal<>();
    
    public static Connection getConnection() {
        Connection conn = connHolder.get();
        if (conn == null) {
            conn = createConnection();
            connHolder.set(conn);
        }
        return conn;
    }
}
```

---

**ä¼˜åŒ–3ï¼šä½¿ç”¨å¯¹è±¡æ± **

```java
// å¦‚æœå¯¹è±¡åˆ›å»ºå¼€é”€å¤§ï¼Œè€ƒè™‘ä½¿ç”¨å¯¹è±¡æ± 
public class ObjectPoolThreadLocal {
    private static ThreadLocal<ObjectPool<ExpensiveObject>> poolHolder = 
        ThreadLocal.withInitial(() -> new ObjectPool<>(ExpensiveObject::new));
    
    public static ExpensiveObject borrowObject() {
        return poolHolder.get().borrow();
    }
    
    public static void returnObject(ExpensiveObject obj) {
        poolHolder.get().returnObject(obj);
    }
}
```

---

## 6. æ ¸å¿ƒé—®é¢˜æ€»ç»“

### Q1: ThreadLocalå†…å­˜æ³„æ¼çš„æ ¹æœ¬åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ
**A**: ä½¿ç”¨åä¸è°ƒç”¨remove()ï¼Œå¯¼è‡´valueçš„å¼ºå¼•ç”¨é“¾è·¯æ— æ³•æ–­å¼€ï¼Œç‰¹åˆ«æ˜¯åœ¨çº¿ç¨‹æ± åœºæ™¯ä¸‹ã€‚

### Q2: å¦‚ä½•æ£€æµ‹ThreadLocalå†…å­˜æ³„æ¼ï¼Ÿ
**A**: ä½¿ç”¨JProfiler/VisualVMæŸ¥çœ‹Heap Dumpï¼Œæˆ–ä½¿ç”¨ä»£ç ç›‘æ§ThreadLocalæ•°é‡ã€‚

### Q3: ThreadLocalçš„æœ€ä½³å®è·µæ˜¯ä»€ä¹ˆï¼Ÿ
**A**: 
1. ä½¿ç”¨try-finallyä¿è¯remove()
2. ä½¿ç”¨withInitialæä¾›é»˜è®¤å€¼
3. é¿å…å­˜å‚¨å¤§å¯¹è±¡
4. çº¿ç¨‹æ± åœºæ™¯ä¸‹æ³¨æ„æ•°æ®æ±¡æŸ“

### Q4: çº¿ç¨‹æ± åœºæ™¯ä¸‹æœ‰ä»€ä¹ˆç‰¹æ®Šæ³¨æ„äº‹é¡¹ï¼Ÿ
**A**: çº¿ç¨‹å¤ç”¨å¯èƒ½å¯¼è‡´æ•°æ®æ±¡æŸ“ï¼Œéœ€è¦åœ¨ä»»åŠ¡å¼€å§‹æ—¶é‡ç½®ï¼Œç»“æŸæ—¶æ¸…ç†ã€‚

### Q5: ThreadLocalçš„å¸¸è§é™·é˜±æœ‰å“ªäº›ï¼Ÿ
**A**: 
1. çˆ¶å­çº¿ç¨‹æ— æ³•ä¼ é€’å€¼
2. åœ¨staticä»£ç å—ä¸­åˆå§‹åŒ–
3. åœ¨å¼‚æ­¥å›è°ƒä¸­ä½¿ç”¨
4. åœ¨å•ä¾‹Beanä¸­ä½¿ç”¨

### Q6: å¦‚ä½•ä¼˜åŒ–ThreadLocalçš„æ€§èƒ½ï¼Ÿ
**A**: 
1. å‡å°‘ThreadLocalæ•°é‡
2. å»¶è¿Ÿåˆå§‹åŒ–
3. ä½¿ç”¨å¯¹è±¡æ± 

---

## ä¸‹ä¸€ç« é¢„å‘Š

ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ ï¼š

- **InheritableThreadLocalçš„å®ç°åŸç†**
- **çˆ¶å­çº¿ç¨‹å€¼ä¼ é€’æœºåˆ¶**
- **TransmittableThreadLocalçš„ä¼˜åŒ–**
- **Nettyçš„FastThreadLocal**
- **ThreadLocalçš„æ›¿ä»£æ–¹æ¡ˆ**

è®©æˆ‘ä»¬ç»§ç»­æ·±å…¥ï¼ğŸš€
