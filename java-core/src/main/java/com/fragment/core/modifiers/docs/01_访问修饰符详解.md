# Java 访问修饰符详解

## 概述

Java 提供了四种访问级别的修饰符，用于控制类、方法、变量的可见性和访问范围。

## 访问修饰符分类

### 1. public（公共的）

**作用范围：** 所有类都可以访问

**适用于：**
- 类（顶层类）
- 接口
- 方法
- 变量
- 构造器

**特点：**
- 最宽松的访问级别
- 可以被任何其他类访问
- public 类必须与文件名相同
- 一个 .java 文件只能有一个 public 类

**使用场景：**
```java
// 对外提供的 API 接口
public class UserService {
    // 公共方法，供外部调用
    public User getUserById(Long id) {
        return userRepository.findById(id);
    }
}

// 公共常量
public class Constants {
    public static final String APP_NAME = "MyApp";
    public static final int MAX_SIZE = 100;
}
```

### 2. protected（受保护的）

**作用范围：** 同一包内的类 + 不同包的子类

**适用于：**
- 方法
- 变量
- 构造器
- 内部类

**注意：** 不能修饰顶层类（只能修饰内部类）

**特点：**
- 介于 public 和 private 之间
- 支持继承体系中的访问
- 子类可以访问父类的 protected 成员

**使用场景：**
```java
public class Animal {
    // 受保护的属性，子类可以访问
    protected String name;
    protected int age;
    
    // 受保护的方法，供子类重写或调用
    protected void makeSound() {
        System.out.println("Animal makes sound");
    }
}

public class Dog extends Animal {
    public void bark() {
        // 子类可以访问父类的 protected 成员
        this.name = "Dog";
        makeSound();
    }
}
```

### 3. default（默认的，包访问权限）

**作用范围：** 仅限同一包内的类

**适用于：**
- 类（顶层类）
- 接口
- 方法
- 变量
- 构造器

**特点：**
- 不需要显式声明关键字
- 也称为 package-private
- 同一包内的类可以互相访问

**使用场景：**
```java
// 包内部使用的工具类，不对外暴露
class PackageUtils {
    // 包内可见的方法
    static String formatDate(Date date) {
        return new SimpleDateFormat("yyyy-MM-dd").format(date);
    }
}

public class UserService {
    // 包内可见的辅助方法
    void validateUser(User user) {
        // 验证逻辑
    }
}
```

### 4. private（私有的）

**作用范围：** 仅限当前类内部

**适用于：**
- 方法
- 变量
- 构造器
- 内部类

**注意：** 不能修饰顶层类（只能修饰内部类）

**特点：**
- 最严格的访问级别
- 实现封装的核心手段
- 外部类无法访问

**使用场景：**
```java
public class BankAccount {
    // 私有属性，外部无法直接访问
    private String accountNumber;
    private double balance;
    
    // 私有方法，仅供内部使用
    private boolean validateAmount(double amount) {
        return amount > 0 && amount <= balance;
    }
    
    // 公共方法提供受控访问
    public boolean withdraw(double amount) {
        if (validateAmount(amount)) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    // 私有构造器，防止外部实例化
    private BankAccount() {
        // 单例模式常用
    }
}
```

## 访问级别对比表

| 修饰符 | 当前类 | 同一包 | 子类（不同包） | 其他包 |
|--------|--------|--------|----------------|--------|
| public | ✓ | ✓ | ✓ | ✓ |
| protected | ✓ | ✓ | ✓ | ✗ |
| default | ✓ | ✓ | ✗ | ✗ |
| private | ✓ | ✗ | ✗ | ✗ |

## 最佳实践

### 1. 最小权限原则
```java
public class User {
    // 优先使用 private
    private Long id;
    private String username;
    
    // 必要时提供 public getter/setter
    public Long getId() {
        return id;
    }
}
```

### 2. 封装原则
```java
public class ShoppingCart {
    // 私有集合，防止外部直接修改
    private List<Item> items = new ArrayList<>();
    
    // 提供受控的添加方法
    public void addItem(Item item) {
        if (item != null && item.isValid()) {
            items.add(item);
        }
    }
    
    // 返回不可修改的视图
    public List<Item> getItems() {
        return Collections.unmodifiableList(items);
    }
}
```

### 3. 继承设计
```java
public abstract class BaseService {
    // protected 供子类使用
    protected Logger logger = LoggerFactory.getLogger(getClass());
    
    // protected 模板方法
    protected void beforeProcess() {
        logger.info("Processing started");
    }
    
    // public 最终方法
    public final void process() {
        beforeProcess();
        doProcess();
        afterProcess();
    }
    
    // protected 抽象方法，强制子类实现
    protected abstract void doProcess();
    
    protected void afterProcess() {
        logger.info("Processing completed");
    }
}
```

### 4. 包设计
```java
// com.example.service.internal 包
class ServiceHelper {
    // 包内工具类，不对外暴露
    static void logOperation(String operation) {
        // ...
    }
}

// com.example.service 包
public class UserService {
    void internalMethod() {
        // 包内方法，供同包其他 Service 调用
    }
}
```

## 常见错误

### 1. 过度使用 public
```java
// ❌ 不好的做法
public class User {
    public String password; // 敏感信息暴露
    public List<Order> orders; // 可被外部直接修改
}

// ✓ 好的做法
public class User {
    private String password;
    private List<Order> orders = new ArrayList<>();
    
    public boolean verifyPassword(String input) {
        return password.equals(input);
    }
}
```

### 2. protected 的误用
```java
// ❌ 不好的做法
public class BaseEntity {
    protected Long id; // 所有子类都能修改 ID
}

// ✓ 好的做法
public class BaseEntity {
    private Long id;
    
    protected Long getId() {
        return id;
    }
}
```

### 3. 忽略包访问权限
```java
// ❌ 不好的做法 - 所有方法都是 public
public class UserRepository {
    public User findById(Long id) { }
    public void saveToCache(User user) { } // 内部方法也是 public
    public void clearCache() { } // 内部方法也是 public
}

// ✓ 好的做法
public class UserRepository {
    public User findById(Long id) { }
    
    // 包内或私有方法
    void saveToCache(User user) { }
    private void clearCache() { }
}
```

## 总结

1. **默认使用最严格的访问级别**，需要时再放宽
2. **public** 用于对外 API
3. **protected** 用于继承体系
4. **default** 用于包内协作
5. **private** 用于内部实现

遵循这些原则可以提高代码的封装性、安全性和可维护性。
