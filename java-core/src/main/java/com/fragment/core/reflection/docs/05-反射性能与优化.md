# 05 反射性能与优化

## 反射的性能开销

### 性能对比数据
基于 `PerformanceDemo.java` 的测试结果：
- **直接调用**：基准性能
- **反射调用**：比直接调用慢 50-100 倍
- **缓存反射调用**：比未缓存快 10-20 倍，但仍比直接调用慢 10-50 倍

### 性能开销来源

1. **方法查找**：`getMethod()` 需要遍历类层次结构
2. **安全检查**：访问权限验证
3. **参数装箱**：基本类型与包装类型转换
4. **异常包装**：`InvocationTargetException` 包装
5. **JIT 优化限制**：反射调用难以内联优化

## 优化策略

### 1. 缓存反射对象
```java
// 不好：每次都重新获取
for (int i = 0; i < 1000000; i++) {
    Method method = clazz.getMethod("getName");
    method.invoke(obj);
}

// 好：缓存 Method 对象
Method method = clazz.getMethod("getName");
for (int i = 0; i < 1000000; i++) {
    method.invoke(obj);
}
```

### 2. 使用 ConcurrentHashMap 缓存
```java
private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();

public static Method getMethodCached(Class<?> clazz, String methodName, Class<?>... paramTypes) {
    String key = clazz.getName() + "#" + methodName + "#" + Arrays.toString(paramTypes);
    return methodCache.computeIfAbsent(key, k -> {
        try {
            return clazz.getMethod(methodName, paramTypes);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    });
}
```

### 3. 批量操作
```java
// 不好：逐个字段操作
for (Field field : fields) {
    field.setAccessible(true);
    Object value = field.get(source);
    field.set(target, value);
}

// 好：批量设置访问权限
Field.setAccessible(fields, true);
for (Field field : fields) {
    Object value = field.get(source);
    field.set(target, value);
}
```

### 4. 避免不必要的 setAccessible
```java
// 检查是否已经可访问
if (!method.isAccessible()) {
    method.setAccessible(true);
}
```

## 替代方案

### 1. MethodHandle（Java 7+）
```java
MethodHandles.Lookup lookup = MethodHandles.lookup();
MethodHandle getter = lookup.findGetter(Person.class, "name", String.class);

// 调用比反射快，但仍比直接调用慢
String name = (String) getter.invoke(person);
```

### 2. 字节码生成
使用 ASM、CGLIB、ByteBuddy 等库生成字节码：
```java
// 使用 ByteBuddy 生成访问器
Class<?> accessorClass = new ByteBuddy()
    .subclass(Object.class)
    .method(named("getName"))
    .intercept(FieldAccessor.ofField("name"))
    .make()
    .load(getClass().getClassLoader())
    .getLoaded();
```

### 3. 编译时代码生成
使用注解处理器在编译时生成代码，运行时直接调用生成的代码。

## JVM 优化机制

### 1. 反射调用的 JVM 优化
- **本地实现**：前 15 次调用使用本地方法
- **字节码生成**：超过阈值后生成优化的字节码
- **内联优化**：在某些情况下可以内联反射调用

### 2. 影响优化的因素
- **调用频率**：频繁调用的反射方法更容易被优化
- **方法复杂度**：简单方法更容易内联
- **多态性**：单态调用比多态调用更容易优化

## 最佳实践

### 1. 设计原则
- **最小化反射使用**：只在必要时使用反射
- **缓存优先**：缓存所有反射对象
- **批量操作**：减少反射调用次数
- **异常处理**：合理处理反射异常

### 2. 代码示例
```java
public class OptimizedReflectionUtil {
    private static final Map<String, Field> fieldCache = new ConcurrentHashMap<>();
    private static final Map<String, Method> methodCache = new ConcurrentHashMap<>();
    
    public static void copyProperties(Object source, Object target) {
        Class<?> sourceClass = source.getClass();
        Class<?> targetClass = target.getClass();
        
        Field[] fields = sourceClass.getDeclaredFields();
        Field.setAccessible(fields, true); // 批量设置
        
        for (Field sourceField : fields) {
            try {
                Field targetField = getFieldCached(targetClass, sourceField.getName());
                if (targetField != null && targetField.getType().equals(sourceField.getType())) {
                    Object value = sourceField.get(source);
                    targetField.set(target, value);
                }
            } catch (Exception e) {
                // 处理异常
            }
        }
    }
    
    private static Field getFieldCached(Class<?> clazz, String fieldName) {
        String key = clazz.getName() + "#" + fieldName;
        return fieldCache.computeIfAbsent(key, k -> {
            try {
                Field field = clazz.getDeclaredField(fieldName);
                field.setAccessible(true);
                return field;
            } catch (NoSuchFieldException e) {
                return null;
            }
        });
    }
}
```

### 3. 性能监控
```java
public class ReflectionProfiler {
    private static final Map<String, Long> callCounts = new ConcurrentHashMap<>();
    private static final Map<String, Long> totalTimes = new ConcurrentHashMap<>();
    
    public static Object invokeWithProfiling(Method method, Object obj, Object... args) throws Exception {
        String key = method.getDeclaringClass().getName() + "#" + method.getName();
        long start = System.nanoTime();
        
        try {
            return method.invoke(obj, args);
        } finally {
            long duration = System.nanoTime() - start;
            callCounts.merge(key, 1L, Long::sum);
            totalTimes.merge(key, duration, Long::sum);
        }
    }
    
    public static void printStats() {
        callCounts.forEach((method, count) -> {
            long totalTime = totalTimes.get(method);
            System.out.printf("%s: %d calls, avg: %.2f μs%n", 
                method, count, totalTime / 1000.0 / count);
        });
    }
}
```

## 何时避免反射

### 1. 高频调用场景
- 游戏循环中的对象更新
- 高并发服务的请求处理
- 实时数据处理

### 2. 性能敏感的代码路径
- 数据库 ORM 的热点查询
- 序列化/反序列化的核心逻辑
- 缓存系统的数据访问

### 3. 替代方案
- 使用接口和多态代替反射调用
- 编译时代码生成
- 配置驱动的工厂模式

## 示例代码位置

- `PerformanceDemo.java`：反射性能对比测试
- `BeanCopyUtil.java`：优化的反射工具示例
