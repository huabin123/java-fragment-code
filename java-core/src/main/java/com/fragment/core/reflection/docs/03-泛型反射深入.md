# 03 泛型反射深入

## 泛型擦除与反射

### 泛型擦除机制
Java 的泛型在编译时会发生类型擦除，但在某些情况下，泛型信息仍然保留在字节码中，可以通过反射获取。

### 保留泛型信息的场景
1. **字段声明**：`private List<String> items;`
2. **方法参数**：`public void method(List<String> list)`
3. **方法返回值**：`public List<String> getItems()`
4. **类继承**：`class StringList extends ArrayList<String>`

## Type 体系结构

### Type 接口层次
```
Type (接口)
├── Class (类)
├── ParameterizedType (参数化类型)
├── TypeVariable (类型变量)
├── WildcardType (通配符类型)
└── GenericArrayType (泛型数组类型)
```

### ParameterizedType（参数化类型）
表示带有类型参数的类型，如 `List<String>`、`Map<String, Integer>`

```java
Field field = clazz.getDeclaredField("stringList");
Type genericType = field.getGenericType();

if (genericType instanceof ParameterizedType) {
    ParameterizedType pt = (ParameterizedType) genericType;
    
    // 原始类型：List
    Type rawType = pt.getRawType();
    
    // 类型参数：[String]
    Type[] actualTypes = pt.getActualTypeArguments();
}
```

### TypeVariable（类型变量）
表示泛型声明中的类型变量，如 `T`、`E`

```java
class GenericClass<T extends Comparable<T>> {
    // T 就是 TypeVariable
}

TypeVariable<?>[] typeParams = GenericClass.class.getTypeParameters();
for (TypeVariable<?> typeParam : typeParams) {
    String name = typeParam.getName(); // "T"
    Type[] bounds = typeParam.getBounds(); // [Comparable<T>]
}
```

### WildcardType（通配符类型）
表示通配符类型，如 `? extends Number`、`? super Integer`

```java
// List<? extends Number>
Field field = clazz.getDeclaredField("numberList");
Type genericType = field.getGenericType();

if (genericType instanceof ParameterizedType) {
    Type[] actualTypes = ((ParameterizedType) genericType).getActualTypeArguments();
    Type wildcardType = actualTypes[0];
    
    if (wildcardType instanceof WildcardType) {
        WildcardType wt = (WildcardType) wildcardType;
        Type[] upperBounds = wt.getUpperBounds(); // [Number]
        Type[] lowerBounds = wt.getLowerBounds(); // []
    }
}
```

## 实际应用场景

### JSON 序列化框架
```java
public <T> T fromJson(String json, Class<T> clazz) {
    // 使用反射获取字段的泛型信息
    // 正确处理 List<String>、Map<String, Object> 等复杂类型
}
```

### 依赖注入框架
```java
@Inject
private List<UserService> userServices; // 注入所有 UserService 实现

// 框架通过反射获取泛型信息，知道要注入 UserService 类型的 List
```

### ORM 框架
```java
public class User {
    private List<Order> orders; // 一对多关系
}

// ORM 框架通过泛型反射知道 orders 字段包含 Order 对象
```

## 泛型反射的限制

### 运行时类型擦除
```java
List<String> stringList = new ArrayList<>();
List<Integer> intList = new ArrayList<>();

// 运行时无法区分，都是 ArrayList
System.out.println(stringList.getClass() == intList.getClass()); // true
```

### 无法获取局部变量泛型
```java
public void method() {
    List<String> localList = new ArrayList<>(); // 无法通过反射获取泛型信息
}
```

## 高级技巧

### 通过匿名类保留泛型信息
```java
// Gson 的 TypeToken 技巧
Type listType = new TypeToken<List<String>>(){}.getType();
```

### 泛型数组处理
```java
// 创建泛型数组
@SuppressWarnings("unchecked")
T[] array = (T[]) Array.newInstance(componentType, size);
```

## 示例代码位置

- `GenericReflectionDemo.java`：完整的泛型反射演示
- `GenericContainer.java`：泛型类示例
