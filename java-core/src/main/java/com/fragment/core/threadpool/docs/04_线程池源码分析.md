# ç¬¬å››ç« ï¼šçº¿ç¨‹æ± æºç åˆ†æ

## å¼•è¨€

æœ¬ç« å°†æ·±å…¥ThreadPoolExecutorçš„æºç ï¼Œç†è§£å…¶ç²¾å¦™çš„è®¾è®¡å’Œå®ç°ç»†èŠ‚ã€‚

---

## 1. ctlçš„å·§å¦™è®¾è®¡

### 1.1 é—®é¢˜1ï¼šä¸ºä»€ä¹ˆç”¨ä¸€ä¸ªAtomicIntegerè¡¨ç¤ºä¸¤ä¸ªå€¼ï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
// ä½¿ç”¨ä¸€ä¸ª32ä½æ•´æ•°åŒæ—¶è¡¨ç¤ºä¸¤ä¸ªä¿¡æ¯
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// é«˜3ä½ï¼šè¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€ï¼ˆ5ç§çŠ¶æ€ï¼‰
// ä½29ä½ï¼šè¡¨ç¤ºå·¥ä½œçº¿ç¨‹æ•°é‡ï¼ˆæœ€å¤š5äº¿ä¸ªçº¿ç¨‹ï¼‰
private static final int COUNT_BITS = Integer.SIZE - 3;  // 29
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;  // 0001 1111...ï¼ˆ29ä¸ª1ï¼‰

// çº¿ç¨‹æ± çŠ¶æ€ï¼ˆå­˜å‚¨åœ¨é«˜3ä½ï¼‰
private static final int RUNNING    = -1 << COUNT_BITS;  // 111 00000...
private static final int SHUTDOWN   =  0 << COUNT_BITS;  // 000 00000...
private static final int STOP       =  1 << COUNT_BITS;  // 001 00000...
private static final int TIDYING    =  2 << COUNT_BITS;  // 010 00000...
private static final int TERMINATED =  3 << COUNT_BITS;  // 011 00000...

// è·å–è¿è¡ŒçŠ¶æ€
private static int runStateOf(int c)     { return c & ~CAPACITY; }
// è·å–å·¥ä½œçº¿ç¨‹æ•°
private static int workerCountOf(int c)  { return c & CAPACITY; }
// ç»„åˆçŠ¶æ€å’Œçº¿ç¨‹æ•°
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

**è®¾è®¡ä¼˜åŠ¿**ï¼š

1. **åŸå­æ€§**ï¼šçŠ¶æ€å’Œçº¿ç¨‹æ•°å¿…é¡»åŒæ—¶æ›´æ–°ï¼Œä¸€æ¬¡CASæ“ä½œå®Œæˆ
2. **æ€§èƒ½**ï¼šé¿å…ä½¿ç”¨ä¸¤ä¸ªAtomicIntegerï¼Œå‡å°‘å†…å­˜å ç”¨
3. **ä¸€è‡´æ€§**ï¼šä¿è¯çŠ¶æ€å’Œçº¿ç¨‹æ•°çš„å¼ºä¸€è‡´æ€§

**ä½è¿ç®—å›¾è§£**ï¼š

```
ctl = 111 00000000000000000000000000101
      â†‘â†‘â†‘ â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘â†‘
      çŠ¶æ€  å·¥ä½œçº¿ç¨‹æ•°ï¼ˆ5ä¸ªçº¿ç¨‹ï¼‰
      
runStateOf(ctl):
  ctl & ~CAPACITY
  = 111 00000000000000000000000000101
  & 111 00000000000000000000000000000
  = 111 00000000000000000000000000000  (RUNNING)

workerCountOf(ctl):
  ctl & CAPACITY
  = 111 00000000000000000000000000101
  & 000 11111111111111111111111111111
  = 000 00000000000000000000000000101  (5)
```

---

## 2. execute()æ–¹æ³•æºç å‰–æ

### 2.2 é—®é¢˜2ï¼šä»»åŠ¡æäº¤çš„å®Œæ•´æµç¨‹æ˜¯ä»€ä¹ˆï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    
    // è·å–ctlå€¼
    int c = ctl.get();
    
    // æ­¥éª¤1: å¦‚æœå½“å‰çº¿ç¨‹æ•° < æ ¸å¿ƒçº¿ç¨‹æ•°ï¼Œåˆ›å»ºæ ¸å¿ƒçº¿ç¨‹
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))  // trueè¡¨ç¤ºæ ¸å¿ƒçº¿ç¨‹
            return;  // åˆ›å»ºæˆåŠŸï¼Œç›´æ¥è¿”å›
        c = ctl.get();  // åˆ›å»ºå¤±è´¥ï¼Œé‡æ–°è·å–ctl
    }
    
    // æ­¥éª¤2: å°è¯•å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // åŒé‡æ£€æŸ¥ï¼šå¦‚æœçº¿ç¨‹æ± å·²å…³é—­ï¼Œç§»é™¤ä»»åŠ¡å¹¶æ‹’ç»
        if (!isRunning(recheck) && remove(command))
            reject(command);
        // å¦‚æœæ²¡æœ‰å·¥ä½œçº¿ç¨‹ï¼Œåˆ›å»ºä¸€ä¸ªï¼ˆé˜²æ­¢é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡æ— äººæ‰§è¡Œï¼‰
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // æ­¥éª¤3: é˜Ÿåˆ—æ»¡äº†ï¼Œå°è¯•åˆ›å»ºä¸´æ—¶çº¿ç¨‹
    else if (!addWorker(command, false)) {  // falseè¡¨ç¤ºéæ ¸å¿ƒçº¿ç¨‹
        // æ­¥éª¤4: æ— æ³•åˆ›å»ºçº¿ç¨‹ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
        reject(command);
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **ä¸ºä»€ä¹ˆéœ€è¦åŒé‡æ£€æŸ¥ï¼Ÿ**
   - çº¿ç¨‹æ± çŠ¶æ€å¯èƒ½åœ¨ä»»åŠ¡å…¥é˜Ÿåæ”¹å˜
   - éœ€è¦ç¡®ä¿å·²å…³é—­çš„çº¿ç¨‹æ± ä¸æ‰§è¡Œæ–°ä»»åŠ¡

2. **ä¸ºä»€ä¹ˆé˜Ÿåˆ—æˆåŠŸåè¿˜è¦æ£€æŸ¥çº¿ç¨‹æ•°ï¼Ÿ**
   - é˜²æ­¢æ‰€æœ‰æ ¸å¿ƒçº¿ç¨‹éƒ½å·²é€€å‡ºï¼Œå¯¼è‡´é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡æ— äººæ‰§è¡Œ

---

## 3. addWorker()æ–¹æ³•æºç å‰–æ

### 3.1 é—®é¢˜3ï¼šWorkeræ˜¯å¦‚ä½•åˆ›å»ºçš„ï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;
        
        // CASå¢åŠ çº¿ç¨‹æ•°
        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;  // CASæˆåŠŸï¼Œè·³å‡ºå¤–å±‚å¾ªç¯
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;  // çŠ¶æ€æ”¹å˜ï¼Œé‡è¯•
        }
    }
    
    // åˆ›å»ºWorker
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())
                        throw new IllegalThreadStateException();
                    workers.add(w);  // æ·»åŠ åˆ°workersé›†åˆ
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();  // å¯åŠ¨Workerçº¿ç¨‹
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

**å…³é”®ç‚¹**ï¼š

1. **ä¸ºä»€ä¹ˆä½¿ç”¨ä¸¤å±‚å¾ªç¯ï¼Ÿ**
   - å¤–å±‚å¾ªç¯ï¼šæ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
   - å†…å±‚å¾ªç¯ï¼šCASå¢åŠ çº¿ç¨‹æ•°

2. **ä¸ºä»€ä¹ˆéœ€è¦mainLockï¼Ÿ**
   - workersæ˜¯HashSetï¼Œéçº¿ç¨‹å®‰å…¨
   - éœ€è¦ä¿æŠ¤workersçš„æ·»åŠ æ“ä½œ

---

## 4. Workerç±»æºç å‰–æ

### 4.1 é—®é¢˜4ï¼šWorkerä¸ºä»€ä¹ˆç»§æ‰¿AQSï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable {
    
    final Thread thread;
    Runnable firstTask;
    volatile long completedTasks;
    
    Worker(Runnable firstTask) {
        setState(-1);  // ç¦æ­¢ä¸­æ–­ï¼Œç›´åˆ°runWorker
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
    
    // å®ç°ç®€å•çš„ä¸å¯é‡å…¥é”
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }
    
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
    
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }
    
    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
    
    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

**ä¸ºä»€ä¹ˆç»§æ‰¿AQSï¼Ÿ**

1. **å®ç°ä¸å¯é‡å…¥é”**ï¼šæ§åˆ¶ä»»åŠ¡æ‰§è¡Œçš„å¹¶å‘
2. **åŒºåˆ†ç©ºé—²å’Œæ‰§è¡Œä¸­**ï¼šshutdown()æ—¶åªä¸­æ–­ç©ºé—²Worker
3. **é¿å…ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡**ï¼šä¿æŠ¤ä»»åŠ¡æ‰§è¡Œ

**çŠ¶æ€å«ä¹‰**ï¼š
- `state = -1`ï¼šåˆå§‹çŠ¶æ€ï¼Œç¦æ­¢ä¸­æ–­
- `state = 0`ï¼šç©ºé—²çŠ¶æ€ï¼Œå¯ä»¥ä¸­æ–­
- `state = 1`ï¼šæ‰§è¡ŒçŠ¶æ€ï¼ŒæŒæœ‰é”

---

## 5. runWorker()æ–¹æ³•æºç å‰–æ

### 5.1 é—®é¢˜5ï¼šWorkerå¦‚ä½•å¾ªç¯æ‰§è¡Œä»»åŠ¡ï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();  // å…è®¸ä¸­æ–­ï¼ˆstateä»-1å˜ä¸º0ï¼‰
    boolean completedAbruptly = true;
    try {
        // æ ¸å¿ƒå¾ªç¯ï¼šæ‰§è¡ŒfirstTaskæˆ–ä»é˜Ÿåˆ—è·å–ä»»åŠ¡
        while (task != null || (task = getTask()) != null) {
            w.lock();  // è·å–é”ï¼Œé˜²æ­¢shutdownæ—¶ä¸­æ–­
            
            // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€ï¼Œå†³å®šæ˜¯å¦ä¸­æ–­
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            
            try {
                beforeExecute(wt, task);  // é’©å­æ–¹æ³•
                Throwable thrown = null;
                try {
                    task.run();  // æ‰§è¡Œä»»åŠ¡
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);  // é’©å­æ–¹æ³•
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();  // é‡Šæ”¾é”
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);  // Workeré€€å‡ºå¤„ç†
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **ä¸ºä»€ä¹ˆè¦lock/unlockï¼Ÿ**
   - é˜²æ­¢shutdown()æ—¶ä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
   - åªä¸­æ–­ç©ºé—²çš„Worker

2. **é’©å­æ–¹æ³•çš„ä½œç”¨**ï¼š
   - `beforeExecute()`ï¼šä»»åŠ¡æ‰§è¡Œå‰çš„å¤„ç†
   - `afterExecute()`ï¼šä»»åŠ¡æ‰§è¡Œåçš„å¤„ç†
   - å¯ä»¥ç”¨äºç»Ÿè®¡ã€æ—¥å¿—ã€ç›‘æ§

---

## 6. getTask()æ–¹æ³•æºç å‰–æ

### 6.1 é—®é¢˜6ï¼šWorkerå¦‚ä½•ä»é˜Ÿåˆ—è·å–ä»»åŠ¡ï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
private Runnable getTask() {
    boolean timedOut = false;
    
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;  // è¿”å›nullï¼ŒWorkeré€€å‡º
        }
        
        int wc = workerCountOf(c);
        
        // åˆ¤æ–­æ˜¯å¦éœ€è¦è¶…æ—¶æ§åˆ¶
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;
        
        // åˆ¤æ–­æ˜¯å¦åº”è¯¥é€€å‡º
        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        
        try {
            // æ ¸å¿ƒçº¿ç¨‹ï¼šé˜»å¡ç­‰å¾…
            // éæ ¸å¿ƒçº¿ç¨‹ï¼šè¶…æ—¶ç­‰å¾…
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **æ ¸å¿ƒçº¿ç¨‹ä¸ºä»€ä¹ˆä¸ä¼šé€€å‡ºï¼Ÿ**
   - `timed = false`ï¼Œä½¿ç”¨`take()`é˜»å¡ç­‰å¾…
   - é™¤éè®¾ç½®äº†`allowCoreThreadTimeOut`

2. **ä¸´æ—¶çº¿ç¨‹å¦‚ä½•å›æ”¶ï¼Ÿ**
   - `timed = true`ï¼Œä½¿ç”¨`poll(timeout)`è¶…æ—¶ç­‰å¾…
   - è¶…æ—¶åè¿”å›nullï¼ŒWorkeré€€å‡º

---

## 7. shutdown()æ–¹æ³•æºç å‰–æ

### 7.1 é—®é¢˜7ï¼šå¦‚ä½•ä¼˜é›…å…³é—­çº¿ç¨‹æ± ï¼Ÿ

**æºç åˆ†æ**ï¼š

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);  // è®¾ç½®çŠ¶æ€ä¸ºSHUTDOWN
        interruptIdleWorkers();     // ä¸­æ–­ç©ºé—²Worker
        onShutdown();               // é’©å­æ–¹æ³•
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

private void interruptIdleWorkers() {
    interruptIdleWorkers(false);
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {  // åªä¸­æ–­ç©ºé—²Worker
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

**å…³é”®ç‚¹**ï¼š

1. **ä¸ºä»€ä¹ˆç”¨tryLock()ï¼Ÿ**
   - åªä¸­æ–­ç©ºé—²çš„Workerï¼ˆèƒ½è·å–é”çš„ï¼‰
   - æ­£åœ¨æ‰§è¡Œä»»åŠ¡çš„WorkeræŒæœ‰é”ï¼Œä¸ä¼šè¢«ä¸­æ–­

2. **shutdown() vs shutdownNow()**ï¼š
   - `shutdown()`ï¼šç­‰å¾…é˜Ÿåˆ—ä»»åŠ¡æ‰§è¡Œå®Œ
   - `shutdownNow()`ï¼šæ¸…ç©ºé˜Ÿåˆ—ï¼Œä¸­æ–­æ‰€æœ‰Worker

---

## 8. æºç ä¸­çš„ç²¾å¦™è®¾è®¡

### 8.1 è®¾è®¡æ¨¡å¼

1. **æ¨¡æ¿æ–¹æ³•æ¨¡å¼**ï¼š
   - `beforeExecute()`ã€`afterExecute()`ã€`terminated()`

2. **ç­–ç•¥æ¨¡å¼**ï¼š
   - `RejectedExecutionHandler`

3. **å·¥å‚æ¨¡å¼**ï¼š
   - `ThreadFactory`

### 8.2 å¹¶å‘æ§åˆ¶

1. **CASæ“ä½œ**ï¼š
   - `ctl`çš„æ›´æ–°ä½¿ç”¨CASï¼Œæ— é”åŒ–

2. **ReentrantLock**ï¼š
   - ä¿æŠ¤`workers`é›†åˆçš„æ“ä½œ

3. **AQS**ï¼š
   - Workerå®ç°ç®€å•çš„ä¸å¯é‡å…¥é”

### 8.3 æ€§èƒ½ä¼˜åŒ–

1. **ä½è¿ç®—**ï¼š
   - ç”¨ä¸€ä¸ªæ•´æ•°è¡¨ç¤ºä¸¤ä¸ªå€¼

2. **å±€éƒ¨æ€§åŸç†**ï¼š
   - WorkeræŒæœ‰Threadï¼Œå‡å°‘æŸ¥æ‰¾

3. **åŒé‡æ£€æŸ¥**ï¼š
   - å‡å°‘é”ç«äº‰

---

## 9. æ ¸å¿ƒé—®é¢˜æ€»ç»“

### Q1: ctlä¸ºä»€ä¹ˆç”¨ä¸€ä¸ªAtomicIntegerï¼Ÿ
**A**: ä¿è¯çŠ¶æ€å’Œçº¿ç¨‹æ•°çš„åŸå­æ€§æ›´æ–°ï¼Œæé«˜æ€§èƒ½ã€‚

### Q2: Workerä¸ºä»€ä¹ˆç»§æ‰¿AQSï¼Ÿ
**A**: å®ç°ä¸å¯é‡å…¥é”ï¼ŒåŒºåˆ†ç©ºé—²å’Œæ‰§è¡Œä¸­çš„Workerã€‚

### Q3: ä¸ºä»€ä¹ˆéœ€è¦åŒé‡æ£€æŸ¥ï¼Ÿ
**A**: é˜²æ­¢çº¿ç¨‹æ± çŠ¶æ€åœ¨æ“ä½œè¿‡ç¨‹ä¸­æ”¹å˜ã€‚

### Q4: æ ¸å¿ƒçº¿ç¨‹ä¸ºä»€ä¹ˆä¸ä¼šé€€å‡ºï¼Ÿ
**A**: ä½¿ç”¨`take()`é˜»å¡ç­‰å¾…ï¼Œä¸ä¼šè¶…æ—¶ã€‚

### Q5: shutdown()å¦‚ä½•ä¿è¯ä¸ä¸­æ–­æ‰§è¡Œä¸­çš„ä»»åŠ¡ï¼Ÿ
**A**: ä½¿ç”¨`tryLock()`ï¼Œåªä¸­æ–­ç©ºé—²çš„Workerã€‚

---

## ä¸‹ä¸€ç« é¢„å‘Š

ä¸‹ä¸€ç« æˆ‘ä»¬å°†ï¼š

- **å®ç°ä¸€ä¸ªç®€æ˜“ç‰ˆçº¿ç¨‹æ± **
- **ç†è§£çº¿ç¨‹æ± çš„æ ¸å¿ƒé€»è¾‘**
- **æŒæ¡çº¿ç¨‹æ± çš„è®¾è®¡æ€æƒ³**

è®©æˆ‘ä»¬ç»§ç»­æ·±å…¥ï¼ğŸš€
