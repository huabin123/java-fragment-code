# ç¬¬å…­ç« ï¼šé”åœ¨çº¿ç¨‹æ± ä¸­çš„åº”ç”¨

## å¼•è¨€

çº¿ç¨‹æ± ä½œä¸ºä¸€ä¸ªé«˜å¹¶å‘ç»„ä»¶ï¼Œå†…éƒ¨ä½¿ç”¨äº†å¤šç§é”æœºåˆ¶æ¥ä¿è¯çº¿ç¨‹å®‰å…¨å’Œæ€§èƒ½ã€‚æœ¬ç« å°†æ·±å…¥åˆ†æçº¿ç¨‹æ± ä¸­é”çš„åº”ç”¨åœºæ™¯ã€è®¾è®¡æ€æƒ³å’Œå®ç°ç»†èŠ‚ã€‚

---

## 1. çº¿ç¨‹æ± ä¸­çš„é”æ¦‚è§ˆ

### 1.1 çº¿ç¨‹æ± ä½¿ç”¨çš„é”ç±»å‹

ThreadPoolExecutorä¸­ä¸»è¦ä½¿ç”¨äº†ä»¥ä¸‹å‡ ç§é”æœºåˆ¶ï¼š

| é”ç±»å‹ | ä½¿ç”¨ä½ç½® | ä½œç”¨ | ç²’åº¦ |
|--------|----------|------|------|
| **ReentrantLock (mainLock)** | workersé›†åˆæ“ä½œ | ä¿æŠ¤çº¿ç¨‹æ± æ ¸å¿ƒçŠ¶æ€ | ç²—ç²’åº¦ |
| **Workerçš„AQSé”** | ä»»åŠ¡æ‰§è¡Œ | åŒºåˆ†ç©ºé—²/æ‰§è¡Œä¸­çš„Worker | ç»†ç²’åº¦ |
| **CAS (ctl)** | çº¿ç¨‹æ•°å’ŒçŠ¶æ€æ›´æ–° | æ— é”åŒ–æ›´æ–° | æ— é” |
| **é˜»å¡é˜Ÿåˆ—çš„é”** | ä»»åŠ¡å…¥é˜Ÿ/å‡ºé˜Ÿ | ä¿æŠ¤é˜Ÿåˆ—æ“ä½œ | é˜Ÿåˆ—çº§åˆ« |

---

## 2. ReentrantLock (mainLock) çš„åº”ç”¨

### 2.1 mainLockçš„å®šä¹‰

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    /**
     * ä¸»é”ï¼Œç”¨äºä¿æŠ¤å¯¹workersé›†åˆçš„è®¿é—®
     * ä»¥åŠç›¸å…³çš„ç°¿è®°æ“ä½œï¼ˆå¦‚largestPoolSizeã€completedTaskCountç­‰ï¼‰
     */
    private final ReentrantLock mainLock = new ReentrantLock();
    
    /**
     * åŒ…å«çº¿ç¨‹æ± ä¸­æ‰€æœ‰Workerçš„é›†åˆ
     * åªæœ‰åœ¨æŒæœ‰mainLockæ—¶æ‰èƒ½è®¿é—®
     */
    private final HashSet<Worker> workers = new HashSet<Worker>();
    
    /**
     * ç­‰å¾…æ¡ä»¶ï¼Œç”¨äºæ”¯æŒawaitTermination
     */
    private final Condition termination = mainLock.newCondition();
}
```

---

### 2.2 mainLockçš„ä½¿ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šæ·»åŠ Worker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    // ... å‰é¢çš„CASæ“ä½œå¢åŠ çº¿ç¨‹æ•° ...
    
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();  // ğŸ”’ è·å–mainLock
            try {
                // å†æ¬¡æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€ï¼ˆåŒé‡æ£€æŸ¥ï¼‰
                int rs = runStateOf(ctl.get());
                
                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive())  // çº¿ç¨‹ä¸åº”è¯¥å·²ç»å¯åŠ¨
                        throw new IllegalThreadStateException();
                    workers.add(w);  // âœ… æ·»åŠ åˆ°workersé›†åˆ
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;  // âœ… æ›´æ–°æœ€å¤§çº¿ç¨‹æ•°
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();  // ğŸ”“ é‡Šæ”¾mainLock
            }
            if (workerAdded) {
                t.start();  // å¯åŠ¨Workerçº¿ç¨‹
                workerStarted = true;
            }
        }
    } finally {
        if (!workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

**ä¸ºä»€ä¹ˆéœ€è¦mainLockï¼Ÿ**

1. **workersæ˜¯HashSet**ï¼šéçº¿ç¨‹å®‰å…¨ï¼Œéœ€è¦å¤–éƒ¨åŒæ­¥
2. **ä¿æŠ¤å¤šä¸ªçŠ¶æ€**ï¼šåŒæ—¶æ›´æ–°workerså’ŒlargestPoolSize
3. **åŒé‡æ£€æŸ¥**ï¼šåœ¨é”å†…å†æ¬¡æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€

---

#### åœºæ™¯2ï¼šä¸­æ–­ç©ºé—²Worker

```java
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();  // ğŸ”’ è·å–mainLock
    try {
        for (Worker w : workers) {  // âœ… éå†workersé›†åˆ
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {  // å°è¯•è·å–Workeré”
                try {
                    t.interrupt();  // ä¸­æ–­ç©ºé—²Worker
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();  // ğŸ”“ é‡Šæ”¾mainLock
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦mainLockï¼Ÿ**

1. **å®‰å…¨éå†workers**ï¼šé˜²æ­¢éå†è¿‡ç¨‹ä¸­é›†åˆè¢«ä¿®æ”¹
2. **ä¸€è‡´æ€§è§†å›¾**ï¼šç¡®ä¿çœ‹åˆ°workersçš„ä¸€è‡´çŠ¶æ€

---

#### åœºæ™¯3ï¼šè·å–çº¿ç¨‹æ± çŠ¶æ€

```java
public int getPoolSize() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();  // ğŸ”’ è·å–mainLock
    try {
        // å¦‚æœçº¿ç¨‹æ± è‡³å°‘æ˜¯TIDYINGçŠ¶æ€ï¼Œè¿”å›0
        // å¦åˆ™è¿”å›workers.size()
        return runStateAtLeast(ctl.get(), TIDYING) ? 0 : workers.size();
    } finally {
        mainLock.unlock();  // ğŸ”“ é‡Šæ”¾mainLock
    }
}

public int getActiveCount() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();  // ğŸ”’ è·å–mainLock
    try {
        int n = 0;
        for (Worker w : workers)
            if (w.isLocked())  // æ£€æŸ¥Workeræ˜¯å¦æŒæœ‰é”ï¼ˆæ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼‰
                ++n;
        return n;
    } finally {
        mainLock.unlock();  // ğŸ”“ é‡Šæ”¾mainLock
    }
}
```

---

#### åœºæ™¯4ï¼šç­‰å¾…çº¿ç¨‹æ± ç»ˆæ­¢

```java
public boolean awaitTermination(long timeout, TimeUnit unit)
    throws InterruptedException {
    long nanos = unit.toNanos(timeout);
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();  // ğŸ”’ è·å–mainLock
    try {
        for (;;) {
            if (runStateAtLeast(ctl.get(), TERMINATED))
                return true;
            if (nanos <= 0)
                return false;
            nanos = termination.awaitNanos(nanos);  // âœ… ä½¿ç”¨Conditionç­‰å¾…
        }
    } finally {
        mainLock.unlock();  // ğŸ”“ é‡Šæ”¾mainLock
    }
}

// åœ¨tryTerminate()ä¸­å”¤é†’ç­‰å¾…çš„çº¿ç¨‹
final void tryTerminate() {
    // ...
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        if (ctl.compareAndSet(c, ctlOf(TERMINATED, 0))) {
            try {
                terminated();  // é’©å­æ–¹æ³•
            } finally {
                termination.signalAll();  // âœ… å”¤é†’æ‰€æœ‰ç­‰å¾…çš„çº¿ç¨‹
            }
            return;
        }
    } finally {
        mainLock.unlock();
    }
}
```

---

### 2.3 mainLockçš„è®¾è®¡æ€æƒ³

#### ä¸ºä»€ä¹ˆé€‰æ‹©ReentrantLockè€Œä¸æ˜¯synchronizedï¼Ÿ

| ç‰¹æ€§ | ReentrantLock | synchronized |
|------|---------------|--------------|
| **Conditionæ”¯æŒ** | âœ… æ”¯æŒå¤šä¸ªCondition | âŒ åªæœ‰ä¸€ä¸ªwait/notify |
| **å¯ä¸­æ–­** | âœ… lockInterruptibly() | âŒ ä¸å¯ä¸­æ–­ |
| **å°è¯•è·å–** | âœ… tryLock() | âŒ ä¸æ”¯æŒ |
| **å…¬å¹³æ€§** | âœ… å¯é€‰å…¬å¹³/éå…¬å¹³ | âŒ éå…¬å¹³ |
| **æ€§èƒ½** | é«˜å¹¶å‘ä¸‹æ›´å¥½ | JDK6åä¼˜åŒ–ï¼Œå·®è·ä¸å¤§ |

**çº¿ç¨‹æ± é€‰æ‹©ReentrantLockçš„åŸå› **ï¼š

1. **éœ€è¦Condition**ï¼š`awaitTermination()` éœ€è¦ç­‰å¾…çº¿ç¨‹æ± ç»ˆæ­¢
2. **æ›´çµæ´»çš„æ§åˆ¶**ï¼šå¯ä»¥é€‰æ‹©å…¬å¹³/éå…¬å¹³é”
3. **æ›´å¥½çš„å¯è¯»æ€§**ï¼šæ˜¾å¼çš„lock/unlock

---

## 3. Workerçš„AQSé”

### 3.1 Workerä¸ºä»€ä¹ˆè¦å®ç°é”ï¼Ÿ

Workerç»§æ‰¿äº†AbstractQueuedSynchronizerï¼ˆAQSï¼‰ï¼Œå®ç°äº†ä¸€ä¸ª**ç®€å•çš„ä¸å¯é‡å…¥é”**ã€‚

```java
private final class Worker
    extends AbstractQueuedSynchronizer
    implements Runnable {
    
    final Thread thread;
    Runnable firstTask;
    volatile long completedTasks;
    
    Worker(Runnable firstTask) {
        setState(-1);  // ğŸ”’ åˆå§‹çŠ¶æ€ä¸º-1ï¼Œç¦æ­¢ä¸­æ–­
        this.firstTask = firstTask;
        this.thread = getThreadFactory().newThread(this);
    }
    
    public void run() {
        runWorker(this);
    }
    
    // ğŸ”’ å®ç°ç®€å•çš„ä¸å¯é‡å…¥é”
    protected boolean isHeldExclusively() {
        return getState() != 0;
    }
    
    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }
    
    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }
    
    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }
}
```

---

### 3.2 Workeré”çš„çŠ¶æ€å«ä¹‰

Workerçš„AQSçŠ¶æ€ï¼ˆstateï¼‰æœ‰ä¸‰ç§å€¼ï¼š

| stateå€¼ | å«ä¹‰ | åœºæ™¯ |
|---------|------|------|
| **-1** | åˆå§‹çŠ¶æ€ï¼Œç¦æ­¢ä¸­æ–­ | Workeråˆšåˆ›å»ºï¼Œè¿˜æœªæ‰§è¡Œä»»åŠ¡ |
| **0** | ç©ºé—²çŠ¶æ€ï¼ŒæœªæŒæœ‰é” | Workerç­‰å¾…ä»»åŠ¡æˆ–å·²å®Œæˆä»»åŠ¡ |
| **1** | æ‰§è¡ŒçŠ¶æ€ï¼ŒæŒæœ‰é” | Workeræ­£åœ¨æ‰§è¡Œä»»åŠ¡ |

**çŠ¶æ€è½¬æ¢å›¾**ï¼š

```
åˆ›å»ºWorker
    â†“
state = -1 (ç¦æ­¢ä¸­æ–­)
    â†“
runWorker()è°ƒç”¨unlock()
    â†“
state = 0 (å…è®¸ä¸­æ–­ï¼Œç©ºé—²)
    â†“
è·å–ä»»åŠ¡ï¼Œè°ƒç”¨lock()
    â†“
state = 1 (æ‰§è¡Œä¸­ï¼ŒæŒæœ‰é”)
    â†“
ä»»åŠ¡å®Œæˆï¼Œè°ƒç”¨unlock()
    â†“
state = 0 (ç©ºé—²)
    â†“
å¾ªç¯...
```

---

### 3.3 Workeré”çš„ä½¿ç”¨åœºæ™¯

#### åœºæ™¯1ï¼šåœ¨runWorker()ä¸­ä½¿ç”¨

```java
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock();  // ğŸ”“ å…è®¸ä¸­æ–­ï¼ˆstateä»-1å˜ä¸º0ï¼‰
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();  // ğŸ”’ è·å–é”ï¼Œè¡¨ç¤ºæ­£åœ¨æ‰§è¡Œä»»åŠ¡
            
            // æ£€æŸ¥çº¿ç¨‹æ± çŠ¶æ€
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();  // âœ… æ‰§è¡Œä»»åŠ¡ï¼ˆæŒæœ‰é”ï¼‰
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();  // ğŸ”“ é‡Šæ”¾é”ï¼Œè¡¨ç¤ºä»»åŠ¡å®Œæˆ
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

**ä¸ºä»€ä¹ˆè¦lock/unlockï¼Ÿ**

1. **æ ‡è®°WorkerçŠ¶æ€**ï¼šæŒæœ‰é”è¡¨ç¤ºæ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼ŒæœªæŒæœ‰é”è¡¨ç¤ºç©ºé—²
2. **é˜²æ­¢ä¸­æ–­**ï¼šshutdown()æ—¶åªä¸­æ–­ç©ºé—²çš„Worker
3. **ä¿æŠ¤ä»»åŠ¡æ‰§è¡Œ**ï¼šç¡®ä¿ä»»åŠ¡æ‰§è¡Œä¸è¢«æ„å¤–ä¸­æ–­

---

#### åœºæ™¯2ï¼šåœ¨shutdown()ä¸­ä½¿ç”¨

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        interruptIdleWorkers();  // âœ… åªä¸­æ–­ç©ºé—²Worker
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}

private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            // âœ… ä½¿ç”¨tryLock()åˆ¤æ–­Workeræ˜¯å¦ç©ºé—²
            if (!t.isInterrupted() && w.tryLock()) {
                try {
                    t.interrupt();  // ä¸­æ–­ç©ºé—²Worker
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨tryLock()ï¼Ÿ**

1. **éé˜»å¡åˆ¤æ–­**ï¼šä¸é˜»å¡ï¼Œç«‹å³è¿”å›
2. **åŒºåˆ†ç©ºé—²å’Œæ‰§è¡Œä¸­**ï¼š
   - ç©ºé—²Workerï¼ˆstate=0ï¼‰ï¼štryLock()æˆåŠŸï¼Œå¯ä»¥ä¸­æ–­
   - æ‰§è¡Œä¸­Workerï¼ˆstate=1ï¼‰ï¼štryLock()å¤±è´¥ï¼Œä¸ä¸­æ–­
3. **ä¿æŠ¤æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡**ï¼šä¸ä¼šä¸­æ–­æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡

---

### 3.4 ä¸ºä»€ä¹ˆæ˜¯ä¸å¯é‡å…¥é”ï¼Ÿ

Workerçš„é”æ˜¯**ä¸å¯é‡å…¥**çš„ï¼Œè¿™æ˜¯æœ‰æ„ä¸ºä¹‹ï¼š

```java
protected boolean tryAcquire(int unused) {
    // âŒ æ²¡æœ‰æ£€æŸ¥å½“å‰çº¿ç¨‹æ˜¯å¦å·²æŒæœ‰é”
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;  // å³ä½¿æ˜¯åŒä¸€ä¸ªçº¿ç¨‹ï¼Œä¹Ÿä¼šå¤±è´¥
}
```

**ä¸ºä»€ä¹ˆä¸å¯é‡å…¥ï¼Ÿ**

1. **ç®€åŒ–å®ç°**ï¼šä¸éœ€è¦ç»´æŠ¤é‡å…¥æ¬¡æ•°
2. **æ˜ç¡®è¯­ä¹‰**ï¼šWorkerè¦ä¹ˆç©ºé—²ï¼ˆ0ï¼‰ï¼Œè¦ä¹ˆæ‰§è¡Œä¸­ï¼ˆ1ï¼‰ï¼Œæ²¡æœ‰ä¸­é—´çŠ¶æ€
3. **é¿å…è¯¯ç”¨**ï¼šé˜²æ­¢åœ¨ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­é‡å¤åŠ é”

**å¯¹æ¯”ReentrantLock**ï¼š

```java
// ReentrantLockæ˜¯å¯é‡å…¥çš„
ReentrantLock lock = new ReentrantLock();
lock.lock();
lock.lock();  // âœ… å¯ä»¥é‡å…¥
lock.unlock();
lock.unlock();

// Workerçš„é”æ˜¯ä¸å¯é‡å…¥çš„
Worker w = new Worker(task);
w.lock();
w.lock();  // âŒ ä¼šé˜»å¡ï¼ˆæ­»é”ï¼‰
```

---

## 4. CASæ“ä½œï¼ˆæ— é”åŒ–ï¼‰

### 4.1 ctlçš„CASæ›´æ–°

çº¿ç¨‹æ± ä½¿ç”¨AtomicIntegerçš„CASæ“ä½œæ¥æ›´æ–°ctlï¼Œå®ç°æ— é”åŒ–ï¼š

```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// CASå¢åŠ Workeræ•°é‡
private boolean compareAndIncrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect + 1);
}

// CASå‡å°‘Workeræ•°é‡
private boolean compareAndDecrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect - 1);
}

// ä½¿ç”¨CASçš„ç¤ºä¾‹
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);
        
        // ... çŠ¶æ€æ£€æŸ¥ ...
        
        for (;;) {
            int wc = workerCountOf(c);
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            // âœ… CASå¢åŠ çº¿ç¨‹æ•°
            if (compareAndIncrementWorkerCount(c))
                break retry;  // æˆåŠŸï¼Œè·³å‡ºå¤–å±‚å¾ªç¯
            c = ctl.get();
            if (runStateOf(c) != rs)
                continue retry;  // çŠ¶æ€æ”¹å˜ï¼Œé‡è¯•
        }
    }
    // ... åˆ›å»ºWorker ...
}
```

---

### 4.2 CAS vs é”

| ç‰¹æ€§ | CAS | é” |
|------|-----|-----|
| **æ€§èƒ½** | é«˜ï¼ˆæ— é˜»å¡ï¼‰ | ä½ï¼ˆå¯èƒ½é˜»å¡ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | ç®€å•çš„åŸå­æ“ä½œ | å¤æ‚çš„ä¸´ç•ŒåŒº |
| **å¤±è´¥å¤„ç†** | è‡ªæ—‹é‡è¯• | é˜»å¡ç­‰å¾… |
| **å…¬å¹³æ€§** | ä¸ä¿è¯ | å¯é€‰å…¬å¹³/éå…¬å¹³ |

**çº¿ç¨‹æ± ä¸ºä»€ä¹ˆå¯¹ctlä½¿ç”¨CASï¼Ÿ**

1. **é«˜é¢‘æ“ä½œ**ï¼šçº¿ç¨‹æ•°çš„å¢å‡éå¸¸é¢‘ç¹
2. **ç®€å•æ“ä½œ**ï¼šåªæ˜¯ä¸€ä¸ªæ•´æ•°çš„å¢å‡
3. **æ€§èƒ½ä¼˜å…ˆ**ï¼šé¿å…é”çš„å¼€é”€

---

## 5. é˜»å¡é˜Ÿåˆ—çš„é”

### 5.1 é˜»å¡é˜Ÿåˆ—çš„å†…éƒ¨é”

çº¿ç¨‹æ± ä½¿ç”¨çš„é˜»å¡é˜Ÿåˆ—ï¼ˆå¦‚LinkedBlockingQueueï¼‰å†…éƒ¨ä¹Ÿä½¿ç”¨äº†é”ï¼š

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
    
    /** ä¿æŠ¤å…¥é˜Ÿæ“ä½œçš„é” */
    private final ReentrantLock putLock = new ReentrantLock();
    
    /** ç­‰å¾…å…¥é˜Ÿçš„æ¡ä»¶ */
    private final Condition notFull = putLock.newCondition();
    
    /** ä¿æŠ¤å‡ºé˜Ÿæ“ä½œçš„é” */
    private final ReentrantLock takeLock = new ReentrantLock();
    
    /** ç­‰å¾…å‡ºé˜Ÿçš„æ¡ä»¶ */
    private final Condition notEmpty = takeLock.newCondition();
    
    public void put(E e) throws InterruptedException {
        // ...
        final ReentrantLock putLock = this.putLock;
        putLock.lockInterruptibly();  // ğŸ”’ è·å–putLock
        try {
            while (count.get() == capacity) {
                notFull.await();  // é˜Ÿåˆ—æ»¡ï¼Œç­‰å¾…
            }
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 < capacity)
                notFull.signal();
        } finally {
            putLock.unlock();  // ğŸ”“ é‡Šæ”¾putLock
        }
        if (c == 0)
            signalNotEmpty();
    }
    
    public E take() throws InterruptedException {
        // ...
        final ReentrantLock takeLock = this.takeLock;
        takeLock.lockInterruptibly();  // ğŸ”’ è·å–takeLock
        try {
            while (count.get() == 0) {
                notEmpty.await();  // é˜Ÿåˆ—ç©ºï¼Œç­‰å¾…
            }
            x = dequeue();
            c = count.getAndDecrement();
            if (c > 1)
                notEmpty.signal();
        } finally {
            takeLock.unlock();  // ğŸ”“ é‡Šæ”¾takeLock
        }
        if (c == capacity)
            signalNotFull();
        return x;
    }
}
```

**è¯»å†™åˆ†ç¦»çš„é”è®¾è®¡**ï¼š

1. **putLock**ï¼šä¿æŠ¤å…¥é˜Ÿæ“ä½œ
2. **takeLock**ï¼šä¿æŠ¤å‡ºé˜Ÿæ“ä½œ
3. **å¥½å¤„**ï¼šå…¥é˜Ÿå’Œå‡ºé˜Ÿå¯ä»¥å¹¶å‘è¿›è¡Œï¼Œæé«˜ååé‡

---

### 5.2 çº¿ç¨‹æ± å¦‚ä½•ä½¿ç”¨é˜»å¡é˜Ÿåˆ—

```java
// execute()ä¸­ï¼šä»»åŠ¡å…¥é˜Ÿ
if (isRunning(c) && workQueue.offer(command)) {
    // offer()æ˜¯éé˜»å¡çš„ï¼Œé˜Ÿåˆ—æ»¡æ—¶è¿”å›false
}

// getTask()ä¸­ï¼šä»»åŠ¡å‡ºé˜Ÿ
Runnable r = timed ?
    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :  // è¶…æ—¶ç­‰å¾…
    workQueue.take();  // é˜»å¡ç­‰å¾…
```

**ä¸ºä»€ä¹ˆexecute()ç”¨offer()è€Œä¸æ˜¯put()ï¼Ÿ**

1. **éé˜»å¡**ï¼šoffer()ä¸ä¼šé˜»å¡ï¼Œé˜Ÿåˆ—æ»¡æ—¶ç«‹å³è¿”å›false
2. **å¿«é€Ÿå¤±è´¥**ï¼šå¯ä»¥ç«‹å³å°è¯•åˆ›å»ºä¸´æ—¶çº¿ç¨‹æˆ–æ‰§è¡Œæ‹’ç»ç­–ç•¥
3. **é¿å…æ­»é”**ï¼šä¸ä¼šå› ä¸ºé˜Ÿåˆ—æ»¡è€Œé˜»å¡æäº¤çº¿ç¨‹

---

## 6. é”çš„å±‚æ¬¡ç»“æ„

### 6.1 çº¿ç¨‹æ± ä¸­çš„é”å±‚æ¬¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ThreadPoolExecutor              â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  mainLock (ReentrantLock)       â”‚   â”‚  ç²—ç²’åº¦é”
â”‚  â”‚  - ä¿æŠ¤workersé›†åˆ              â”‚   â”‚  ä¿æŠ¤æ ¸å¿ƒçŠ¶æ€
â”‚  â”‚  - ä¿æŠ¤ç»Ÿè®¡ä¿¡æ¯                 â”‚   â”‚
â”‚  â”‚  - æ”¯æŒCondition (termination)  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  ctl (AtomicInteger + CAS)      â”‚   â”‚  æ— é”åŒ–
â”‚  â”‚  - çº¿ç¨‹æ± çŠ¶æ€                   â”‚   â”‚  é«˜æ€§èƒ½
â”‚  â”‚  - Workeræ•°é‡                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Worker (AQSé”)                 â”‚   â”‚  ç»†ç²’åº¦é”
â”‚  â”‚  - æ ‡è®°WorkerçŠ¶æ€               â”‚   â”‚  åŒºåˆ†ç©ºé—²/æ‰§è¡Œä¸­
â”‚  â”‚  - ä¿æŠ¤ä»»åŠ¡æ‰§è¡Œ                 â”‚   â”‚
â”‚  â”‚  - ä¸å¯é‡å…¥                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  BlockingQueue (å†…éƒ¨é”)         â”‚   â”‚  é˜Ÿåˆ—çº§åˆ«é”
â”‚  â”‚  - putLock (å…¥é˜Ÿ)               â”‚   â”‚  è¯»å†™åˆ†ç¦»
â”‚  â”‚  - takeLock (å‡ºé˜Ÿ)              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### 6.2 é”çš„è·å–é¡ºåº

**é¿å…æ­»é”çš„åŸåˆ™**ï¼šå§‹ç»ˆæŒ‰ç…§ç›¸åŒçš„é¡ºåºè·å–é”

```java
// âœ… æ­£ç¡®çš„é¡ºåºï¼šmainLock -> Workeré”
private void interruptIdleWorkers() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();  // 1ï¸âƒ£ å…ˆè·å–mainLock
    try {
        for (Worker w : workers) {
            if (w.tryLock()) {  // 2ï¸âƒ£ å†è·å–Workeré”
                try {
                    w.thread.interrupt();
                } finally {
                    w.unlock();
                }
            }
        }
    } finally {
        mainLock.unlock();
    }
}

// âŒ é”™è¯¯çš„é¡ºåºï¼šWorkeré” -> mainLockï¼ˆå¯èƒ½æ­»é”ï¼‰
// çº¿ç¨‹æ± çš„è®¾è®¡é¿å…äº†è¿™ç§æƒ…å†µ
```

---

## 7. é”çš„æ€§èƒ½ä¼˜åŒ–

### 7.1 å‡å°‘é”çš„æŒæœ‰æ—¶é—´

```java
// âœ… å¥½çš„åšæ³•ï¼šé”å¤–åˆ›å»ºWorkerï¼Œé”å†…åªåšå¿…è¦æ“ä½œ
private boolean addWorker(Runnable firstTask, boolean core) {
    // ... CASå¢åŠ çº¿ç¨‹æ•° ...
    
    Worker w = null;
    try {
        w = new Worker(firstTask);  // ğŸš€ é”å¤–åˆ›å»ºWorker
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();  // ğŸ”’ è·å–é”
            try {
                workers.add(w);  // âœ… é”å†…åªåšæ·»åŠ æ“ä½œ
                // ...
            } finally {
                mainLock.unlock();  // ğŸ”“ å°½å¿«é‡Šæ”¾é”
            }
            t.start();  // ğŸš€ é”å¤–å¯åŠ¨çº¿ç¨‹
        }
    } finally {
        // ...
    }
    return workerStarted;
}
```

---

### 7.2 ä½¿ç”¨tryLock()é¿å…é˜»å¡

```java
// âœ… ä½¿ç”¨tryLock()ï¼Œé¿å…é˜»å¡
private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() && w.tryLock()) {  // âœ… éé˜»å¡
                try {
                    t.interrupt();
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
```

---

### 7.3 ä½¿ç”¨CASä»£æ›¿é”

```java
// âœ… å¯¹ctlä½¿ç”¨CASï¼Œé¿å…é”çš„å¼€é”€
private boolean compareAndIncrementWorkerCount(int expect) {
    return ctl.compareAndSet(expect, expect + 1);
}

// âŒ å¦‚æœä½¿ç”¨é”ï¼ˆæ€§èƒ½è¾ƒå·®ï¼‰
private synchronized boolean incrementWorkerCount() {
    if (workerCountOf(ctl.get()) < CAPACITY) {
        ctl.set(ctl.get() + 1);
        return true;
    }
    return false;
}
```

---

## 8. å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆWorkerè¦å®ç°è‡ªå·±çš„é”ï¼Œè€Œä¸æ˜¯ç”¨ReentrantLockï¼Ÿ

**A**: 
1. **è½»é‡çº§**ï¼šWorkeråªéœ€è¦ç®€å•çš„ä¸å¯é‡å…¥é”ï¼ŒAQSå®ç°æ›´è½»é‡
2. **è¯­ä¹‰æ˜ç¡®**ï¼šstateåªæœ‰3ä¸ªå€¼ï¼ˆ-1, 0, 1ï¼‰ï¼Œè¯­ä¹‰æ¸…æ™°
3. **æ€§èƒ½æ›´å¥½**ï¼šé¿å…ReentrantLockçš„é¢å¤–å¼€é”€

---

### Q2: mainLockå’ŒWorkeré”æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ

**A**:

| ç‰¹æ€§ | mainLock | Workeré” |
|------|----------|----------|
| **ç±»å‹** | ReentrantLock | AQSè‡ªå®šä¹‰é” |
| **å¯é‡å…¥** | âœ… å¯é‡å…¥ | âŒ ä¸å¯é‡å…¥ |
| **ä¿æŠ¤å¯¹è±¡** | workersé›†åˆ | å•ä¸ªWorker |
| **ç²’åº¦** | ç²—ç²’åº¦ | ç»†ç²’åº¦ |
| **ç”¨é€”** | ä¿æŠ¤æ ¸å¿ƒçŠ¶æ€ | åŒºåˆ†ç©ºé—²/æ‰§è¡Œä¸­ |

---

### Q3: ä¸ºä»€ä¹ˆä¸ç”¨synchronizedï¼Ÿ

**A**:
1. **éœ€è¦Condition**ï¼šawaitTermination()éœ€è¦ç­‰å¾…æ¡ä»¶
2. **éœ€è¦tryLock()**ï¼šinterruptIdleWorkers()éœ€è¦éé˜»å¡åˆ¤æ–­
3. **æ›´çµæ´»**ï¼šå¯ä»¥é€‰æ‹©å…¬å¹³/éå…¬å¹³é”
4. **æ›´å¥½çš„å¯è¯»æ€§**ï¼šæ˜¾å¼çš„lock/unlock

---

### Q4: å¦‚ä½•é¿å…æ­»é”ï¼Ÿ

**A**:
1. **å›ºå®šçš„é”é¡ºåº**ï¼šå§‹ç»ˆå…ˆè·å–mainLockï¼Œå†è·å–Workeré”
2. **ä½¿ç”¨tryLock()**ï¼šé¿å…é˜»å¡ç­‰å¾…
3. **å‡å°‘é”çš„æŒæœ‰æ—¶é—´**ï¼šå°½å¿«é‡Šæ”¾é”
4. **é¿å…åµŒå¥—é”**ï¼šå°½é‡ä¸åœ¨æŒæœ‰ä¸€ä¸ªé”æ—¶è·å–å¦ä¸€ä¸ªé”

---

## 9. æ€»ç»“

### 9.1 çº¿ç¨‹æ± ä¸­çš„é”è®¾è®¡åŸåˆ™

1. **åˆ†å±‚è®¾è®¡**ï¼šä¸åŒå±‚æ¬¡ä½¿ç”¨ä¸åŒçš„é”æœºåˆ¶
2. **ç²—ç»†ç»“åˆ**ï¼šç²—ç²’åº¦é”ï¼ˆmainLockï¼‰+ ç»†ç²’åº¦é”ï¼ˆWorkeré”ï¼‰
3. **æ— é”ä¼˜åŒ–**ï¼šå¯¹é«˜é¢‘æ“ä½œï¼ˆctlï¼‰ä½¿ç”¨CAS
4. **è¯»å†™åˆ†ç¦»**ï¼šé˜»å¡é˜Ÿåˆ—ä½¿ç”¨è¯»å†™é”

---

### 9.2 æ ¸å¿ƒè¦ç‚¹

| é”ç±»å‹ | ä½œç”¨ | è®¾è®¡äº®ç‚¹ |
|--------|------|----------|
| **mainLock** | ä¿æŠ¤workersé›†åˆ | æ”¯æŒConditionï¼Œä¿æŠ¤æ ¸å¿ƒçŠ¶æ€ |
| **Workeré”** | åŒºåˆ†ç©ºé—²/æ‰§è¡Œä¸­ | ä¸å¯é‡å…¥ï¼Œè¯­ä¹‰æ˜ç¡® |
| **CAS** | æ›´æ–°ctl | æ— é”åŒ–ï¼Œé«˜æ€§èƒ½ |
| **é˜Ÿåˆ—é”** | ä¿æŠ¤é˜Ÿåˆ—æ“ä½œ | è¯»å†™åˆ†ç¦»ï¼Œæé«˜ååé‡ |

---

### 9.3 å­¦ä¹ å»ºè®®

1. **ç†è§£é”çš„ä½œç”¨**ï¼šæ¯ä¸ªé”ä¿æŠ¤ä»€ä¹ˆï¼Œä¸ºä»€ä¹ˆéœ€è¦
2. **åˆ†æé”çš„ç²’åº¦**ï¼šç²—ç²’åº¦ vs ç»†ç²’åº¦
3. **å…³æ³¨æ€§èƒ½ä¼˜åŒ–**ï¼šCASã€tryLockã€å‡å°‘æŒæœ‰æ—¶é—´
4. **é¿å…æ­»é”**ï¼šå›ºå®šçš„é”é¡ºåºï¼Œä½¿ç”¨tryLock

---

## 10. å®æˆ˜ç»ƒä¹ 

### ç»ƒä¹ 1ï¼šåˆ†æé”çš„ä½¿ç”¨

é˜…è¯»ä»¥ä¸‹ä»£ç ï¼Œåˆ†æä½¿ç”¨äº†å“ªäº›é”ï¼Œä¸ºä»€ä¹ˆï¼Ÿ

```java
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        advanceRunState(SHUTDOWN);
        interruptIdleWorkers();
        onShutdown();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
```

### ç»ƒä¹ 2ï¼šå®ç°ä¸€ä¸ªç®€å•çš„Workeré”

å°è¯•å®ç°ä¸€ä¸ªç®€å•çš„ä¸å¯é‡å…¥é”ï¼Œç†è§£Workeré”çš„è®¾è®¡ã€‚

---

## ä¸‹ä¸€ç« é¢„å‘Š

ä¸‹ä¸€ç« æˆ‘ä»¬å°†ï¼š
- **åˆ†æçº¿ç¨‹æ± çš„ç›‘æ§å’Œè°ƒä¼˜**
- **å­¦ä¹ å¦‚ä½•æ’æŸ¥çº¿ç¨‹æ± é—®é¢˜**
- **æŒæ¡çº¿ç¨‹æ± çš„æœ€ä½³å®è·µ**

è®©æˆ‘ä»¬ç»§ç»­æ·±å…¥ï¼ğŸš€
