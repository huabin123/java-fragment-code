# ç¬¬äº”ç« ï¼šå®ç°ç®€æ˜“ç‰ˆçº¿ç¨‹æ± 

## å¼•è¨€

é€šè¿‡å‰é¢ç« èŠ‚çš„å­¦ä¹ ï¼Œæˆ‘ä»¬å·²ç»ç†è§£äº†çº¿ç¨‹æ± çš„åŸç†å’Œæºç ã€‚æœ¬ç« å°†åŠ¨æ‰‹å®ç°ä¸€ä¸ªç®€æ˜“ç‰ˆçº¿ç¨‹æ± ï¼ŒåŠ æ·±ç†è§£ã€‚

---

## 1. è®¾è®¡ç›®æ ‡

### 1.1 é—®é¢˜1ï¼šæˆ‘ä»¬è¦å®ç°å“ªäº›åŠŸèƒ½ï¼Ÿ

**æ ¸å¿ƒåŠŸèƒ½**ï¼š

1. âœ… å›ºå®šæ•°é‡çš„å·¥ä½œçº¿ç¨‹
2. âœ… ä»»åŠ¡é˜Ÿåˆ—ï¼ˆé˜»å¡é˜Ÿåˆ—ï¼‰
3. âœ… ä»»åŠ¡æäº¤ï¼ˆexecuteæ–¹æ³•ï¼‰
4. âœ… ä¼˜é›…å…³é—­ï¼ˆshutdownæ–¹æ³•ï¼‰
5. âœ… æ‹’ç»ç­–ç•¥

**ç®€åŒ–è®¾è®¡**ï¼š

- âŒ ä¸å®ç°æ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°çš„åŒºåˆ†
- âŒ ä¸å®ç°çº¿ç¨‹è¶…æ—¶å›æ”¶
- âŒ ä¸å®ç°å¤æ‚çš„çŠ¶æ€ç®¡ç†
- âŒ ä¸å®ç°submitå’ŒFuture

---

## 2. å®ç°æ­¥éª¤

### 2.1 æ­¥éª¤1ï¼šå®šä¹‰Workerçº¿ç¨‹

**Workerçš„èŒè´£**ï¼š

```
Workerçº¿ç¨‹
    â†“
while (true) {
    ä»é˜Ÿåˆ—è·å–ä»»åŠ¡
    â†“
    æ‰§è¡Œä»»åŠ¡
    â†“
    ç»§ç»­å¾ªç¯
}
```

**ä»£ç å®ç°**ï¼š

```java
/**
 * å·¥ä½œçº¿ç¨‹
 */
private class Worker implements Runnable {
    
    @Override
    public void run() {
        // å¾ªç¯ä»é˜Ÿåˆ—è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ
        while (!isShutdown || !taskQueue.isEmpty()) {
            try {
                // ä»é˜Ÿåˆ—è·å–ä»»åŠ¡ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
                Runnable task = taskQueue.take();
                
                // æ‰§è¡Œä»»åŠ¡
                try {
                    task.run();
                } catch (Exception e) {
                    // æ•è·ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸ï¼Œé˜²æ­¢Workerçº¿ç¨‹é€€å‡º
                    System.err.println("ä»»åŠ¡æ‰§è¡Œå¤±è´¥: " + e.getMessage());
                    e.printStackTrace();
                }
                
            } catch (InterruptedException e) {
                // çº¿ç¨‹è¢«ä¸­æ–­ï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡º
                if (isShutdown) {
                    break;
                }
            }
        }
        
        System.out.println("Workerçº¿ç¨‹é€€å‡º: " + Thread.currentThread().getName());
    }
}
```

---

### 2.2 æ­¥éª¤2ï¼šå®šä¹‰æ‹’ç»ç­–ç•¥

```java
/**
 * æ‹’ç»ç­–ç•¥æ¥å£
 */
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable task, SimpleThreadPool executor);
}

/**
 * æŠ›å‡ºå¼‚å¸¸ç­–ç•¥
 */
public static class AbortPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
        throw new RuntimeException("ä»»åŠ¡è¢«æ‹’ç»: " + task);
    }
}

/**
 * è°ƒç”¨è€…æ‰§è¡Œç­–ç•¥
 */
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
        if (!executor.isShutdown()) {
            task.run();
        }
    }
}

/**
 * ä¸¢å¼ƒç­–ç•¥
 */
public static class DiscardPolicy implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
        // ä»€ä¹ˆéƒ½ä¸åš
    }
}
```

---

### 2.3 æ­¥éª¤3ï¼šå®ç°çº¿ç¨‹æ± ä¸»ä½“

**å®Œæ•´ä»£ç **ï¼š

```java
package com.fragment.core.threadpool.simple;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * ç®€æ˜“ç‰ˆçº¿ç¨‹æ± 
 * 
 * @author fragment
 */
public class SimpleThreadPool {
    
    // ä»»åŠ¡é˜Ÿåˆ—
    private final BlockingQueue<Runnable> taskQueue;
    
    // å·¥ä½œçº¿ç¨‹åˆ—è¡¨
    private final List<Thread> workers;
    
    // çº¿ç¨‹æ•°é‡
    private final int poolSize;
    
    // æ‹’ç»ç­–ç•¥
    private final RejectedExecutionHandler handler;
    
    // æ˜¯å¦å·²å…³é—­
    private volatile boolean isShutdown = false;
    
    // å·²å®Œæˆä»»åŠ¡æ•°
    private final AtomicInteger completedTaskCount = new AtomicInteger(0);
    
    /**
     * æ„é€ å‡½æ•°
     * 
     * @param poolSize çº¿ç¨‹æ•°é‡
     * @param queueCapacity é˜Ÿåˆ—å®¹é‡
     * @param handler æ‹’ç»ç­–ç•¥
     */
    public SimpleThreadPool(int poolSize, 
                           int queueCapacity, 
                           RejectedExecutionHandler handler) {
        if (poolSize <= 0) {
            throw new IllegalArgumentException("çº¿ç¨‹æ•°å¿…é¡»å¤§äº0");
        }
        if (queueCapacity <= 0) {
            throw new IllegalArgumentException("é˜Ÿåˆ—å®¹é‡å¿…é¡»å¤§äº0");
        }
        
        this.poolSize = poolSize;
        this.taskQueue = new LinkedBlockingQueue<>(queueCapacity);
        this.workers = new ArrayList<>(poolSize);
        this.handler = handler != null ? handler : new AbortPolicy();
        
        // åˆ›å»ºå¹¶å¯åŠ¨å·¥ä½œçº¿ç¨‹
        for (int i = 0; i < poolSize; i++) {
            Worker worker = new Worker();
            Thread thread = new Thread(worker, "SimpleThreadPool-Worker-" + i);
            thread.start();
            workers.add(thread);
        }
        
        System.out.println("çº¿ç¨‹æ± å·²åˆ›å»ºï¼Œçº¿ç¨‹æ•°: " + poolSize + 
                         ", é˜Ÿåˆ—å®¹é‡: " + queueCapacity);
    }
    
    /**
     * æäº¤ä»»åŠ¡
     * 
     * @param task ä»»åŠ¡
     */
    public void execute(Runnable task) {
        if (task == null) {
            throw new NullPointerException("ä»»åŠ¡ä¸èƒ½ä¸ºç©º");
        }
        
        if (isShutdown) {
            throw new RuntimeException("çº¿ç¨‹æ± å·²å…³é—­ï¼Œæ— æ³•æäº¤æ–°ä»»åŠ¡");
        }
        
        // å°è¯•å°†ä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
        boolean offered = taskQueue.offer(task);
        
        if (!offered) {
            // é˜Ÿåˆ—å·²æ»¡ï¼Œæ‰§è¡Œæ‹’ç»ç­–ç•¥
            handler.rejectedExecution(task, this);
        }
    }
    
    /**
     * å…³é—­çº¿ç¨‹æ± 
     */
    public void shutdown() {
        isShutdown = true;
        
        // ä¸­æ–­æ‰€æœ‰å·¥ä½œçº¿ç¨‹
        for (Thread worker : workers) {
            worker.interrupt();
        }
        
        System.out.println("çº¿ç¨‹æ± å·²å…³é—­");
    }
    
    /**
     * ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
     * 
     * @param timeoutMillis è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
     */
    public void awaitTermination(long timeoutMillis) throws InterruptedException {
        long startTime = System.currentTimeMillis();
        
        for (Thread worker : workers) {
            long elapsed = System.currentTimeMillis() - startTime;
            long remaining = timeoutMillis - elapsed;
            
            if (remaining <= 0) {
                break;
            }
            
            worker.join(remaining);
        }
    }
    
    /**
     * è·å–é˜Ÿåˆ—å¤§å°
     */
    public int getQueueSize() {
        return taskQueue.size();
    }
    
    /**
     * è·å–å·²å®Œæˆä»»åŠ¡æ•°
     */
    public int getCompletedTaskCount() {
        return completedTaskCount.get();
    }
    
    /**
     * æ˜¯å¦å·²å…³é—­
     */
    public boolean isShutdown() {
        return isShutdown;
    }
    
    /**
     * å·¥ä½œçº¿ç¨‹
     */
    private class Worker implements Runnable {
        
        @Override
        public void run() {
            System.out.println("Workerçº¿ç¨‹å¯åŠ¨: " + Thread.currentThread().getName());
            
            // å¾ªç¯ä»é˜Ÿåˆ—è·å–ä»»åŠ¡å¹¶æ‰§è¡Œ
            while (!isShutdown || !taskQueue.isEmpty()) {
                try {
                    // ä»é˜Ÿåˆ—è·å–ä»»åŠ¡ï¼ˆé˜»å¡ç­‰å¾…ï¼‰
                    Runnable task = taskQueue.take();
                    
                    // æ‰§è¡Œä»»åŠ¡
                    try {
                        task.run();
                        completedTaskCount.incrementAndGet();
                    } catch (Exception e) {
                        // æ•è·ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸ï¼Œé˜²æ­¢Workerçº¿ç¨‹é€€å‡º
                        System.err.println("ä»»åŠ¡æ‰§è¡Œå¤±è´¥: " + e.getMessage());
                        e.printStackTrace();
                    }
                    
                } catch (InterruptedException e) {
                    // çº¿ç¨‹è¢«ä¸­æ–­ï¼Œæ£€æŸ¥æ˜¯å¦åº”è¯¥é€€å‡º
                    if (isShutdown) {
                        break;
                    }
                }
            }
            
            System.out.println("Workerçº¿ç¨‹é€€å‡º: " + Thread.currentThread().getName());
        }
    }
    
    /**
     * æ‹’ç»ç­–ç•¥æ¥å£
     */
    public interface RejectedExecutionHandler {
        void rejectedExecution(Runnable task, SimpleThreadPool executor);
    }
    
    /**
     * æŠ›å‡ºå¼‚å¸¸ç­–ç•¥
     */
    public static class AbortPolicy implements RejectedExecutionHandler {
        @Override
        public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
            throw new RuntimeException("ä»»åŠ¡è¢«æ‹’ç»: " + task);
        }
    }
    
    /**
     * è°ƒç”¨è€…æ‰§è¡Œç­–ç•¥
     */
    public static class CallerRunsPolicy implements RejectedExecutionHandler {
        @Override
        public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
            if (!executor.isShutdown()) {
                System.out.println("é˜Ÿåˆ—å·²æ»¡ï¼Œè°ƒç”¨è€…æ‰§è¡Œä»»åŠ¡");
                task.run();
            }
        }
    }
    
    /**
     * ä¸¢å¼ƒç­–ç•¥
     */
    public static class DiscardPolicy implements RejectedExecutionHandler {
        @Override
        public void rejectedExecution(Runnable task, SimpleThreadPool executor) {
            System.out.println("é˜Ÿåˆ—å·²æ»¡ï¼Œä¸¢å¼ƒä»»åŠ¡: " + task);
        }
    }
}
```

---

## 3. æµ‹è¯•ä»£ç 

### 3.1 åŸºæœ¬åŠŸèƒ½æµ‹è¯•

```java
package com.fragment.core.threadpool.simple;

/**
 * ç®€æ˜“çº¿ç¨‹æ± æµ‹è¯•
 */
public class SimpleThreadPoolTest {
    
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºçº¿ç¨‹æ± ï¼š5ä¸ªçº¿ç¨‹ï¼Œé˜Ÿåˆ—å®¹é‡10
        SimpleThreadPool pool = new SimpleThreadPool(
            5, 
            10, 
            new SimpleThreadPool.CallerRunsPolicy()
        );
        
        // æäº¤20ä¸ªä»»åŠ¡
        for (int i = 0; i < 20; i++) {
            final int taskId = i;
            pool.execute(() -> {
                System.out.println("æ‰§è¡Œä»»åŠ¡ " + taskId + 
                                 ", çº¿ç¨‹: " + Thread.currentThread().getName());
                try {
                    Thread.sleep(1000);  // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("ä»»åŠ¡ " + taskId + " å®Œæˆ");
            });
            
            // æ‰“å°é˜Ÿåˆ—å¤§å°
            System.out.println("é˜Ÿåˆ—å¤§å°: " + pool.getQueueSize());
        }
        
        // å…³é—­çº¿ç¨‹æ± 
        pool.shutdown();
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        pool.awaitTermination(60000);
        
        System.out.println("å·²å®Œæˆä»»åŠ¡æ•°: " + pool.getCompletedTaskCount());
    }
}
```

---

## 4. ä¸JDKçº¿ç¨‹æ± çš„å¯¹æ¯”

### 4.1 åŠŸèƒ½å¯¹æ¯”

| åŠŸèƒ½ | SimpleThreadPool | ThreadPoolExecutor |
|------|------------------|-------------------|
| å›ºå®šçº¿ç¨‹æ•° | âœ… | âœ… |
| ä»»åŠ¡é˜Ÿåˆ— | âœ… | âœ… |
| æ‹’ç»ç­–ç•¥ | âœ… | âœ… |
| æ ¸å¿ƒ/æœ€å¤§çº¿ç¨‹æ•° | âŒ | âœ… |
| çº¿ç¨‹è¶…æ—¶å›æ”¶ | âŒ | âœ… |
| çŠ¶æ€ç®¡ç† | ç®€å• | å¤æ‚ï¼ˆ5ç§çŠ¶æ€ï¼‰ |
| submit/Future | âŒ | âœ… |
| é’©å­æ–¹æ³• | âŒ | âœ… |
| ç›‘æ§æŒ‡æ ‡ | ç®€å• | å®Œå–„ |

---

## 5. æ”¹è¿›æ–¹å‘

### 5.1 å¯ä»¥æ·»åŠ çš„åŠŸèƒ½

1. **æ”¯æŒæ ¸å¿ƒçº¿ç¨‹æ•°å’Œæœ€å¤§çº¿ç¨‹æ•°**
2. **æ”¯æŒçº¿ç¨‹è¶…æ—¶å›æ”¶**
3. **æ”¯æŒsubmitå’ŒFuture**
4. **å®Œå–„çš„çŠ¶æ€ç®¡ç†**
5. **æ›´å¤šçš„ç›‘æ§æŒ‡æ ‡**
6. **é’©å­æ–¹æ³•**
7. **çº¿ç¨‹å·¥å‚**

---

## 6. æ ¸å¿ƒæ”¶è·

é€šè¿‡å®ç°ç®€æ˜“ç‰ˆçº¿ç¨‹æ± ï¼Œæˆ‘ä»¬ç†è§£äº†ï¼š

1. **Workerçº¿ç¨‹çš„å¾ªç¯æœºåˆ¶**ï¼šä¸æ–­ä»é˜Ÿåˆ—è·å–ä»»åŠ¡
2. **é˜»å¡é˜Ÿåˆ—çš„ä½œç”¨**ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼
3. **æ‹’ç»ç­–ç•¥çš„å®ç°**ï¼šç­–ç•¥æ¨¡å¼
4. **ä¼˜é›…å…³é—­çš„å®ç°**ï¼šä¸­æ–­ + ç­‰å¾…

---

## æ€»ç»“

æœ¬ç« é€šè¿‡å®ç°ç®€æ˜“ç‰ˆçº¿ç¨‹æ± ï¼ŒåŠ æ·±äº†å¯¹çº¿ç¨‹æ± æ ¸å¿ƒæœºåˆ¶çš„ç†è§£ã€‚è™½ç„¶åŠŸèƒ½ç®€å•ï¼Œä½†æ ¸å¿ƒæ€æƒ³ä¸JDKçº¿ç¨‹æ± ä¸€è‡´ã€‚

**å…³é”®ç‚¹**ï¼š

1. âœ… Workerçº¿ç¨‹å¾ªç¯æ‰§è¡Œä»»åŠ¡
2. âœ… é˜»å¡é˜Ÿåˆ—å®ç°ç”Ÿäº§è€…-æ¶ˆè´¹è€…
3. âœ… æ‹’ç»ç­–ç•¥å¤„ç†é˜Ÿåˆ—æ»¡çš„æƒ…å†µ
4. âœ… ä¼˜é›…å…³é—­ä¿è¯ä»»åŠ¡å®Œæˆ

---

## ä¸‹ä¸€æ­¥

ç»§ç»­å­¦ä¹ ï¼š

- **ForkJoinPoolçš„å®ç°åŸç†**
- **CompletableFutureçš„ä½¿ç”¨**
- **è™šæ‹Ÿçº¿ç¨‹ï¼ˆJava 21+ï¼‰**

ğŸš€ çº¿ç¨‹æ± ç³»åˆ—å®Œç»“ï¼
