# 第四章：数组类型原子类 - 数组元素的原子操作

> **学习目标**：掌握AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray的使用

---

## 一、为什么需要数组类型原子类？

### 1.1 普通数组的线程安全问题

```java
// 问题：数组元素的更新不是原子的
public class Counter {
    private int[] counts = new int[10];
    
    public void increment(int index) {
        counts[index]++;  // 不是原子操作
    }
}

// 多线程问题：
// 线程A读取counts[0]=5
// 线程B读取counts[0]=5
// 线程A写入counts[0]=6
// 线程B写入counts[0]=6
// 结果：counts[0]=6（错误，应该是7）
```

### 1.2 synchronized的性能问题

```java
// 使用synchronized保证线程安全
public class Counter {
    private int[] counts = new int[10];
    
    public synchronized void increment(int index) {
        counts[index]++;
    }
}

// 问题：
// ❌ 锁粒度太大（整个对象）
// ❌ 不同索引也会竞争
// ❌ 性能差
```

### 1.3 原子数组的解决方案

```java
// 使用AtomicIntegerArray
public class Counter {
    private AtomicIntegerArray counts = new AtomicIntegerArray(10);
    
    public void increment(int index) {
        counts.incrementAndGet(index);  // 原子操作
    }
}

// 优势：
// ✅ 无锁，性能好
// ✅ 细粒度（每个元素独立）
// ✅ 线程安全
```

---

## 二、AtomicIntegerArray详解

### 2.1 核心方法

```java
public class AtomicIntegerArray implements java.io.Serializable {
    
    // 构造方法
    public AtomicIntegerArray(int length)
    public AtomicIntegerArray(int[] array)  // 复制数组
    
    // 获取和设置
    public final int get(int i)
    public final void set(int i, int newValue)
    public final void lazySet(int i, int newValue)
    
    // 自增自减
    public final int getAndIncrement(int i)
    public final int incrementAndGet(int i)
    public final int getAndDecrement(int i)
    public final int decrementAndGet(int i)
    
    // 加减操作
    public final int getAndAdd(int i, int delta)
    public final int addAndGet(int i, int delta)
    
    // CAS操作
    public final boolean compareAndSet(int i, int expect, int update)
    
    // 函数式操作
    public final int getAndUpdate(int i, IntUnaryOperator updateFunction)
    public final int updateAndGet(int i, IntUnaryOperator updateFunction)
    public final int getAndAccumulate(int i, int x, IntBinaryOperator accumulatorFunction)
    public final int accumulateAndGet(int i, int x, IntBinaryOperator accumulatorFunction)
    
    // 其他
    public final int length()
    public String toString()
}
```

### 2.2 实现原理

```java
public class AtomicIntegerArray implements java.io.Serializable {
    
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    
    // 数组首元素的偏移量
    private static final int base = unsafe.arrayBaseOffset(int[].class);
    
    // 数组元素的间隔（scale）
    private static final int shift;
    
    static {
        int scale = unsafe.arrayIndexScale(int[].class);
        if ((scale & (scale - 1)) != 0)
            throw new Error("data type scale not a power of two");
        shift = 31 - Integer.numberOfLeadingZeros(scale);
    }
    
    // 实际存储数据的数组
    private final int[] array;
    
    /**
     * 计算元素i的内存偏移量
     */
    private long checkedByteOffset(int i) {
        if (i < 0 || i >= array.length)
            throw new IndexOutOfBoundsException("index " + i);
        return byteOffset(i);
    }
    
    private static long byteOffset(int i) {
        return ((long) i << shift) + base;
    }
    
    /**
     * CAS操作
     */
    public final boolean compareAndSet(int i, int expect, int update) {
        return unsafe.compareAndSwapInt(array, checkedByteOffset(i), expect, update);
    }
    
    /**
     * 自增并获取
     */
    public final int incrementAndGet(int i) {
        return getAndAdd(i, 1) + 1;
    }
    
    public final int getAndAdd(int i, int delta) {
        return unsafe.getAndAddInt(array, checkedByteOffset(i), delta);
    }
}
```

**关键点**：

```
1. 内存布局：
   - base：数组首元素的偏移量
   - shift：元素间隔的位移量
   - 元素i的偏移 = base + (i << shift)

2. CAS操作：
   - 直接操作数组元素的内存地址
   - 每个元素独立的CAS

3. 性能：
   - 细粒度锁（每个元素独立）
   - 无锁算法
```

### 2.3 使用示例

```java
// 创建数组
AtomicIntegerArray array = new AtomicIntegerArray(10);

// 设置值
array.set(0, 100);

// 自增
int old = array.getAndIncrement(0);  // 返回100，array[0]变为101
int new = array.incrementAndGet(0);  // array[0]变为102，返回102

// CAS操作
boolean success = array.compareAndSet(0, 102, 200);  // true

// 函数式操作
array.updateAndGet(0, x -> x * 2);  // array[0]变为400
```

---

## 三、AtomicLongArray详解

### 3.1 与AtomicIntegerArray的区别

```java
public class AtomicLongArray implements java.io.Serializable {
    private final long[] array;  // 存储long类型
    
    public final boolean compareAndSet(int i, long expect, long update) {
        return unsafe.compareAndSwapLong(array, checkedByteOffset(i), expect, update);
    }
}
```

**区别**：

| 特性 | AtomicIntegerArray | AtomicLongArray |
|------|-------------------|-----------------|
| 元素类型 | int | long |
| 内存占用 | 4字节/元素 | 8字节/元素 |
| CAS指令 | compareAndSwapInt | compareAndSwapLong |

### 3.2 使用场景

```java
// ✅ 使用AtomicIntegerArray
// - 计数器数组
// - 统计数据（范围在int内）
AtomicIntegerArray counters = new AtomicIntegerArray(100);

// ✅ 使用AtomicLongArray
// - 大数值统计
// - 时间戳数组
// - ID生成器
AtomicLongArray timestamps = new AtomicLongArray(100);
```

---

## 四、AtomicReferenceArray详解

### 4.1 基本使用

```java
public class AtomicReferenceArray<E> implements java.io.Serializable {
    
    // 构造方法
    public AtomicReferenceArray(int length)
    public AtomicReferenceArray(E[] array)
    
    // 获取和设置
    public final E get(int i)
    public final void set(int i, E newValue)
    public final void lazySet(int i, E newValue)
    
    // CAS操作
    public final boolean compareAndSet(int i, E expect, E update)
    
    // 获取并设置
    public final E getAndSet(int i, E newValue)
    
    // 函数式操作
    public final E getAndUpdate(int i, UnaryOperator<E> updateFunction)
    public final E updateAndGet(int i, UnaryOperator<E> updateFunction)
}
```

### 4.2 使用示例

```java
// 创建对象数组
AtomicReferenceArray<User> users = new AtomicReferenceArray<>(10);

// 设置对象
users.set(0, new User("张三", 20));

// CAS更新
User oldUser = users.get(0);
User newUser = new User("李四", 25);
users.compareAndSet(0, oldUser, newUser);

// 函数式更新
users.updateAndGet(0, user -> {
    user.setAge(user.getAge() + 1);
    return user;
});
```

---

## 五、实际应用场景

### 5.1 多维计数器

```java
/**
 * 多维统计计数器
 */
public class MultiDimensionCounter {
    private final AtomicIntegerArray counters;
    
    public MultiDimensionCounter(int dimensions) {
        this.counters = new AtomicIntegerArray(dimensions);
    }
    
    public void increment(int dimension) {
        counters.incrementAndGet(dimension);
    }
    
    public int get(int dimension) {
        return counters.get(dimension);
    }
    
    public int getTotal() {
        int total = 0;
        for (int i = 0; i < counters.length(); i++) {
            total += counters.get(i);
        }
        return total;
    }
}

// 使用示例
MultiDimensionCounter counter = new MultiDimensionCounter(5);
counter.increment(0);  // 维度0计数
counter.increment(1);  // 维度1计数
```

### 5.2 时间窗口统计

```java
/**
 * 滑动窗口计数器
 */
public class SlidingWindowCounter {
    private final AtomicIntegerArray buckets;
    private final int windowSize;
    private final AtomicInteger currentIndex = new AtomicInteger(0);
    
    public SlidingWindowCounter(int windowSize) {
        this.windowSize = windowSize;
        this.buckets = new AtomicIntegerArray(windowSize);
    }
    
    public void record() {
        int index = currentIndex.get() % windowSize;
        buckets.incrementAndGet(index);
    }
    
    public void slide() {
        int index = currentIndex.incrementAndGet() % windowSize;
        buckets.set(index, 0);  // 清空旧桶
    }
    
    public int getTotal() {
        int total = 0;
        for (int i = 0; i < windowSize; i++) {
            total += buckets.get(i);
        }
        return total;
    }
}
```

### 5.3 并发哈希表的桶

```java
/**
 * 简化的并发哈希表
 */
public class ConcurrentHashMap<K, V> {
    private static class Node<K, V> {
        final K key;
        volatile V value;
        volatile Node<K, V> next;
        
        Node(K key, V value, Node<K, V> next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    
    private final AtomicReferenceArray<Node<K, V>> table;
    
    public ConcurrentHashMap(int capacity) {
        this.table = new AtomicReferenceArray<>(capacity);
    }
    
    public void put(K key, V value) {
        int index = hash(key) % table.length();
        Node<K, V> newNode = new Node<>(key, value, null);
        
        Node<K, V> oldHead;
        do {
            oldHead = table.get(index);
            newNode.next = oldHead;
        } while (!table.compareAndSet(index, oldHead, newNode));
    }
    
    private int hash(K key) {
        return key.hashCode() & 0x7FFFFFFF;
    }
}
```

---

## 六、性能对比

### 6.1 测试代码

```java
public class PerformanceTest {
    private static final int ARRAY_SIZE = 100;
    private static final int THREAD_COUNT = 10;
    private static final int ITERATIONS = 100000;
    
    // 方案1：synchronized
    static class SyncArray {
        private int[] array = new int[ARRAY_SIZE];
        
        public synchronized void increment(int index) {
            array[index]++;
        }
    }
    
    // 方案2：AtomicIntegerArray
    static class AtomicArray {
        private AtomicIntegerArray array = new AtomicIntegerArray(ARRAY_SIZE);
        
        public void increment(int index) {
            array.incrementAndGet(index);
        }
    }
}
```

### 6.2 性能结果

```
测试环境：10个线程，各执行10万次随机索引自增

结果：
1. synchronized：        1500ms
2. AtomicIntegerArray：  400ms

结论：
- AtomicIntegerArray比synchronized快3.75倍
- 细粒度锁的优势明显
```

---

## 七、常见陷阱

### 7.1 复制构造的陷阱

```java
// ❌ 错误：共享同一个数组
int[] source = {1, 2, 3};
AtomicIntegerArray array1 = new AtomicIntegerArray(source);

source[0] = 100;  // 修改原数组
System.out.println(array1.get(0));  // 仍然是1（已复制）

// ✅ 正确：AtomicIntegerArray会复制数组
```

### 7.2 长度不可变

```java
// ❌ 错误：长度固定，无法扩容
AtomicIntegerArray array = new AtomicIntegerArray(10);
// 无法增加长度

// ✅ 解决：需要扩容时创建新数组
AtomicIntegerArray newArray = new AtomicIntegerArray(20);
for (int i = 0; i < array.length(); i++) {
    newArray.set(i, array.get(i));
}
```

### 7.3 复合操作不是原子的

```java
// ❌ 错误：复合操作不是原子的
AtomicIntegerArray array = new AtomicIntegerArray(10);

if (array.get(0) < 10) {
    array.incrementAndGet(0);  // 不是原子操作
}

// ✅ 正确：使用CAS循环
int oldValue, newValue;
do {
    oldValue = array.get(0);
    if (oldValue >= 10) break;
    newValue = oldValue + 1;
} while (!array.compareAndSet(0, oldValue, newValue));
```

---

## 八、最佳实践

### 8.1 选择合适的数组类型

```java
// ✅ 基本类型：AtomicIntegerArray
AtomicIntegerArray counters = new AtomicIntegerArray(100);

// ✅ 大数值：AtomicLongArray
AtomicLongArray ids = new AtomicLongArray(100);

// ✅ 对象引用：AtomicReferenceArray
AtomicReferenceArray<User> users = new AtomicReferenceArray<>(100);
```

### 8.2 合理设置数组大小

```java
// ❌ 不好：数组太大，内存浪费
AtomicIntegerArray array = new AtomicIntegerArray(1000000);

// ✅ 好的：根据实际需求设置
int size = calculateOptimalSize();
AtomicIntegerArray array = new AtomicIntegerArray(size);
```

### 8.3 避免伪共享

```java
// 问题：相邻元素在同一缓存行，伪共享
AtomicIntegerArray array = new AtomicIntegerArray(10);

// 线程1操作array[0]
// 线程2操作array[1]
// 可能在同一缓存行，导致缓存失效

// 解决：填充（padding）
// 每个元素占用一个缓存行（64字节）
class PaddedAtomicInteger {
    volatile long p1, p2, p3, p4, p5, p6, p7;  // 填充
    volatile int value;
    volatile long p8, p9, p10, p11, p12, p13, p14;  // 填充
}
```

---

## 九、总结

### 9.1 核心要点

1. **AtomicIntegerArray**：int数组的原子操作
2. **AtomicLongArray**：long数组的原子操作
3. **AtomicReferenceArray**：对象数组的原子操作
4. **细粒度锁**：每个元素独立，性能好
5. **应用场景**：多维计数、时间窗口统计、并发容器

### 9.2 性能优势

```
vs synchronized：
- 细粒度锁（元素级别）
- 无锁算法
- 性能提升3-4倍

vs 普通数组：
- 线程安全
- 无需手动加锁
```

### 9.3 思考题

1. **AtomicIntegerArray如何计算元素的内存偏移？**
2. **为什么AtomicIntegerArray比synchronized快？**
3. **什么是伪共享？如何避免？**
4. **数组原子类的长度可以改变吗？**

---

**下一章预告**：我们将学习高性能原子类LongAdder和LongAccumulator。

---

**参考资料**：
- 《Java并发编程实战》第15章
- JDK源码：`java.util.concurrent.atomic.AtomicIntegerArray`
