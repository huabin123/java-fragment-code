# 第三章：引用类型原子类 - 对象的原子操作

> **学习目标**：掌握AtomicReference、AtomicStampedReference、字段更新器的使用

---

## 一、为什么需要引用类型原子类？

### 1.1 基本类型原子类的局限

```java
// 问题：只能操作基本类型
AtomicInteger count = new AtomicInteger(0);  // ✅ int
AtomicLong id = new AtomicLong(0);           // ✅ long

// 如何原子地更新对象？
User user = new User("张三", 20);
// ❌ 无法使用AtomicInteger

// 需求：原子地更新User对象
```

### 1.2 引用类型原子类的解决方案

```java
// 使用AtomicReference
AtomicReference<User> userRef = new AtomicReference<>(
    new User("张三", 20)
);

// 原子地更新User对象
User oldUser = userRef.get();
User newUser = new User("李四", 25);
userRef.compareAndSet(oldUser, newUser);
```

---

## 二、AtomicReference详解

### 2.1 基本使用

```java
public class AtomicReference<V> implements java.io.Serializable {
    
    // 构造方法
    public AtomicReference()
    public AtomicReference(V initialValue)
    
    // 获取和设置
    public final V get()
    public final void set(V newValue)
    public final void lazySet(V newValue)
    
    // CAS操作
    public final boolean compareAndSet(V expect, V update)
    
    // 获取并设置
    public final V getAndSet(V newValue)
    
    // 函数式操作
    public final V getAndUpdate(UnaryOperator<V> updateFunction)
    public final V updateAndGet(UnaryOperator<V> updateFunction)
    public final V getAndAccumulate(V x, BinaryOperator<V> accumulatorFunction)
    public final V accumulateAndGet(V x, BinaryOperator<V> accumulatorFunction)
}
```

### 2.2 实现原理

```java
public class AtomicReference<V> implements java.io.Serializable {
    
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;
    
    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicReference.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }
    
    // 存储引用（volatile保证可见性）
    private volatile V value;
    
    public final boolean compareAndSet(V expect, V update) {
        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);
    }
}
```

**关键点**：
- 使用`compareAndSwapObject`比较对象引用
- 比较的是引用地址，不是对象内容
- volatile保证引用的可见性

### 2.3 使用场景

#### 场景1：无锁栈

```java
public class LockFreeStack<E> {
    private static class Node<E> {
        final E item;
        Node<E> next;
        
        Node(E item) {
            this.item = item;
        }
    }
    
    private AtomicReference<Node<E>> top = new AtomicReference<>();
    
    public void push(E item) {
        Node<E> newHead = new Node<>(item);
        Node<E> oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        } while (!top.compareAndSet(oldHead, newHead));
    }
    
    public E pop() {
        Node<E> oldHead;
        Node<E> newHead;
        do {
            oldHead = top.get();
            if (oldHead == null) {
                return null;
            }
            newHead = oldHead.next;
        } while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    }
}
```

#### 场景2：配置热更新

```java
public class ConfigManager {
    private AtomicReference<Config> configRef = 
        new AtomicReference<>(new Config());
    
    public void updateConfig(Config newConfig) {
        configRef.set(newConfig);  // 原子更新
    }
    
    public Config getConfig() {
        return configRef.get();
    }
    
    public void updateIfChanged(Config expected, Config newConfig) {
        configRef.compareAndSet(expected, newConfig);
    }
}
```

---

## 三、AtomicStampedReference - 解决ABA问题

### 3.1 ABA问题回顾

```java
// ABA问题示例
AtomicReference<String> ref = new AtomicReference<>("A");

// 线程1
String old = ref.get();  // "A"
// ... 被挂起

// 线程2
ref.compareAndSet("A", "B");  // A -> B
ref.compareAndSet("B", "A");  // B -> A

// 线程1继续
ref.compareAndSet(old, "C");  // 成功！但中间状态被忽略
```

### 3.2 AtomicStampedReference的实现

```java
public class AtomicStampedReference<V> {
    
    // 内部类：封装引用和版本号
    private static class Pair<T> {
        final T reference;
        final int stamp;
        
        private Pair(T reference, int stamp) {
            this.reference = reference;
            this.stamp = stamp;
        }
        
        static <T> Pair<T> of(T reference, int stamp) {
            return new Pair<T>(reference, stamp);
        }
    }
    
    private volatile Pair<V> pair;
    
    // 构造方法
    public AtomicStampedReference(V initialRef, int initialStamp) {
        pair = Pair.of(initialRef, initialStamp);
    }
    
    // 获取引用
    public V getReference() {
        return pair.reference;
    }
    
    // 获取版本号
    public int getStamp() {
        return pair.stamp;
    }
    
    // 同时获取引用和版本号
    public V get(int[] stampHolder) {
        Pair<V> pair = this.pair;
        stampHolder[0] = pair.stamp;
        return pair.reference;
    }
    
    // CAS操作（同时比较引用和版本号）
    public boolean compareAndSet(
        V expectedReference,
        V newReference,
        int expectedStamp,
        int newStamp) {
        
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
    
    // 只更新版本号
    public boolean attemptStamp(V expectedReference, int newStamp) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            (newStamp == current.stamp ||
             casPair(current, Pair.of(expectedReference, newStamp)));
    }
}
```

### 3.3 使用示例

```java
// 创建带版本号的引用
AtomicStampedReference<String> ref = 
    new AtomicStampedReference<>("A", 0);

// 线程1
int[] stampHolder = new int[1];
String value = ref.get(stampHolder);  // value="A", stamp=0

// 线程2
ref.compareAndSet("A", "B", 0, 1);  // A -> B, stamp: 0 -> 1
ref.compareAndSet("B", "A", 1, 2);  // B -> A, stamp: 1 -> 2

// 线程1继续
ref.compareAndSet(value, "C", stampHolder[0], stampHolder[0] + 1);
// 失败！因为stamp已经是2，不是0
```

### 3.4 实际应用

```java
/**
 * 账户余额管理（防止ABA问题）
 */
public class Account {
    private AtomicStampedReference<Integer> balance;
    
    public Account(int initialBalance) {
        balance = new AtomicStampedReference<>(initialBalance, 0);
    }
    
    public boolean withdraw(int amount) {
        int[] stampHolder = new int[1];
        int currentBalance;
        int newBalance;
        
        do {
            currentBalance = balance.get(stampHolder);
            if (currentBalance < amount) {
                return false;  // 余额不足
            }
            newBalance = currentBalance - amount;
        } while (!balance.compareAndSet(
            currentBalance, newBalance,
            stampHolder[0], stampHolder[0] + 1
        ));
        
        return true;
    }
    
    public int getBalance() {
        return balance.getReference();
    }
}
```

---

## 四、AtomicMarkableReference

### 4.1 与AtomicStampedReference的区别

```java
// AtomicStampedReference：使用int版本号
AtomicStampedReference<Node> ref1 = 
    new AtomicStampedReference<>(node, 0);

// AtomicMarkableReference：使用boolean标记
AtomicMarkableReference<Node> ref2 = 
    new AtomicMarkableReference<>(node, false);
```

**区别**：

| 特性 | AtomicStampedReference | AtomicMarkableReference |
|------|----------------------|------------------------|
| 标记类型 | int（版本号） | boolean（标记位） |
| 适用场景 | 需要追踪修改次数 | 只需要标记状态 |
| 内存占用 | 略大 | 略小 |

### 4.2 使用场景

```java
/**
 * 无锁链表节点删除
 */
public class Node<E> {
    final E item;
    final AtomicMarkableReference<Node<E>> next;
    
    public Node(E item, Node<E> next) {
        this.item = item;
        this.next = new AtomicMarkableReference<>(next, false);
    }
    
    public boolean delete() {
        Node<E> successor;
        do {
            successor = next.getReference();
        } while (!next.compareAndSet(successor, successor, false, true));
        // 标记为已删除
        return true;
    }
    
    public boolean isDeleted() {
        return next.isMarked();
    }
}
```

---

## 五、字段更新器

### 5.1 为什么需要字段更新器？

```java
// 问题：大量对象，每个都有AtomicInteger，内存占用大
public class User {
    private AtomicInteger age = new AtomicInteger(0);  // 每个对象16字节
}

// 解决：使用字段更新器，共享一个更新器实例
public class User {
    private volatile int age = 0;  // 每个对象4字节
    
    private static final AtomicIntegerFieldUpdater<User> ageUpdater =
        AtomicIntegerFieldUpdater.newUpdater(User.class, "age");
    
    public void incrementAge() {
        ageUpdater.incrementAndGet(this);
    }
}
```

### 5.2 AtomicIntegerFieldUpdater

```java
public abstract class AtomicIntegerFieldUpdater<T> {
    
    // 创建更新器
    public static <U> AtomicIntegerFieldUpdater<U> newUpdater(
        Class<U> tclass,
        String fieldName)
    
    // 原子操作
    public abstract boolean compareAndSet(T obj, int expect, int update);
    public abstract int get(T obj);
    public abstract void set(T obj, int newValue);
    public abstract int getAndIncrement(T obj);
    public abstract int incrementAndGet(T obj);
    // ...
}
```

**使用示例**：

```java
public class Counter {
    private volatile int count = 0;
    
    private static final AtomicIntegerFieldUpdater<Counter> updater =
        AtomicIntegerFieldUpdater.newUpdater(Counter.class, "count");
    
    public void increment() {
        updater.incrementAndGet(this);
    }
    
    public int get() {
        return updater.get(this);
    }
}
```

**要求**：
1. 字段必须是`volatile`
2. 字段不能是`static`
3. 字段不能是`final`
4. 字段必须对更新器可见（通常是public或同包）

### 5.3 AtomicReferenceFieldUpdater

```java
public class Node {
    private volatile Node next;
    
    private static final AtomicReferenceFieldUpdater<Node, Node> nextUpdater =
        AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "next");
    
    public boolean casNext(Node expect, Node update) {
        return nextUpdater.compareAndSet(this, expect, update);
    }
}
```

### 5.4 性能优势

```java
// 内存占用对比（100万个对象）

// 方案1：每个对象一个AtomicInteger
class User {
    AtomicInteger age = new AtomicInteger(0);  // 16字节/对象
}
// 总内存：1000000 * 16 = 16MB

// 方案2：使用字段更新器
class User {
    volatile int age = 0;  // 4字节/对象
    static AtomicIntegerFieldUpdater<User> updater;  // 共享
}
// 总内存：1000000 * 4 = 4MB

// 节省：12MB（75%）
```

---

## 六、实际应用场景

### 6.1 无锁队列

```java
public class LockFreeQueue<E> {
    private static class Node<E> {
        final E item;
        final AtomicReference<Node<E>> next;
        
        Node(E item) {
            this.item = item;
            this.next = new AtomicReference<>();
        }
    }
    
    private AtomicReference<Node<E>> head;
    private AtomicReference<Node<E>> tail;
    
    public LockFreeQueue() {
        Node<E> dummy = new Node<>(null);
        head = new AtomicReference<>(dummy);
        tail = new AtomicReference<>(dummy);
    }
    
    public void enqueue(E item) {
        Node<E> newNode = new Node<>(item);
        while (true) {
            Node<E> curTail = tail.get();
            Node<E> tailNext = curTail.next.get();
            
            if (curTail == tail.get()) {
                if (tailNext != null) {
                    tail.compareAndSet(curTail, tailNext);
                } else {
                    if (curTail.next.compareAndSet(null, newNode)) {
                        tail.compareAndSet(curTail, newNode);
                        return;
                    }
                }
            }
        }
    }
}
```

### 6.2 版本控制

```java
public class VersionedData<T> {
    private AtomicStampedReference<T> dataRef;
    
    public VersionedData(T initialData) {
        dataRef = new AtomicStampedReference<>(initialData, 0);
    }
    
    public T getData() {
        return dataRef.getReference();
    }
    
    public int getVersion() {
        return dataRef.getStamp();
    }
    
    public boolean update(T newData) {
        int[] stampHolder = new int[1];
        T currentData = dataRef.get(stampHolder);
        return dataRef.compareAndSet(
            currentData, newData,
            stampHolder[0], stampHolder[0] + 1
        );
    }
}
```

---

## 七、总结

### 7.1 核心要点

1. **AtomicReference**：对象引用的原子操作
2. **AtomicStampedReference**：带版本号，解决ABA问题
3. **AtomicMarkableReference**：带标记位，简化版本控制
4. **字段更新器**：节省内存，适合大量对象

### 7.2 选择建议

```
AtomicReference：
  ✅ 简单的引用更新
  ✅ 不关心ABA问题

AtomicStampedReference：
  ✅ 需要追踪修改次数
  ✅ 关心ABA问题

AtomicMarkableReference：
  ✅ 只需要标记状态
  ✅ 节点删除标记

字段更新器：
  ✅ 大量对象
  ✅ 节省内存
```

### 7.3 思考题

1. **AtomicReference比较的是什么？**
2. **AtomicStampedReference如何解决ABA问题？**
3. **字段更新器有什么限制？**
4. **什么时候使用AtomicMarkableReference？**

---

**下一章预告**：我们将学习数组类型原子类的使用。

---

**参考资料**：
- 《Java并发编程实战》第15章
- JDK源码：`java.util.concurrent.atomic`
