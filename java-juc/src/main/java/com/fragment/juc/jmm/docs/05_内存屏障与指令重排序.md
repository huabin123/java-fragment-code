# 第五章：内存屏障与指令重排序 - JMM的底层实现

> **学习目标**：深入理解JMM的底层实现机制，掌握内存屏障和指令重排序

---

## 一、为什么会有指令重排序？

### 1.1 性能优化的需求

```
CPU执行指令的速度：
- 寄存器：  1个时钟周期
- L1缓存：  ~4个时钟周期
- L2缓存：  ~10个时钟周期
- L3缓存：  ~40个时钟周期
- 主内存：   ~200个时钟周期

问题：
CPU执行速度远快于内存访问速度
如果按顺序执行，CPU会大量等待

解决方案：
指令重排序，充分利用CPU流水线
```

### 1.2 重排序的三个层次

```
1. 编译器重排序：
   - 编译器在不改变单线程语义的前提下
   - 重新安排语句的执行顺序

2. 处理器重排序：
   - CPU在执行时可能乱序执行指令
   - 包括指令级并行和内存系统重排序

3. 内存系统重排序：
   - 由于缓存和读写缓冲区
   - 使得加载和存储操作看起来是乱序的
```

**示例**：

```java
// 原始代码
int a = 1;  // 1
int b = 2;  // 2
int c = a + b;  // 3

// 可能的重排序
int b = 2;  // 2
int a = 1;  // 1
int c = a + b;  // 3

// 不可能的重排序
int c = a + b;  // 3（违反数据依赖）
int a = 1;  // 1
int b = 2;  // 2
```

---

## 二、as-if-serial语义

### 2.1 定义

```
as-if-serial：
不管怎么重排序，单线程程序的执行结果不能改变。

编译器、处理器、运行时必须遵守这个语义。
```

### 2.2 数据依赖性

```
数据依赖性：
如果两个操作访问同一个变量，
且至少有一个是写操作，
则这两个操作存在数据依赖。

三种类型：
1. 写后读（WAR）：a = 1; b = a;
2. 写后写（WAW）：a = 1; a = 2;
3. 读后写（RAW）：b = a; a = 1;

规则：
有数据依赖的操作不能重排序
```

**示例**：

```java
// 示例1：可以重排序
int a = 1;  // 1
int b = 2;  // 2
// 1和2没有数据依赖，可以重排序

// 示例2：不能重排序
int a = 1;  // 1
int b = a + 1;  // 2
// 2依赖1，不能重排序

// 示例3：控制依赖
if (flag) {  // 1
    int a = 1;  // 2
}
// 2依赖1的控制流，但可能被重排序
// （处理器使用分支预测）
```

### 2.3 多线程下的问题

```java
// as-if-serial只保证单线程
// 多线程下可能出问题

int a = 0;
boolean flag = false;

// 线程1
a = 1;          // 1
flag = true;    // 2

// 线程2
if (flag) {     // 3
    int i = a;  // 4
}

// 问题：
// 1和2可能重排序（单线程内没有数据依赖）
// 如果2在1之前执行，线程2可能看到flag=true但a=0
```

---

## 三、内存屏障（Memory Barrier）

### 3.1 什么是内存屏障？

```
内存屏障（Memory Barrier）：
也叫内存栅栏（Memory Fence）

作用：
1. 阻止屏障两侧的指令重排序
2. 强制刷新缓存到内存
3. 使缓存失效，强制从内存读取

实现：
CPU指令，不同架构有不同的实现
```

### 3.2 四种内存屏障

```
1. LoadLoad屏障：
   Load1; LoadLoad; Load2
   
   作用：
   - 保证Load1的数据在Load2及后续加载指令之前加载
   
   示例：
   int a = x;  // Load1
   LoadLoad屏障
   int b = y;  // Load2

2. StoreStore屏障：
   Store1; StoreStore; Store2
   
   作用：
   - 保证Store1的数据在Store2及后续存储指令之前刷新到内存
   
   示例：
   x = 1;  // Store1
   StoreStore屏障
   y = 2;  // Store2

3. LoadStore屏障：
   Load1; LoadStore; Store2
   
   作用：
   - 保证Load1的数据在Store2及后续存储指令之前加载
   
   示例：
   int a = x;  // Load1
   LoadStore屏障
   y = 2;  // Store2

4. StoreLoad屏障：
   Store1; StoreLoad; Load2
   
   作用：
   - 保证Store1的数据在Load2及后续加载指令之前刷新到内存
   - 开销最大，相当于全屏障
   
   示例：
   x = 1;  // Store1
   StoreLoad屏障
   int a = y;  // Load2
```

### 3.3 JMM的内存屏障插入策略

```
volatile写操作：
普通写
StoreStore屏障
volatile写
StoreLoad屏障
普通读/写

volatile读操作：
普通读/写
LoadLoad屏障
volatile读
LoadStore屏障
普通写

synchronized：
进入：LoadLoad + LoadStore
退出：LoadStore + StoreStore
```

**示例**：

```java
int a = 0;
volatile int v = 0;
int b = 0;

// 写操作
a = 1;              // 普通写
// StoreStore屏障
v = 2;              // volatile写
// StoreLoad屏障
b = 3;              // 普通写

// 读操作
int r1 = v;         // volatile读
// LoadLoad屏障
// LoadStore屏障
int r2 = a;         // 普通读
int r3 = b;         // 普通读

// 保证：
// 1. a=1在v=2之前刷新到内存
// 2. v=2在b=3之前完成
// 3. r1=v在r2=a之前完成
// 4. r1=v在r3=b之前完成
```

---

## 四、CPU缓存一致性

### 4.1 MESI协议

```
MESI协议：
保证多核CPU缓存一致性的协议

四种状态：
M (Modified)：   已修改，独占，与内存不一致
E (Exclusive)：  独占，与内存一致
S (Shared)：     共享，多个CPU缓存都有
I (Invalid)：    无效，需要从内存重新加载

状态转换：
M → E：写回内存
E → S：其他CPU读取
S → I：其他CPU修改
I → E：独占读取
I → S：共享读取
```

**示例**：

```
初始状态：
CPU1: I (count)
CPU2: I (count)
内存: count = 0

CPU1读取count：
CPU1: E (count=0)  // 独占
CPU2: I (count)
内存: count = 0

CPU2读取count：
CPU1: S (count=0)  // 共享
CPU2: S (count=0)  // 共享
内存: count = 0

CPU1写入count=1：
CPU1: M (count=1)  // 已修改
CPU2: I (count)    // 失效
内存: count = 0    // 未同步

CPU1写回内存：
CPU1: E (count=1)  // 独占
CPU2: I (count)    // 失效
内存: count = 1    // 已同步
```

### 4.2 缓存行（Cache Line）

```
缓存行：
CPU缓存的最小单位，通常是64字节

问题：伪共享（False Sharing）
- 两个变量在同一个缓存行
- 一个变量被修改，整个缓存行失效
- 导致另一个变量也需要重新加载

示例：
class Data {
    volatile long x;  // 8字节
    volatile long y;  // 8字节
}

// x和y可能在同一个缓存行
// 线程1修改x，线程2的y缓存失效
// 即使y没有被修改

解决方案：缓存行填充
class Data {
    volatile long x;
    long p1, p2, p3, p4, p5, p6, p7;  // 填充56字节
    volatile long y;
}

// 或使用@Contended注解（JDK 8+）
class Data {
    @sun.misc.Contended
    volatile long x;
    
    @sun.misc.Contended
    volatile long y;
}
```

---

## 五、不同架构的内存模型

### 5.1 x86架构

```
x86/x64的内存模型：
- 相对较强的内存模型
- 保证Store-Store顺序
- 保证Load-Load顺序
- 保证Load-Store顺序
- 不保证Store-Load顺序

特点：
- 只需要StoreLoad屏障
- 其他屏障可以省略
- volatile写需要StoreLoad屏障
- volatile读不需要屏障
```

### 5.2 ARM架构

```
ARM的内存模型：
- 相对较弱的内存模型
- 允许各种重排序
- 需要显式的内存屏障

特点：
- 需要所有类型的内存屏障
- volatile读写都需要屏障
- 性能开销较大
```

### 5.3 JMM的抽象

```
JMM的设计：
- 提供统一的抽象
- 屏蔽不同架构的差异
- 在不同平台上保证一致的语义

实现：
- 在强内存模型上可以省略部分屏障
- 在弱内存模型上需要完整的屏障
- JVM根据平台自动选择
```

---

## 六、happens-before的实现

### 6.1 volatile的实现

```java
// volatile变量
volatile int v = 0;

// 写操作
v = 1;

// 编译后（x86）：
mov [v], 1
lock addl $0, 0(%rsp)  // StoreLoad屏障

// lock前缀的作用：
// 1. 锁定缓存行
// 2. 刷新到内存
// 3. 使其他CPU缓存失效
```

### 6.2 synchronized的实现

```java
// synchronized块
synchronized (lock) {
    // 临界区
}

// 编译后（x86）：
monitorenter  // 进入监视器
    // LoadLoad + LoadStore屏障
    // 临界区代码
    // LoadStore + StoreStore屏障
monitorexit   // 退出监视器

// 作用：
// 1. 进入时：清空工作内存，从主内存读取
// 2. 退出时：刷新工作内存到主内存
```

### 6.3 final的实现

```java
// final域
class FinalExample {
    final int x;
    
    FinalExample() {
        x = 1;
        // StoreStore屏障
    }
}

// 作用：
// 保证final域的写入在构造函数返回前完成
```

---

## 七、实际应用

### 7.1 双重检查锁的正确实现

```java
public class Singleton {
    private static volatile Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {  // 1. 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {  // 2. 第二次检查
                    instance = new Singleton();  // 3. 创建对象
                }
            }
        }
        return instance;
    }
}

// volatile的作用：
// 1. 禁止3的重排序
// 2. 保证对象完全初始化后才对其他线程可见

// 内存屏障：
// instance = new Singleton();
// StoreStore屏障（保证初始化完成）
// volatile写
// StoreLoad屏障（保证对其他线程可见）
```

### 7.2 无锁队列的实现

```java
public class LockFreeQueue<E> {
    private static class Node<E> {
        volatile E item;
        volatile Node<E> next;
    }
    
    private volatile Node<E> head;
    private volatile Node<E> tail;
    
    public void enqueue(E item) {
        Node<E> newNode = new Node<>();
        newNode.item = item;
        
        while (true) {
            Node<E> curTail = tail;  // volatile读
            Node<E> tailNext = curTail.next;  // volatile读
            
            if (curTail == tail) {
                if (tailNext != null) {
                    // 帮助其他线程完成入队
                    CAS(tail, curTail, tailNext);
                } else {
                    // 尝试入队
                    if (CAS(curTail.next, null, newNode)) {
                        CAS(tail, curTail, newNode);
                        return;
                    }
                }
            }
        }
    }
}

// volatile的作用：
// 1. 保证head和tail的可见性
// 2. 保证node.next的可见性
// 3. 配合CAS实现无锁算法
```

---

## 八、性能优化

### 8.1 减少volatile的使用

```java
// ❌ 不好：过度使用volatile
class Counter {
    volatile int count = 0;
    
    public void increment() {
        count++;  // 不是原子的
    }
}

// ✅ 好的：使用AtomicInteger
class Counter {
    AtomicInteger count = new AtomicInteger(0);
    
    public void increment() {
        count.incrementAndGet();
    }
}
```

### 8.2 批量操作

```java
// ❌ 不好：频繁的volatile写
volatile boolean flag1 = false;
volatile boolean flag2 = false;
volatile boolean flag3 = false;

public void update() {
    flag1 = true;  // StoreLoad屏障
    flag2 = true;  // StoreLoad屏障
    flag3 = true;  // StoreLoad屏障
}

// ✅ 好的：合并状态
volatile int flags = 0;

public void update() {
    flags = 0b111;  // 一次StoreLoad屏障
}
```

### 8.3 避免伪共享

```java
// ❌ 不好：伪共享
class Data {
    volatile long x;
    volatile long y;
}

// ✅ 好的：缓存行填充
class Data {
    volatile long x;
    long p1, p2, p3, p4, p5, p6, p7;
    volatile long y;
}

// 或使用@Contended
class Data {
    @sun.misc.Contended
    volatile long x;
    
    @sun.misc.Contended
    volatile long y;
}
```

---

## 九、总结

### 9.1 核心要点

1. **指令重排序**：编译器、处理器、内存系统三个层次
2. **as-if-serial**：单线程语义不变
3. **内存屏障**：4种类型，控制重排序
4. **MESI协议**：CPU缓存一致性
5. **JMM实现**：通过内存屏障实现happens-before

### 9.2 内存屏障总结

| 屏障 | 作用 | 开销 |
|------|------|------|
| LoadLoad | 禁止Load重排序 | 小 |
| StoreStore | 禁止Store重排序 | 小 |
| LoadStore | 禁止Load-Store重排序 | 中 |
| StoreLoad | 禁止Store-Load重排序 | 大 |

### 9.3 思考题

1. **为什么会有指令重排序？**
2. **什么是as-if-serial语义？**
3. **内存屏障有哪几种？**
4. **MESI协议是什么？**
5. **如何避免伪共享？**

---

**恭喜！你已经完成了JMM的深度学习！** 🎉

---

**参考资料**：
- 《Java并发编程实战》第16章
- 《深入理解Java虚拟机》第12章
- Intel® 64 and IA-32 Architectures Software Developer's Manual
- ARM Architecture Reference Manual
