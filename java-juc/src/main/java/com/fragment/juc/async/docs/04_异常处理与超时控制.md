# 第四章：异常处理与超时控制 - 构建健壮的异步应用

> **学习目标**：掌握CompletableFuture的异常处理和超时控制，构建生产级异步应用

---

## 一、为什么异常处理很重要？

### 1.1 异步异常的特殊性

```java
// 同步代码：异常处理简单
try {
    String result = riskyOperation();
    System.out.println(result);
} catch (Exception e) {
    System.err.println("错误: " + e.getMessage());
}

// 异步代码：异常在另一个线程
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("异步异常");
    // 这个异常在哪里捕获？
});

// 问题：
// ❌ 异常发生在工作线程，主线程无法直接捕获
// ❌ 如果不处理，异常会被"吞掉"
// ❌ 链式调用中，异常会传播到哪里？
```

### 1.2 未处理异常的后果

```java
// 危险示例：异常被吞掉
CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("严重错误");
}).thenApply(result -> {
    // 这行永远不会执行
    return result.toUpperCase();
});

// 程序继续运行，但任务失败了
// 用户不知道发生了什么
// 日志中也没有记录
```

---

## 二、异常处理方法

### 2.1 exceptionally - 处理异常

```java
/**
 * 处理异常，返回默认值
 * 
 * @param fn 异常处理函数
 * @return 新的CompletableFuture
 */
public CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn)
```

**使用示例**：

```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> {
        if (Math.random() > 0.5) {
            throw new RuntimeException("随机异常");
        }
        return "成功";
    })
    .exceptionally(ex -> {
        System.err.println("捕获异常: " + ex.getMessage());
        return "默认值"; // 返回降级结果
    });

// 无论成功还是失败，都会有结果
String result = future.get();
System.out.println("结果: " + result);
```

**工作原理**：

```
正常流程：
supplyAsync() -> "成功" -> 返回"成功"

异常流程：
supplyAsync() -> 抛异常 -> exceptionally() -> 返回"默认值"
```

**实际应用**：

```java
/**
 * 查询用户信息，失败时返回默认用户
 */
public CompletableFuture<User> getUserWithFallback(String userId) {
    return CompletableFuture
        .supplyAsync(() -> userService.getUser(userId))
        .exceptionally(ex -> {
            log.error("查询用户失败: " + userId, ex);
            return User.getDefaultUser(); // 返回默认用户
        });
}
```

---

### 2.2 handle - 处理结果或异常

```java
/**
 * 处理正常结果或异常
 * 
 * @param fn BiFunction<结果, 异常, 新结果>
 * @return 新的CompletableFuture
 */
public <U> CompletableFuture<U> handle(
    BiFunction<? super T, Throwable, ? extends U> fn)
```

**使用示例**：

```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> {
        if (Math.random() > 0.5) {
            throw new RuntimeException("错误");
        }
        return "成功";
    })
    .handle((result, ex) -> {
        if (ex != null) {
            // 处理异常
            System.err.println("异常: " + ex.getMessage());
            return "错误处理";
        } else {
            // 处理正常结果
            System.out.println("成功: " + result);
            return result.toUpperCase();
        }
    });
```

**vs exceptionally**：

```java
// exceptionally：只处理异常
future.exceptionally(ex -> "默认值")

// handle：同时处理结果和异常
future.handle((result, ex) -> {
    if (ex != null) {
        return "错误: " + ex.getMessage();
    }
    return "成功: " + result;
})
```

**实际应用**：

```java
/**
 * HTTP请求，统一处理成功和失败
 */
public CompletableFuture<Response> httpRequest(String url) {
    return CompletableFuture
        .supplyAsync(() -> httpClient.get(url))
        .handle((response, ex) -> {
            if (ex != null) {
                // 请求失败
                return Response.error(ex.getMessage());
            } else {
                // 请求成功
                return Response.success(response);
            }
        });
}
```

---

### 2.3 whenComplete - 完成时执行

```java
/**
 * 完成时执行（无论成功还是失败）
 * 不改变结果
 * 
 * @param action BiConsumer<结果, 异常>
 * @return 新的CompletableFuture
 */
public CompletableFuture<T> whenComplete(
    BiConsumer<? super T, ? super Throwable> action)
```

**使用示例**：

```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "结果")
    .whenComplete((result, ex) -> {
        if (ex != null) {
            System.err.println("失败: " + ex.getMessage());
        } else {
            System.out.println("成功: " + result);
        }
        // 不改变结果，只是记录日志
    });

// 结果不变
String result = future.get(); // "结果"
```

**vs handle**：

```java
// handle：可以改变结果
future.handle((result, ex) -> {
    return "新结果"; // 改变结果
})

// whenComplete：不改变结果
future.whenComplete((result, ex) -> {
    System.out.println(result); // 只是观察，不改变
})
```

**实际应用**：

```java
/**
 * 记录任务执行时间
 */
public CompletableFuture<String> timedTask() {
    long startTime = System.currentTimeMillis();
    
    return CompletableFuture
        .supplyAsync(() -> expensiveOperation())
        .whenComplete((result, ex) -> {
            long duration = System.currentTimeMillis() - startTime;
            if (ex != null) {
                log.error("任务失败，耗时: {}ms", duration, ex);
            } else {
                log.info("任务成功，耗时: {}ms", duration);
            }
        });
}
```

---

## 三、异常传播

### 3.1 异常在链式调用中的传播

```java
CompletableFuture.supplyAsync(() -> {
    System.out.println("步骤1");
    throw new RuntimeException("步骤1异常");
})
.thenApply(result -> {
    System.out.println("步骤2"); // 不会执行
    return result.toUpperCase();
})
.thenApply(result -> {
    System.out.println("步骤3"); // 不会执行
    return result + "!";
})
.exceptionally(ex -> {
    System.err.println("捕获异常: " + ex.getMessage());
    return "默认值";
});

// 输出：
// 步骤1
// 捕获异常: java.lang.RuntimeException: 步骤1异常
```

**传播规则**：

```
步骤1抛异常 -> 步骤2跳过 -> 步骤3跳过 -> exceptionally捕获

类似于：
try {
    step1();
    step2();
    step3();
} catch (Exception e) {
    // 处理异常
}
```

### 3.2 中途捕获异常

```java
CompletableFuture.supplyAsync(() -> {
    System.out.println("步骤1");
    throw new RuntimeException("步骤1异常");
})
.exceptionally(ex -> {
    System.err.println("捕获步骤1异常: " + ex.getMessage());
    return "恢复值"; // 恢复正常流程
})
.thenApply(result -> {
    System.out.println("步骤2: " + result); // 会执行
    return result.toUpperCase();
})
.thenAccept(result -> {
    System.out.println("步骤3: " + result); // 会执行
});

// 输出：
// 步骤1
// 捕获步骤1异常: java.lang.RuntimeException: 步骤1异常
// 步骤2: 恢复值
// 步骤3: 恢复值
```

---

## 四、超时控制

### 4.1 为什么需要超时？

```java
// 场景：调用外部服务
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // 外部服务可能很慢，甚至挂了
    return externalService.call();
});

// 问题：
// ❌ 如果服务挂了，可能永远等待
// ❌ 影响用户体验
// ❌ 资源无法释放
```

### 4.2 JDK 9+ 的超时方法

```java
/**
 * 超时后抛出TimeoutException
 * JDK 9+
 */
public CompletableFuture<T> orTimeout(long timeout, TimeUnit unit)

/**
 * 超时后返回默认值
 * JDK 9+
 */
public CompletableFuture<T> completeOnTimeout(
    T value, long timeout, TimeUnit unit)
```

**JDK 9+ 使用示例**：

```java
// 超时抛异常
CompletableFuture<String> future1 = CompletableFuture
    .supplyAsync(() -> slowOperation())
    .orTimeout(2, TimeUnit.SECONDS) // 2秒超时
    .exceptionally(ex -> {
        if (ex instanceof TimeoutException) {
            return "超时了";
        }
        return "其他错误";
    });

// 超时返回默认值
CompletableFuture<String> future2 = CompletableFuture
    .supplyAsync(() -> slowOperation())
    .completeOnTimeout("默认值", 2, TimeUnit.SECONDS);
```

### 4.3 JDK 8 的超时实现

```java
/**
 * JDK 8兼容的超时实现
 */
public static <T> CompletableFuture<T> withTimeout(
        CompletableFuture<T> future, 
        long timeout, 
        TimeUnit unit) {
    
    // 创建超时Future
    CompletableFuture<T> timeoutFuture = new CompletableFuture<>();
    
    // 定时器
    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    scheduler.schedule(() -> {
        timeoutFuture.completeExceptionally(
            new TimeoutException("操作超时")
        );
    }, timeout, unit);
    
    // 返回最快完成的Future
    return future.applyToEither(timeoutFuture, Function.identity());
}

// 使用
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> slowOperation());

CompletableFuture<String> withTimeout = withTimeout(future, 2, TimeUnit.SECONDS)
    .exceptionally(ex -> {
        if (ex instanceof TimeoutException) {
            return "超时降级";
        }
        return "错误";
    });
```

### 4.4 超时 + 降级

```java
/**
 * 超时后使用降级数据
 */
public CompletableFuture<String> getDataWithTimeout(String key) {
    // 主数据源
    CompletableFuture<String> primary = CompletableFuture
        .supplyAsync(() -> primaryDataSource.get(key));
    
    // 超时Future
    CompletableFuture<String> timeout = new CompletableFuture<>();
    scheduler.schedule(() -> {
        timeout.completeExceptionally(new TimeoutException());
    }, 1, TimeUnit.SECONDS);
    
    // 返回最快的结果
    return primary.applyToEither(timeout, Function.identity())
        .exceptionally(ex -> {
            // 超时或异常，使用降级数据
            log.warn("主数据源超时，使用降级数据");
            return fallbackDataSource.get(key);
        });
}
```

---

## 五、组合异常处理

### 5.1 多个Future的异常处理

```java
CompletableFuture<String> future1 = CompletableFuture
    .supplyAsync(() -> {
        throw new RuntimeException("Future1异常");
    });

CompletableFuture<String> future2 = CompletableFuture
    .supplyAsync(() -> "Future2成功");

// allOf：任一失败则失败
CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);

allOf.handle((result, ex) -> {
    if (ex != null) {
        System.err.println("有Future失败: " + ex.getMessage());
        return null;
    }
    
    // 收集所有成功的结果
    try {
        String r1 = future1.join();
        String r2 = future2.join();
        return Arrays.asList(r1, r2);
    } catch (Exception e) {
        System.err.println("获取结果失败: " + e.getMessage());
        return Collections.emptyList();
    }
});
```

### 5.2 部分失败处理

```java
/**
 * 批量查询，部分失败不影响整体
 */
public CompletableFuture<List<User>> batchGetUsers(List<String> userIds) {
    List<CompletableFuture<User>> futures = userIds.stream()
        .map(id -> CompletableFuture
            .supplyAsync(() -> userService.getUser(id))
            .exceptionally(ex -> {
                // 单个失败，返回null
                log.error("查询用户失败: " + id, ex);
                return null;
            })
        )
        .collect(Collectors.toList());
    
    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> 
            futures.stream()
                .map(CompletableFuture::join)
                .filter(Objects::nonNull) // 过滤失败的
                .collect(Collectors.toList())
        );
}
```

---

## 六、异常处理最佳实践

### 6.1 总是处理异常

```java
// ❌ 不好的做法：不处理异常
CompletableFuture.supplyAsync(() -> riskyOperation());

// ✅ 好的做法：处理异常
CompletableFuture.supplyAsync(() -> riskyOperation())
    .exceptionally(ex -> {
        log.error("操作失败", ex);
        return defaultValue;
    });
```

### 6.2 区分不同类型的异常

```java
CompletableFuture.supplyAsync(() -> operation())
    .exceptionally(ex -> {
        Throwable cause = ex.getCause(); // 获取真正的异常
        
        if (cause instanceof TimeoutException) {
            // 超时异常
            return handleTimeout();
        } else if (cause instanceof IOException) {
            // IO异常
            return handleIOException();
        } else {
            // 其他异常
            return handleOtherException();
        }
    });
```

### 6.3 记录日志

```java
CompletableFuture.supplyAsync(() -> operation())
    .whenComplete((result, ex) -> {
        if (ex != null) {
            log.error("操作失败", ex);
        } else {
            log.info("操作成功: {}", result);
        }
    })
    .exceptionally(ex -> defaultValue);
```

### 6.4 设置合理的超时

```java
// ❌ 不好的做法：无超时
CompletableFuture.supplyAsync(() -> externalCall());

// ✅ 好的做法：设置超时
CompletableFuture.supplyAsync(() -> externalCall())
    .orTimeout(5, TimeUnit.SECONDS) // JDK 9+
    .exceptionally(ex -> fallbackValue);
```

---

## 七、实际应用示例

### 7.1 带重试的异步调用

```java
/**
 * 带重试的异步调用
 */
public CompletableFuture<String> callWithRetry(int maxRetries) {
    return callWithRetry(maxRetries, 0);
}

private CompletableFuture<String> callWithRetry(int maxRetries, int attempt) {
    return CompletableFuture
        .supplyAsync(() -> externalService.call())
        .exceptionally(ex -> {
            if (attempt < maxRetries) {
                log.warn("调用失败，重试第{}次", attempt + 1);
                try {
                    Thread.sleep(1000 * (attempt + 1)); // 指数退避
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return callWithRetry(maxRetries, attempt + 1).join();
            } else {
                log.error("调用失败，已达最大重试次数", ex);
                throw new RuntimeException("调用失败", ex);
            }
        });
}
```

### 7.2 熔断器模式

```java
/**
 * 简单的熔断器
 */
public class CircuitBreaker {
    private AtomicInteger failureCount = new AtomicInteger(0);
    private static final int THRESHOLD = 5;
    private volatile boolean open = false;
    
    public <T> CompletableFuture<T> execute(Supplier<T> supplier) {
        if (open) {
            return CompletableFuture.failedFuture(
                new RuntimeException("熔断器打开")
            );
        }
        
        return CompletableFuture.supplyAsync(supplier)
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    int failures = failureCount.incrementAndGet();
                    if (failures >= THRESHOLD) {
                        open = true;
                        log.warn("熔断器打开");
                    }
                } else {
                    failureCount.set(0); // 成功则重置
                }
            });
    }
}
```

---

## 八、总结

### 8.1 异常处理方法总结

| 方法 | 用途 | 是否改变结果 |
|------|------|-------------|
| exceptionally | 处理异常 | 是 |
| handle | 处理结果或异常 | 是 |
| whenComplete | 观察结果或异常 | 否 |

### 8.2 超时控制总结

```
JDK 9+：
- orTimeout() - 超时抛异常
- completeOnTimeout() - 超时返回默认值

JDK 8：
- 使用ScheduledExecutorService
- 使用applyToEither竞速
```

### 8.3 最佳实践

```
✅ 总是处理异常
✅ 设置合理的超时
✅ 记录日志
✅ 区分异常类型
✅ 提供降级方案
✅ 考虑重试机制
```

### 8.4 思考题

1. **exceptionally和handle有什么区别？**
2. **如何在JDK 8中实现超时？**
3. **异常如何在链式调用中传播？**
4. **如何处理批量操作中的部分失败？**

---

**下一章预告**：我们将学习CompletableFuture的最佳实践和性能优化，包括线程池选择、内存管理、监控等。

---

**参考资料**：
- 《Java并发编程实战》
- [CompletableFuture异常处理](https://www.baeldung.com/java-completablefuture-exception-handling)
