# 第三章：异步编排与组合 - 构建复杂异步流程

> **学习目标**：掌握CompletableFuture的组合操作，构建复杂的异步工作流

---

## 一、为什么需要组合操作？

### 1.1 现实业务场景

```java
// 场景：用户下单流程
1. 验证用户身份
2. 检查库存
3. 计算价格（需要查询优惠信息）
4. 创建订单
5. 扣减库存
6. 发送通知

// 问题：
// - 有些步骤可以并行（检查库存 + 计算价格）
// - 有些步骤必须串行（验证身份 -> 创建订单）
// - 如何优雅地组合这些异步操作？
```

### 1.2 传统方式的问题

```java
// 传统方式：手动管理Future
ExecutorService executor = Executors.newFixedThreadPool(10);

// 步骤1：验证用户
Future<User> userFuture = executor.submit(() -> validateUser(userId));
User user = userFuture.get(); // 阻塞

// 步骤2：并行检查库存和计算价格
Future<Boolean> stockFuture = executor.submit(() -> checkStock(productId));
Future<Double> priceFuture = executor.submit(() -> calculatePrice(productId));

Boolean hasStock = stockFuture.get(); // 阻塞
Double price = priceFuture.get(); // 阻塞

// 步骤3：创建订单
if (hasStock) {
    Future<Order> orderFuture = executor.submit(() -> createOrder(user, productId, price));
    Order order = orderFuture.get(); // 阻塞
}

// 问题：
// ❌ 大量的get()调用，阻塞等待
// ❌ 代码冗长，难以维护
// ❌ 异常处理复杂
```

### 1.3 CompletableFuture的解决方案

```java
// 使用CompletableFuture组合
CompletableFuture.supplyAsync(() -> validateUser(userId))
    .thenCompose(user -> {
        // 并行检查库存和计算价格
        CompletableFuture<Boolean> stockFuture = 
            CompletableFuture.supplyAsync(() -> checkStock(productId));
        CompletableFuture<Double> priceFuture = 
            CompletableFuture.supplyAsync(() -> calculatePrice(productId));
        
        return stockFuture.thenCombine(priceFuture, (hasStock, price) -> {
            if (!hasStock) {
                throw new RuntimeException("库存不足");
            }
            return new OrderInfo(user, productId, price);
        });
    })
    .thenCompose(orderInfo -> 
        CompletableFuture.supplyAsync(() -> createOrder(orderInfo))
    )
    .thenAccept(order -> {
        System.out.println("订单创建成功: " + order);
    })
    .exceptionally(ex -> {
        System.err.println("订单创建失败: " + ex.getMessage());
        return null;
    });

// 优势：
// ✅ 非阻塞，流式API
// ✅ 代码简洁，逻辑清晰
// ✅ 异常处理优雅
```

---

## 二、串行组合：thenCompose

### 2.1 方法定义

```java
/**
 * 串行组合：前一个Future完成后，执行下一个Future
 * 
 * @param fn 接收前一个结果，返回新的CompletableFuture
 * @return 新的CompletableFuture
 */
public <U> CompletableFuture<U> thenCompose(
    Function<? super T, ? extends CompletionStage<U>> fn)

public <U> CompletableFuture<U> thenComposeAsync(
    Function<? super T, ? extends CompletionStage<U>> fn)
```

### 2.2 使用场景

```java
// 场景：获取用户 -> 获取订单 -> 计算总金额
CompletableFuture<Double> totalFuture = CompletableFuture
    .supplyAsync(() -> getUser(userId))
    .thenCompose(user -> 
        CompletableFuture.supplyAsync(() -> getOrders(user.getId()))
    )
    .thenCompose(orders -> 
        CompletableFuture.supplyAsync(() -> calculateTotal(orders))
    );

// 流程图：
// getUser() -> getOrders() -> calculateTotal()
//    ↓            ↓               ↓
//   User       Orders          Double
```

### 2.3 vs thenApply

```java
// thenApply：返回值直接是结果
CompletableFuture<String> future1 = CompletableFuture
    .supplyAsync(() -> "hello")
    .thenApply(s -> s.toUpperCase()); // 返回String

// thenCompose：返回值是CompletableFuture
CompletableFuture<String> future2 = CompletableFuture
    .supplyAsync(() -> "hello")
    .thenCompose(s -> 
        CompletableFuture.supplyAsync(() -> s.toUpperCase())
    ); // 返回CompletableFuture<String>
```

**类比Stream API**：

```java
// Stream的flatMap
List<List<Integer>> lists = Arrays.asList(
    Arrays.asList(1, 2),
    Arrays.asList(3, 4)
);
List<Integer> flattened = lists.stream()
    .flatMap(list -> list.stream()) // 扁平化
    .collect(Collectors.toList());

// CompletableFuture的thenCompose
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "input")
    .thenCompose(s -> 
        CompletableFuture.supplyAsync(() -> process(s))
    ); // 扁平化CompletableFuture<CompletableFuture<String>>
```

### 2.4 实际示例

```java
/**
 * 用户登录流程
 */
public CompletableFuture<String> login(String username, String password) {
    return CompletableFuture
        // 1. 验证用户名密码
        .supplyAsync(() -> validateCredentials(username, password))
        // 2. 查询用户信息
        .thenCompose(userId -> 
            CompletableFuture.supplyAsync(() -> getUserInfo(userId))
        )
        // 3. 生成Token
        .thenCompose(user -> 
            CompletableFuture.supplyAsync(() -> generateToken(user))
        )
        // 4. 记录登录日志
        .thenCompose(token -> {
            CompletableFuture.runAsync(() -> logLogin(username));
            return CompletableFuture.completedFuture(token);
        });
}
```

---

## 三、并行组合：thenCombine

### 3.1 方法定义

```java
/**
 * 并行组合：两个Future都完成后，合并结果
 * 
 * @param other 另一个CompletableFuture
 * @param fn 合并函数
 * @return 新的CompletableFuture
 */
public <U,V> CompletableFuture<V> thenCombine(
    CompletionStage<? extends U> other,
    BiFunction<? super T,? super U,? extends V> fn)

public <U,V> CompletableFuture<V> thenCombineAsync(
    CompletionStage<? extends U> other,
    BiFunction<? super T,? super U,? extends V> fn)
```

### 3.2 使用场景

```java
// 场景：并行查询用户和订单，然后合并
CompletableFuture<User> userFuture = 
    CompletableFuture.supplyAsync(() -> getUser(userId));

CompletableFuture<List<Order>> ordersFuture = 
    CompletableFuture.supplyAsync(() -> getOrders(userId));

CompletableFuture<Dashboard> dashboardFuture = userFuture.thenCombine(
    ordersFuture,
    (user, orders) -> new Dashboard(user, orders)
);

// 流程图：
// getUser()    getOrders()
//    ↓            ↓
//   User        Orders
//    └────┬───────┘
//      合并
//         ↓
//     Dashboard
```

### 3.3 性能优势

```java
// 串行执行（慢）
long start1 = System.currentTimeMillis();
String user = getUser();     // 100ms
String orders = getOrders(); // 100ms
String result1 = user + orders;
long time1 = System.currentTimeMillis() - start1; // 200ms

// 并行执行（快）
long start2 = System.currentTimeMillis();
CompletableFuture<String> userFuture = 
    CompletableFuture.supplyAsync(() -> getUser());
CompletableFuture<String> ordersFuture = 
    CompletableFuture.supplyAsync(() -> getOrders());

String result2 = userFuture.thenCombine(ordersFuture, (u, o) -> u + o).get();
long time2 = System.currentTimeMillis() - start2; // 100ms

// 性能提升：2倍！
```

### 3.4 实际示例

```java
/**
 * 商品详情页
 */
public CompletableFuture<ProductDetail> getProductDetail(String productId) {
    // 并行查询多个数据源
    CompletableFuture<Product> productFuture = 
        CompletableFuture.supplyAsync(() -> getProduct(productId));
    
    CompletableFuture<List<Review>> reviewsFuture = 
        CompletableFuture.supplyAsync(() -> getReviews(productId));
    
    CompletableFuture<Inventory> inventoryFuture = 
        CompletableFuture.supplyAsync(() -> getInventory(productId));
    
    // 两两组合
    return productFuture.thenCombine(reviewsFuture, (product, reviews) -> {
        product.setReviews(reviews);
        return product;
    }).thenCombine(inventoryFuture, (product, inventory) -> {
        return new ProductDetail(product, inventory);
    });
}
```

---

## 四、等待所有完成：allOf

### 4.1 方法定义

```java
/**
 * 等待所有CompletableFuture完成
 * 
 * @param cfs 多个CompletableFuture
 * @return CompletableFuture<Void>
 */
public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)
```

### 4.2 使用场景

```java
// 场景：批量查询多个用户
List<String> userIds = Arrays.asList("1", "2", "3", "4", "5");

// 创建多个异步任务
List<CompletableFuture<User>> futures = userIds.stream()
    .map(id -> CompletableFuture.supplyAsync(() -> getUser(id)))
    .collect(Collectors.toList());

// 等待所有完成
CompletableFuture<Void> allOf = CompletableFuture.allOf(
    futures.toArray(new CompletableFuture[0])
);

// 获取所有结果
allOf.thenRun(() -> {
    List<User> users = futures.stream()
        .map(CompletableFuture::join)
        .collect(Collectors.toList());
    
    System.out.println("所有用户: " + users);
});
```

### 4.3 注意事项

```java
// 注意：allOf返回CompletableFuture<Void>，不包含结果
CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);

// 需要手动获取每个Future的结果
allOf.thenRun(() -> {
    String result1 = future1.join();
    String result2 = future2.join();
    // 使用结果...
});
```

### 4.4 封装工具方法

```java
/**
 * 等待所有完成并收集结果
 */
public static <T> CompletableFuture<List<T>> allOfList(
        List<CompletableFuture<T>> futures) {
    
    CompletableFuture<Void> allOf = CompletableFuture.allOf(
        futures.toArray(new CompletableFuture[0])
    );
    
    return allOf.thenApply(v -> 
        futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList())
    );
}

// 使用
List<CompletableFuture<User>> futures = userIds.stream()
    .map(id -> CompletableFuture.supplyAsync(() -> getUser(id)))
    .collect(Collectors.toList());

CompletableFuture<List<User>> allUsers = allOfList(futures);
allUsers.thenAccept(users -> System.out.println("所有用户: " + users));
```

### 4.5 实际示例

```java
/**
 * 批量导入数据
 */
public CompletableFuture<ImportResult> batchImport(List<Data> dataList) {
    // 分批处理
    int batchSize = 100;
    List<List<Data>> batches = partition(dataList, batchSize);
    
    // 每批创建一个异步任务
    List<CompletableFuture<Integer>> futures = batches.stream()
        .map(batch -> CompletableFuture.supplyAsync(() -> {
            return importBatch(batch);
        }))
        .collect(Collectors.toList());
    
    // 等待所有批次完成
    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .thenApply(v -> {
            int totalSuccess = futures.stream()
                .map(CompletableFuture::join)
                .mapToInt(Integer::intValue)
                .sum();
            
            return new ImportResult(totalSuccess, dataList.size() - totalSuccess);
        });
}
```

---

## 五、等待任一完成：anyOf

### 5.1 方法定义

```java
/**
 * 等待任一CompletableFuture完成
 * 
 * @param cfs 多个CompletableFuture
 * @return CompletableFuture<Object>
 */
public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)
```

### 5.2 使用场景

```java
// 场景：查询多个数据源，返回最快的结果
CompletableFuture<String> source1 = 
    CompletableFuture.supplyAsync(() -> querySource1());

CompletableFuture<String> source2 = 
    CompletableFuture.supplyAsync(() -> querySource2());

CompletableFuture<String> source3 = 
    CompletableFuture.supplyAsync(() -> querySource3());

CompletableFuture<Object> fastest = CompletableFuture.anyOf(
    source1, source2, source3
);

fastest.thenAccept(result -> {
    System.out.println("最快的结果: " + result);
});
```

### 5.3 类型安全的封装

```java
/**
 * 类型安全的anyOf
 */
@SafeVarargs
public static <T> CompletableFuture<T> anyOfTyped(
        CompletableFuture<T>... futures) {
    
    return CompletableFuture.anyOf(futures)
        .thenApply(obj -> (T) obj);
}

// 使用
CompletableFuture<String> result = anyOfTyped(
    CompletableFuture.supplyAsync(() -> "A"),
    CompletableFuture.supplyAsync(() -> "B"),
    CompletableFuture.supplyAsync(() -> "C")
);
```

### 5.4 实际示例

```java
/**
 * 超时降级
 */
public CompletableFuture<String> getDataWithFallback(String key) {
    // 主数据源
    CompletableFuture<String> primary = CompletableFuture.supplyAsync(() -> {
        return primaryDataSource.get(key);
    });
    
    // 超时Future
    CompletableFuture<String> timeout = CompletableFuture.supplyAsync(() -> {
        try {
            Thread.sleep(1000); // 1秒超时
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        throw new TimeoutException("Primary source timeout");
    });
    
    // 返回最快的结果
    return CompletableFuture.anyOf(primary, timeout)
        .thenApply(result -> (String) result)
        .exceptionally(ex -> {
            // 超时或异常，使用降级数据
            return fallbackDataSource.get(key);
        });
}
```

---

## 六、复杂组合示例

### 6.1 电商下单流程

```java
/**
 * 完整的下单流程
 */
public CompletableFuture<Order> placeOrder(OrderRequest request) {
    return CompletableFuture
        // 1. 验证用户
        .supplyAsync(() -> validateUser(request.getUserId()))
        
        // 2. 并行检查库存和计算价格
        .thenCompose(user -> {
            CompletableFuture<Boolean> stockCheck = 
                CompletableFuture.supplyAsync(() -> 
                    checkStock(request.getProductId(), request.getQuantity())
                );
            
            CompletableFuture<Double> priceCalc = 
                CompletableFuture.supplyAsync(() -> 
                    calculatePrice(request.getProductId(), request.getQuantity())
                );
            
            return stockCheck.thenCombine(priceCalc, (hasStock, price) -> {
                if (!hasStock) {
                    throw new RuntimeException("库存不足");
                }
                return new OrderContext(user, price);
            });
        })
        
        // 3. 创建订单
        .thenCompose(context -> 
            CompletableFuture.supplyAsync(() -> createOrder(context))
        )
        
        // 4. 并行执行：扣减库存 + 发送通知
        .thenCompose(order -> {
            CompletableFuture<Void> deductStock = 
                CompletableFuture.runAsync(() -> 
                    deductStock(order.getProductId(), order.getQuantity())
                );
            
            CompletableFuture<Void> sendNotification = 
                CompletableFuture.runAsync(() -> 
                    sendOrderNotification(order)
                );
            
            return CompletableFuture.allOf(deductStock, sendNotification)
                .thenApply(v -> order);
        })
        
        // 5. 异常处理
        .exceptionally(ex -> {
            log.error("订单创建失败", ex);
            throw new RuntimeException("订单创建失败: " + ex.getMessage());
        });
}
```

**流程图**：

```
验证用户
   ↓
┌──┴──┐
│并行 │
├─────┤
检查库存  计算价格
└──┬──┘
   ↓
创建订单
   ↓
┌──┴──┐
│并行 │
├─────┤
扣减库存  发送通知
└──┬──┘
   ↓
返回订单
```

### 6.2 聚合查询

```java
/**
 * 用户仪表盘数据聚合
 */
public CompletableFuture<Dashboard> getDashboard(String userId) {
    // 并行查询多个数据源
    CompletableFuture<UserProfile> profileFuture = 
        CompletableFuture.supplyAsync(() -> getUserProfile(userId));
    
    CompletableFuture<List<Order>> ordersFuture = 
        CompletableFuture.supplyAsync(() -> getRecentOrders(userId));
    
    CompletableFuture<Statistics> statsFuture = 
        CompletableFuture.supplyAsync(() -> getUserStatistics(userId));
    
    CompletableFuture<List<Notification>> notificationsFuture = 
        CompletableFuture.supplyAsync(() -> getNotifications(userId));
    
    // 等待所有查询完成
    return CompletableFuture.allOf(
        profileFuture, ordersFuture, statsFuture, notificationsFuture
    ).thenApply(v -> {
        return new Dashboard(
            profileFuture.join(),
            ordersFuture.join(),
            statsFuture.join(),
            notificationsFuture.join()
        );
    });
}
```

---

## 七、组合操作的最佳实践

### 7.1 选择合适的组合方式

```java
// 串行依赖：使用thenCompose
future1.thenCompose(result1 -> future2(result1))

// 并行独立：使用thenCombine
future1.thenCombine(future2, (r1, r2) -> merge(r1, r2))

// 批量并行：使用allOf
CompletableFuture.allOf(future1, future2, future3)

// 竞速：使用anyOf
CompletableFuture.anyOf(future1, future2, future3)
```

### 7.2 避免过度嵌套

```java
// ❌ 不好的做法：过度嵌套
CompletableFuture.supplyAsync(() -> step1())
    .thenCompose(r1 -> 
        CompletableFuture.supplyAsync(() -> step2(r1))
            .thenCompose(r2 -> 
                CompletableFuture.supplyAsync(() -> step3(r2))
            )
    );

// ✅ 好的做法：扁平化
CompletableFuture.supplyAsync(() -> step1())
    .thenCompose(r1 -> CompletableFuture.supplyAsync(() -> step2(r1)))
    .thenCompose(r2 -> CompletableFuture.supplyAsync(() -> step3(r2)));
```

### 7.3 合理使用线程池

```java
// 为不同类型的任务使用不同的线程池
ExecutorService ioExecutor = Executors.newFixedThreadPool(50);
ExecutorService cpuExecutor = Executors.newFixedThreadPool(
    Runtime.getRuntime().availableProcessors()
);

// IO密集型任务
CompletableFuture.supplyAsync(() -> queryDatabase(), ioExecutor)

// CPU密集型任务
CompletableFuture.supplyAsync(() -> complexCalculation(), cpuExecutor)
```

---

## 八、总结

### 8.1 组合方法总结

| 方法 | 用途 | 特点 |
|------|------|------|
| thenCompose | 串行组合 | 前一个完成后执行下一个 |
| thenCombine | 并行组合 | 两个都完成后合并结果 |
| allOf | 等待所有 | 所有完成后继续 |
| anyOf | 等待任一 | 任一完成后继续 |

### 8.2 使用场景

```
thenCompose：
✅ 步骤之间有依赖
✅ 需要前一步的结果

thenCombine：
✅ 两个独立任务
✅ 需要合并结果

allOf：
✅ 批量并行任务
✅ 需要等待所有完成

anyOf：
✅ 多个数据源
✅ 返回最快的结果
```

### 8.3 思考题

1. **thenCompose和thenApply有什么区别？**
2. **如何实现超时降级？**
3. **allOf返回的是什么类型？如何获取结果？**
4. **如何选择合适的组合方式？**

---

**下一章预告**：我们将学习CompletableFuture的异常处理和超时控制，构建健壮的异步应用。

---

**参考资料**：
- 《Java 8实战》第11章
- [CompletableFuture组合操作详解](https://www.baeldung.com/java-completablefuture)
