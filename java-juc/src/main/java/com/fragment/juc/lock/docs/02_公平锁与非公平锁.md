# 第二章：公平锁与非公平锁 - 性能与公平性的权衡

> **学习目标**：深入理解公平锁和非公平锁的原理、性能差异和选择策略

---

## 一、什么是公平锁和非公平锁？

### 1.1 定义

```
公平锁（Fair Lock）：
多个线程按照申请锁的顺序来获取锁（FIFO）。
先到先得，不允许插队。

非公平锁（Nonfair Lock）：
多个线程获取锁的顺序不是按照申请锁的顺序。
允许插队，可能导致某些线程饥饿。
```

### 1.2 图解

```
公平锁：

等待队列：[线程A] → [线程B] → [线程C]
                ↓
            锁持有者

释放锁后：
线程A获取锁（FIFO）

特点：
✅ 严格按顺序
❌ 性能较低


非公平锁：

等待队列：[线程A] → [线程B] → [线程C]
                ↓
            锁持有者
                ↑
            新线程D（插队）

释放锁后：
线程D可能先获取锁（插队成功）
或线程A获取锁（插队失败）

特点：
✅ 性能较高
❌ 可能不公平
```

---

## 二、ReentrantLock的公平性

### 2.1 构造函数

```java
// 非公平锁（默认）
ReentrantLock lock = new ReentrantLock();
// 等价于
ReentrantLock lock = new ReentrantLock(false);

// 公平锁
ReentrantLock lock = new ReentrantLock(true);
```

### 2.2 公平锁的实现原理

```java
// 公平锁的lock()实现（简化版）

public void lock() {
    acquire(1);
}

protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    if (c == 0) {
        // 关键：检查队列中是否有等待的线程
        if (!hasQueuedPredecessors() && // 公平性检查
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        // 重入
        int nextc = c + acquires;
        setState(nextc);
        return true;
    }
    return false;
}

// 检查是否有前驱节点
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

### 2.3 非公平锁的实现原理

```java
// 非公平锁的lock()实现（简化版）

public void lock() {
    // 关键：直接尝试CAS获取锁（插队）
    if (compareAndSetState(0, 1)) {
        setExclusiveOwnerThread(Thread.currentThread());
    } else {
        acquire(1);
    }
}

protected final boolean tryAcquire(int acquires) {
    return nonfairTryAcquire(acquires);
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    if (c == 0) {
        // 关键：不检查队列，直接尝试获取（插队）
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        // 重入
        int nextc = c + acquires;
        setState(nextc);
        return true;
    }
    return false;
}
```

---

## 三、性能对比

### 3.1 性能测试

```java
public class FairnessPerformanceTest {
    private static final int THREAD_COUNT = 10;
    private static final int ITERATIONS = 100000;
    
    // 测试非公平锁
    public static void testNonfairLock() {
        ReentrantLock lock = new ReentrantLock(false);
        long startTime = System.currentTimeMillis();
        
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < ITERATIONS; j++) {
                    lock.lock();
                    try {
                        // 临界区
                    } finally {
                        lock.unlock();
                    }
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        System.out.println("非公平锁耗时：" + (endTime - startTime) + "ms");
    }
    
    // 测试公平锁
    public static void testFairLock() {
        ReentrantLock lock = new ReentrantLock(true);
        long startTime = System.currentTimeMillis();
        
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < ITERATIONS; j++) {
                    lock.lock();
                    try {
                        // 临界区
                    } finally {
                        lock.unlock();
                    }
                }
                latch.countDown();
            }).start();
        }
        
        latch.await();
        long endTime = System.currentTimeMillis();
        System.out.println("公平锁耗时：" + (endTime - startTime) + "ms");
    }
}

// 性能结果（10个线程，每个线程10万次操作）：
// 非公平锁：约500ms
// 公平锁：  约2000ms

// 结论：
// 非公平锁比公平锁快约4倍
```

### 3.2 为什么非公平锁更快？

```
原因1：减少线程切换
非公平锁：
- 新线程可以直接获取锁
- 避免了线程挂起和唤醒
- 减少了上下文切换

公平锁：
- 新线程必须排队
- 需要挂起和唤醒线程
- 增加了上下文切换

原因2：提高吞吐量
非公平锁：
- 锁释放后，新线程可能立即获取
- 减少了锁的空闲时间
- 提高了系统吞吐量

公平锁：
- 锁释放后，需要唤醒队列中的线程
- 增加了锁的空闲时间
- 降低了系统吞吐量

原因3：缓存局部性
非公平锁：
- 刚释放锁的线程可能再次获取
- CPU缓存仍然有效
- 提高了缓存命中率

公平锁：
- 严格按顺序，缓存可能失效
- 降低了缓存命中率
```

---

## 四、公平性分析

### 4.1 公平锁的优势

```
✅ 优势：

1. 避免饥饿：
   - 每个线程都能获取锁
   - 不会有线程永远等待

2. 可预测性：
   - 严格按顺序
   - 行为可预测

3. 适合特定场景：
   - 需要严格顺序的场景
   - 对公平性要求高的场景
```

### 4.2 非公平锁的优势

```
✅ 优势：

1. 性能高：
   - 减少线程切换
   - 提高吞吐量

2. 适合大多数场景：
   - 大多数场景不需要严格公平
   - 性能优先

3. 默认选择：
   - ReentrantLock默认非公平
   - synchronized也是非公平
```

### 4.3 饥饿问题

```java
// 非公平锁可能导致饥饿

public class StarvationExample {
    private final ReentrantLock lock = new ReentrantLock(false);
    
    public void doWork() {
        lock.lock();
        try {
            // 短时间的工作
            Thread.sleep(1);
        } finally {
            lock.unlock();
        }
    }
}

// 场景：
// 线程A一直在循环调用doWork()
// 线程B也想调用doWork()

// 非公平锁：
// 线程A可能一直获取锁（插队成功）
// 线程B可能一直等待（饥饿）

// 公平锁：
// 线程A和线程B轮流获取锁
// 不会有饥饿问题
```

---

## 五、选择策略

### 5.1 使用公平锁的场景

```
✅ 适合公平锁：

1. 需要严格顺序：
   - 任务调度系统
   - 票务系统
   - 排队系统

2. 避免饥饿：
   - 长时间运行的任务
   - 对响应时间敏感的任务

3. 公平性优先：
   - 对公平性要求高的场景
   - 性能不是主要考虑因素

示例：
// 票务系统
ReentrantLock lock = new ReentrantLock(true);

public Ticket buyTicket() {
    lock.lock();
    try {
        // 按顺序购票
        return getNextTicket();
    } finally {
        lock.unlock();
    }
}
```

### 5.2 使用非公平锁的场景

```
✅ 适合非公平锁：

1. 性能优先：
   - 高并发场景
   - 对性能要求高的场景

2. 短时间持锁：
   - 临界区很小
   - 持锁时间很短

3. 大多数场景：
   - 不需要严格公平
   - 默认选择

示例：
// 计数器
ReentrantLock lock = new ReentrantLock(false);

public void increment() {
    lock.lock();
    try {
        count++; // 很短的临界区
    } finally {
        lock.unlock();
    }
}
```

### 5.3 选择建议

```
决策树：

需要严格顺序？
├─ 是 → 使用公平锁
└─ 否 → 继续

对性能要求高？
├─ 是 → 使用非公平锁
└─ 否 → 继续

可能出现饥饿？
├─ 是 → 使用公平锁
└─ 否 → 使用非公平锁（默认）

总结：
- 默认使用非公平锁
- 特殊场景使用公平锁
- 性能测试验证选择
```

---

## 六、实战案例

### 6.1 任务调度器（公平锁）

```java
public class FairTaskScheduler {
    private final ReentrantLock lock = new ReentrantLock(true);
    private final Queue<Task> taskQueue = new LinkedList<>();
    
    // 提交任务
    public void submitTask(Task task) {
        lock.lock();
        try {
            taskQueue.offer(task);
        } finally {
            lock.unlock();
        }
    }
    
    // 执行任务（按提交顺序）
    public void executeTasks() {
        while (true) {
            Task task = null;
            lock.lock();
            try {
                task = taskQueue.poll();
            } finally {
                lock.unlock();
            }
            
            if (task != null) {
                task.execute();
            } else {
                break;
            }
        }
    }
}

// 使用公平锁保证任务按提交顺序执行
```

### 6.2 高性能计数器（非公平锁）

```java
public class HighPerformanceCounter {
    private final ReentrantLock lock = new ReentrantLock(false);
    private long count = 0;
    
    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
    
    public long getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}

// 使用非公平锁提高性能
```

### 6.3 混合策略

```java
public class HybridLockStrategy {
    private final ReentrantLock fairLock = new ReentrantLock(true);
    private final ReentrantLock nonfairLock = new ReentrantLock(false);
    
    // 重要操作使用公平锁
    public void importantOperation() {
        fairLock.lock();
        try {
            // 重要操作
        } finally {
            fairLock.unlock();
        }
    }
    
    // 普通操作使用非公平锁
    public void normalOperation() {
        nonfairLock.lock();
        try {
            // 普通操作
        } finally {
            nonfairLock.unlock();
        }
    }
}

// 根据操作的重要性选择不同的锁
```

---

## 七、总结

### 7.1 核心要点

1. **公平锁**：按FIFO顺序获取锁，避免饥饿，但性能较低
2. **非公平锁**：允许插队，性能高，但可能饥饿
3. **性能差异**：非公平锁比公平锁快约2-4倍
4. **选择策略**：默认非公平，特殊场景公平
5. **权衡**：公平性 vs 性能

### 7.2 对比表

| 特性 | 公平锁 | 非公平锁 |
|------|--------|----------|
| **顺序** | FIFO | 允许插队 |
| **饥饿** | 不会 | 可能 |
| **性能** | 低 | 高 |
| **线程切换** | 多 | 少 |
| **吞吐量** | 低 | 高 |
| **适用场景** | 需要严格顺序 | 大多数场景 |
| **默认选择** | ❌ | ✅ |

### 7.3 思考题

1. **什么是公平锁和非公平锁？**
2. **为什么非公平锁性能更高？**
3. **什么时候应该使用公平锁？**
4. **如何避免非公平锁的饥饿问题？**

---

**下一章预告**：我们将学习Condition条件队列的使用和原理。

---

**参考资料**：
- 《Java并发编程实战》第13章
- 《Java并发编程的艺术》第5章
- ReentrantLock源码分析
