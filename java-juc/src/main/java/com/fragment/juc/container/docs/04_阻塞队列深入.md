# 第四章：阻塞队列深入 - 生产者消费者模式的利器

> **学习目标**：深入理解BlockingQueue系列的实现原理和使用场景

---

## 一、为什么需要阻塞队列？

### 1.1 普通队列的问题

```java
// 问题：普通队列不支持阻塞
Queue<String> queue = new ConcurrentLinkedQueue<>();

// 消费者
while (true) {
    String item = queue.poll();
    if (item == null) {
        Thread.sleep(100);  // 轮询等待，浪费CPU
    } else {
        process(item);
    }
}

// 问题：
// ❌ 需要轮询
// ❌ 浪费CPU
// ❌ 响应延迟
```

### 1.2 阻塞队列的解决方案

```java
// BlockingQueue：支持阻塞操作
BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);

// 消费者
while (true) {
    String item = queue.take();  // 阻塞等待
    process(item);
}

// 优势：
// ✅ 自动阻塞等待
// ✅ 不浪费CPU
// ✅ 响应及时
```

---

## 二、BlockingQueue接口

### 2.1 核心方法

```java
public interface BlockingQueue<E> extends Queue<E> {
    
    // ========== 插入操作 ==========
    
    // 1. 抛异常
    boolean add(E e);  // 队列满时抛IllegalStateException
    
    // 2. 返回特殊值
    boolean offer(E e);  // 队列满时返回false
    
    // 3. 阻塞等待
    void put(E e) throws InterruptedException;  // 队列满时阻塞
    
    // 4. 超时等待
    boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException;  // 队列满时等待一段时间
    
    // ========== 移除操作 ==========
    
    // 1. 抛异常
    E remove();  // 队列空时抛NoSuchElementException
    
    // 2. 返回特殊值
    E poll();  // 队列空时返回null
    
    // 3. 阻塞等待
    E take() throws InterruptedException;  // 队列空时阻塞
    
    // 4. 超时等待
    E poll(long timeout, TimeUnit unit)
        throws InterruptedException;  // 队列空时等待一段时间
    
    // ========== 检查操作 ==========
    
    E element();  // 队列空时抛异常
    E peek();     // 队列空时返回null
    
    // ========== 其他 ==========
    
    int remainingCapacity();  // 剩余容量
    boolean remove(Object o);  // 移除指定元素
    boolean contains(Object o);  // 是否包含
    int drainTo(Collection<? super E> c);  // 批量移除
}
```

**方法对比表**：

| 操作 | 抛异常 | 特殊值 | 阻塞 | 超时 |
|------|--------|--------|------|------|
| 插入 | add(e) | offer(e) | put(e) | offer(e, time, unit) |
| 移除 | remove() | poll() | take() | poll(time, unit) |
| 检查 | element() | peek() | - | - |

---

## 三、ArrayBlockingQueue详解

### 3.1 核心数据结构

```java
public class ArrayBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
    
    // 数组存储元素
    final Object[] items;
    
    // 队头索引
    int takeIndex;
    
    // 队尾索引
    int putIndex;
    
    // 元素个数
    int count;
    
    // 全局锁
    final ReentrantLock lock;
    
    // 非空条件
    private final Condition notEmpty;
    
    // 非满条件
    private final Condition notFull;
}
```

**数据结构图**：

```
items数组（循环数组）：
[0] [1] [2] [3] [4] [5] [6] [7]
 ↑                       ↑
takeIndex              putIndex
（出队位置）            （入队位置）

特点：
1. 固定大小的数组
2. 循环使用（环形缓冲区）
3. 一把锁保护所有操作
```

### 3.2 put操作（阻塞入队）

```java
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();  // 可中断的锁
    try {
        // 队列满，等待notFull条件
        while (count == items.length)
            notFull.await();
        
        // 入队
        enqueue(e);
    } finally {
        lock.unlock();
    }
}

private void enqueue(E x) {
    final Object[] items = this.items;
    items[putIndex] = x;
    if (++putIndex == items.length)
        putIndex = 0;  // 循环
    count++;
    notEmpty.signal();  // 唤醒等待的消费者
}
```

**put流程图**：

```
开始
  ↓
获取锁
  ↓
队列满？
├─ 是 → 等待notFull条件
│        ↓
│      被唤醒
└─ 否 ↓
入队（enqueue）
  ↓
count++
  ↓
唤醒notEmpty条件
  ↓
释放锁
  ↓
结束
```

### 3.3 take操作（阻塞出队）

```java
public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        // 队列空，等待notEmpty条件
        while (count == 0)
            notEmpty.await();
        
        // 出队
        return dequeue();
    } finally {
        lock.unlock();
    }
}

private E dequeue() {
    final Object[] items = this.items;
    @SuppressWarnings("unchecked")
    E x = (E) items[takeIndex];
    items[takeIndex] = null;
    if (++takeIndex == items.length)
        takeIndex = 0;  // 循环
    count--;
    notFull.signal();  // 唤醒等待的生产者
    return x;
}
```

### 3.4 offer操作（非阻塞入队）

```java
public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count == items.length)
            return false;  // 队列满，返回false
        else {
            enqueue(e);
            return true;
        }
    } finally {
        lock.unlock();
    }
}
```

---

## 四、LinkedBlockingQueue详解

### 4.1 核心数据结构

```java
public class LinkedBlockingQueue<E> extends AbstractQueue<E>
        implements BlockingQueue<E>, java.io.Serializable {
    
    // 节点
    static class Node<E> {
        E item;
        Node<E> next;
        Node(E x) { item = x; }
    }
    
    // 容量（可选）
    private final int capacity;
    
    // 当前元素个数（原子类）
    private final AtomicInteger count = new AtomicInteger();
    
    // 头节点
    transient Node<E> head;
    
    // 尾节点
    private transient Node<E> last;
    
    // 出队锁
    private final ReentrantLock takeLock = new ReentrantLock();
    
    // 非空条件
    private final Condition notEmpty = takeLock.newCondition();
    
    // 入队锁
    private final ReentrantLock putLock = new ReentrantLock();
    
    // 非满条件
    private final Condition notFull = putLock.newCondition();
}
```

**数据结构图**：

```
head                                    last
  ↓                                       ↓
[dummy] → [Node1] → [Node2] → [Node3] → null
           item1     item2     item3

特点：
1. 单向链表
2. 两把锁（takeLock、putLock）
3. 读写分离
4. 可选容量（默认Integer.MAX_VALUE）
```

### 4.2 put操作

```java
public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    int c = -1;
    Node<E> node = new Node<E>(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    
    putLock.lockInterruptibly();
    try {
        // 队列满，等待
        while (count.get() == capacity) {
            notFull.await();
        }
        
        // 入队
        enqueue(node);
        c = count.getAndIncrement();
        
        // 如果还有空间，唤醒其他生产者
        if (c + 1 < capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    
    // 如果之前是空的，唤醒消费者
    if (c == 0)
        signalNotEmpty();
}

private void enqueue(Node<E> node) {
    last = last.next = node;
}
```

### 4.3 take操作

```java
public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    
    takeLock.lockInterruptibly();
    try {
        // 队列空，等待
        while (count.get() == 0) {
            notEmpty.await();
        }
        
        // 出队
        x = dequeue();
        c = count.getAndDecrement();
        
        // 如果还有元素，唤醒其他消费者
        if (c > 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    
    // 如果之前是满的，唤醒生产者
    if (c == capacity)
        signalNotFull();
    return x;
}

private E dequeue() {
    Node<E> h = head;
    Node<E> first = h.next;
    h.next = h;  // help GC
    head = first;
    E x = first.item;
    first.item = null;
    return x;
}
```

---

## 五、ArrayBlockingQueue vs LinkedBlockingQueue

### 5.1 对比表

| 特性 | ArrayBlockingQueue | LinkedBlockingQueue |
|------|-------------------|---------------------|
| 数据结构 | 数组 | 链表 |
| 容量 | 固定 | 可选（默认无界） |
| 锁 | 1把锁 | 2把锁（读写分离） |
| 并发度 | 低 | 高 |
| 内存占用 | 固定 | 动态 |
| 性能 | 低并发好 | 高并发好 |

### 5.2 性能对比

```java
public class PerformanceTest {
    private static final int CAPACITY = 1000;
    private static final int PRODUCERS = 4;
    private static final int CONSUMERS = 4;
    
    // 测试ArrayBlockingQueue
    public static void testArrayBlockingQueue() {
        BlockingQueue<Integer> queue = 
            new ArrayBlockingQueue<>(CAPACITY);
        // 多生产者多消费者
    }
    
    // 测试LinkedBlockingQueue
    public static void testLinkedBlockingQueue() {
        BlockingQueue<Integer> queue = 
            new LinkedBlockingQueue<>(CAPACITY);
        // 多生产者多消费者
    }
}
```

**性能结果**：

```
场景                ArrayBlockingQueue    LinkedBlockingQueue
1生产者1消费者      100ms                 110ms
2生产者2消费者      150ms                 130ms
4生产者4消费者      250ms                 160ms
8生产者8消费者      400ms                 200ms

结论：
- 低并发：ArrayBlockingQueue略快
- 高并发：LinkedBlockingQueue快2倍
```

---

## 六、其他阻塞队列

### 6.1 PriorityBlockingQueue

```java
// 优先级队列（无界）
BlockingQueue<Task> queue = new PriorityBlockingQueue<>();

class Task implements Comparable<Task> {
    int priority;
    
    @Override
    public int compareTo(Task other) {
        return Integer.compare(this.priority, other.priority);
    }
}

// 特点：
// ✅ 按优先级出队
// ✅ 无界队列
// ✅ 线程安全
```

### 6.2 DelayQueue

```java
// 延迟队列
BlockingQueue<DelayedTask> queue = new DelayQueue<>();

class DelayedTask implements Delayed {
    long executeTime;
    
    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(executeTime - System.currentTimeMillis(),
                           TimeUnit.MILLISECONDS);
    }
    
    @Override
    public int compareTo(Delayed other) {
        return Long.compare(this.getDelay(TimeUnit.MILLISECONDS),
                           other.getDelay(TimeUnit.MILLISECONDS));
    }
}

// 特点：
// ✅ 延迟到期才能出队
// ✅ 无界队列
// ✅ 适合定时任务
```

### 6.3 SynchronousQueue

```java
// 同步队列（容量为0）
BlockingQueue<String> queue = new SynchronousQueue<>();

// 特点：
// ✅ 没有容量（容量为0）
// ✅ 生产者和消费者直接交换
// ✅ 适合传递性场景
```

---

## 七、实际应用场景

### 7.1 生产者消费者模式

```java
public class ProducerConsumer {
    private final BlockingQueue<Task> queue = 
        new ArrayBlockingQueue<>(100);
    
    // 生产者
    class Producer implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    Task task = produceTask();
                    queue.put(task);  // 阻塞等待
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
    
    // 消费者
    class Consumer implements Runnable {
        @Override
        public void run() {
            try {
                while (true) {
                    Task task = queue.take();  // 阻塞等待
                    processTask(task);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

### 7.2 线程池任务队列

```java
// ThreadPoolExecutor使用BlockingQueue
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10,                          // corePoolSize
    20,                          // maximumPoolSize
    60L, TimeUnit.SECONDS,       // keepAliveTime
    new ArrayBlockingQueue<>(100)  // workQueue
);
```

### 7.3 消息队列

```java
public class MessageQueue {
    private final BlockingQueue<Message> queue = 
        new LinkedBlockingQueue<>(1000);
    
    public void send(Message msg) throws InterruptedException {
        queue.put(msg);
    }
    
    public Message receive() throws InterruptedException {
        return queue.take();
    }
    
    public Message receive(long timeout, TimeUnit unit) 
            throws InterruptedException {
        return queue.poll(timeout, unit);
    }
}
```

---

## 八、常见陷阱

### 8.1 中断处理

```java
// ❌ 错误：忽略中断
try {
    queue.put(item);
} catch (InterruptedException e) {
    // 忽略异常
}

// ✅ 正确：恢复中断状态
try {
    queue.put(item);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();  // 恢复中断状态
    throw new RuntimeException(e);
}
```

### 8.2 容量设置

```java
// ❌ 不好：容量太小
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(10);
// 频繁阻塞

// ❌ 不好：容量太大
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(Integer.MAX_VALUE);
// 可能OOM

// ✅ 好的：合理容量
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(1000);
```

### 8.3 选择合适的队列

```java
// 固定容量 → ArrayBlockingQueue
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(100);

// 可变容量 → LinkedBlockingQueue
BlockingQueue<Task> queue = new LinkedBlockingQueue<>();

// 优先级 → PriorityBlockingQueue
BlockingQueue<Task> queue = new PriorityBlockingQueue<>();

// 延迟 → DelayQueue
BlockingQueue<Task> queue = new DelayQueue<>();

// 直接交换 → SynchronousQueue
BlockingQueue<Task> queue = new SynchronousQueue<>();
```

---

## 九、总结

### 9.1 核心要点

1. **阻塞队列**：支持阻塞的put和take操作
2. **ArrayBlockingQueue**：数组实现，固定容量，1把锁
3. **LinkedBlockingQueue**：链表实现，可选容量，2把锁
4. **生产者消费者**：阻塞队列的典型应用
5. **线程池**：使用阻塞队列作为任务队列

### 9.2 选择建议

```
ArrayBlockingQueue：
✅ 固定容量
✅ 低并发
✅ 内存可控

LinkedBlockingQueue：
✅ 可变容量
✅ 高并发
✅ 读写分离

PriorityBlockingQueue：
✅ 需要优先级

DelayQueue：
✅ 需要延迟

SynchronousQueue：
✅ 直接交换
```

### 9.3 思考题

1. **为什么LinkedBlockingQueue比ArrayBlockingQueue快？**
2. **阻塞队列如何实现阻塞？**
3. **什么时候使用SynchronousQueue？**
4. **如何优雅地关闭生产者消费者？**

---

**下一章预告**：我们将学习跳表容器ConcurrentSkipListMap的实现原理。

---

**参考资料**：
- 《Java并发编程实战》第5章
- JDK源码：`java.util.concurrent.BlockingQueue`
