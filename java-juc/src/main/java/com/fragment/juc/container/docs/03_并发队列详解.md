# 第三章：并发队列详解 - 无锁队列的实现

> **学习目标**：深入理解ConcurrentLinkedQueue的无锁实现原理

---

## 一、为什么需要并发队列？

### 1.1 普通队列的线程安全问题

```java
// 问题：LinkedList在多线程下不安全
Queue<String> queue = new LinkedList<>();

// 线程1：入队
queue.offer("item1");

// 线程2：出队
queue.poll();

// 问题：
// 1. 数据丢失
// 2. 节点断裂
// 3. 死循环
```

### 1.2 同步队列的性能问题

```java
// 使用synchronized包装
Queue<String> queue = new LinkedList<>();

public synchronized boolean offer(E e) {
    return queue.offer(e);
}

public synchronized E poll() {
    return queue.poll();
}

// 问题：
// ❌ 锁粒度大
// ❌ 读写互斥
// ❌ 性能差
```

### 1.3 ConcurrentLinkedQueue的解决方案

```java
// 无锁队列
Queue<String> queue = new ConcurrentLinkedQueue<>();

// 优势：
// ✅ 无锁算法（CAS）
// ✅ 高并发性能好
// ✅ 无界队列
// ✅ 线程安全
```

---

## 二、ConcurrentLinkedQueue的设计

### 2.1 核心数据结构

```java
public class ConcurrentLinkedQueue<E> extends AbstractQueue<E>
        implements Queue<E>, java.io.Serializable {
    
    // 头节点
    private transient volatile Node<E> head;
    
    // 尾节点
    private transient volatile Node<E> tail;
    
    // 节点
    private static class Node<E> {
        volatile E item;
        volatile Node<E> next;
        
        Node(E item) {
            UNSAFE.putObject(this, itemOffset, item);
        }
        
        boolean casItem(E cmp, E val) {
            return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
        }
        
        void lazySetNext(Node<E> val) {
            UNSAFE.putOrderedObject(this, nextOffset, val);
        }
        
        boolean casNext(Node<E> cmp, Node<E> val) {
            return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
        }
    }
}
```

**数据结构图**：

```
head                                    tail
  ↓                                       ↓
[Node1] → [Node2] → [Node3] → [Node4] → null
  item      item      item      item
  
特点：
1. 单向链表
2. head和tail都是volatile
3. 使用CAS更新
```

### 2.2 松弛阈值（Slack）

```java
// 不是每次操作都更新head/tail
// 而是允许一定的"松弛"

// 入队：
// tail不一定指向最后一个节点
// 可能落后1-2个节点

// 出队：
// head不一定指向第一个节点
// 可能落后1-2个节点

// 优势：
// - 减少CAS操作
// - 提升性能
```

---

## 三、offer操作（入队）

### 3.1 源码分析

```java
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);
    
    for (Node<E> t = tail, p = t;;) {
        Node<E> q = p.next;
        
        // 情况1：p是最后一个节点
        if (q == null) {
            // CAS设置p.next = newNode
            if (p.casNext(null, newNode)) {
                // 成功后，如果p != t，更新tail
                if (p != t)
                    casTail(t, newNode);
                return true;
            }
        }
        // 情况2：p已经出队
        else if (p == q)
            p = (t != (t = tail)) ? t : head;
        // 情况3：继续向后找
        else
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```

### 3.2 入队流程图

```
开始
  ↓
创建新节点
  ↓
获取tail和p（p = tail）
  ↓
获取p.next
  ↓
p.next == null？
├─ 是 → CAS设置p.next = newNode
│        ├─ 成功 → p != tail？
│        │         ├─ 是 → CAS更新tail
│        │         └─ 否 → 返回
│        └─ 失败 → 重试
└─ 否 → p已出队？
         ├─ 是 → 重新定位
         └─ 否 → p = p.next，继续

特点：
1. 自旋重试
2. 松弛更新tail
3. 无锁算法
```

### 3.3 松弛阈值示例

```java
// 初始状态
head → [Node1] → null
tail ↗

// 第1次offer("item2")
head → [Node1] → [Node2] → null
tail ↗            ↑
                  新节点
// tail没有更新（松弛）

// 第2次offer("item3")
head → [Node1] → [Node2] → [Node3] → null
tail ↗                      ↑
                            新节点
// tail更新到Node3

// 优势：
// - 减少tail的CAS操作
// - 提升性能
```

---

## 四、poll操作（出队）

### 4.1 源码分析

```java
public E poll() {
    restartFromHead:
    for (;;) {
        for (Node<E> h = head, p = h, q;;) {
            E item = p.item;
            
            // 情况1：p有元素，CAS设置为null
            if (item != null && p.casItem(item, null)) {
                // 如果p != h，更新head
                if (p != h)
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            // 情况2：p已经是最后一个节点
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            // 情况3：p已经出队
            else if (p == q)
                continue restartFromHead;
            // 情况4：继续向后找
            else
                p = q;
        }
    }
}

final void updateHead(Node<E> h, Node<E> p) {
    if (h != p && casHead(h, p))
        h.lazySetNext(h);  // 自引用，帮助GC
}
```

### 4.2 出队流程图

```
开始
  ↓
获取head和p（p = head）
  ↓
获取p.item
  ↓
item != null？
├─ 是 → CAS设置item = null
│        ├─ 成功 → p != head？
│        │         ├─ 是 → 更新head
│        │         └─ 否 → 返回item
│        └─ 失败 → 重试
└─ 否 → p.next == null？
         ├─ 是 → 队列为空，返回null
         └─ 否 → p = p.next，继续

特点：
1. 自旋重试
2. 松弛更新head
3. 自引用帮助GC
```

---

## 五、size操作

### 5.1 为什么size()很慢？

```java
public int size() {
    int count = 0;
    for (Node<E> p = first(); p != null; p = succ(p))
        if (p.item != null)
            if (++count == Integer.MAX_VALUE)
                break;
    return count;
}

// 问题：
// 1. 需要遍历整个链表
// 2. 时间复杂度O(n)
// 3. 结果可能不准确（弱一致性）
```

### 5.2 替代方案

```java
// ❌ 不好：频繁调用size()
if (queue.size() > 0) {
    queue.poll();
}

// ✅ 好的：使用isEmpty()
if (!queue.isEmpty()) {
    queue.poll();
}

// ✅ 更好：直接poll
E item = queue.poll();
if (item != null) {
    // 处理
}

// ✅ 最好：维护计数器
AtomicInteger counter = new AtomicInteger(0);
queue.offer(item);
counter.incrementAndGet();
```

---

## 六、内存管理

### 6.1 自引用（Self-Linking）

```java
// 出队后的节点
final void updateHead(Node<E> h, Node<E> p) {
    if (h != p && casHead(h, p))
        h.lazySetNext(h);  // h.next = h（自引用）
}

// 为什么要自引用？
// 1. 标记节点已出队
// 2. 帮助GC回收
// 3. 避免遍历已出队节点
```

**自引用示意图**：

```
出队前：
head → [Node1] → [Node2] → [Node3] → null
        item=1    item=2    item=3

出队后：
head → [Node2] → [Node3] → null
        ↑         item=3
[Node1] ─┘
 next指向自己（自引用）

优势：
1. Node1可以被GC回收
2. 遍历时跳过Node1
```

---

## 七、性能分析

### 7.1 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|----------|------|
| offer() | O(1) | 无锁，CAS操作 |
| poll() | O(1) | 无锁，CAS操作 |
| peek() | O(1) | 只读，无锁 |
| size() | O(n) | 需要遍历 |
| isEmpty() | O(1) | 检查head |

### 7.2 性能对比

```java
public class PerformanceTest {
    private static final int THREAD_COUNT = 10;
    private static final int OPERATIONS = 1000000;
    
    // 测试1：ConcurrentLinkedQueue
    public static void testConcurrentQueue() {
        Queue<Integer> queue = new ConcurrentLinkedQueue<>();
        // 多线程入队出队
    }
    
    // 测试2：synchronized包装的LinkedList
    public static void testSynchronizedQueue() {
        Queue<Integer> queue = new LinkedList<>();
        // 多线程入队出队（加锁）
    }
}
```

**性能结果**：

```
线程数    ConcurrentLinkedQueue    Synchronized
1         100ms                    110ms
2         120ms                    200ms
4         140ms                    400ms
8         160ms                    800ms
16        180ms                    1600ms

结论：
- 低并发：性能接近
- 高并发：ConcurrentLinkedQueue快10倍
```

---

## 八、适用场景

### 8.1 适合的场景

```java
// ✅ 场景1：任务队列
public class TaskExecutor {
    private final Queue<Task> taskQueue = new ConcurrentLinkedQueue<>();
    
    public void submitTask(Task task) {
        taskQueue.offer(task);
    }
    
    public Task getTask() {
        return taskQueue.poll();
    }
}

// ✅ 场景2：消息队列
public class MessageQueue {
    private final Queue<Message> queue = new ConcurrentLinkedQueue<>();
    
    public void send(Message msg) {
        queue.offer(msg);
    }
    
    public Message receive() {
        return queue.poll();
    }
}

// ✅ 场景3：缓冲区
public class Buffer {
    private final Queue<Data> buffer = new ConcurrentLinkedQueue<>();
    
    public void write(Data data) {
        buffer.offer(data);
    }
    
    public Data read() {
        return buffer.poll();
    }
}
```

### 8.2 不适合的场景

```java
// ❌ 场景1：需要阻塞等待
// ConcurrentLinkedQueue不支持阻塞
// 应该使用BlockingQueue

// ❌ 场景2：需要有界队列
// ConcurrentLinkedQueue是无界的
// 应该使用ArrayBlockingQueue

// ❌ 场景3：频繁调用size()
// size()性能差
// 应该维护计数器
```

---

## 九、常见陷阱

### 9.1 size()性能问题

```java
// ❌ 错误：频繁调用size()
while (queue.size() > 0) {
    queue.poll();
}

// ✅ 正确：直接poll
while (true) {
    E item = queue.poll();
    if (item == null) break;
    // 处理item
}
```

### 9.2 不支持null

```java
// ❌ 错误：添加null
queue.offer(null);  // NullPointerException

// 原因：
// - null用于标记队列为空
// - poll()返回null表示队列空
```

### 9.3 弱一致性迭代器

```java
// 迭代器是弱一致性的
Iterator<String> it = queue.iterator();
while (it.hasNext()) {
    String item = it.next();
    // 可能看不到最新添加的元素
}
```

---

## 十、总结

### 10.1 核心要点

1. **无锁算法**：使用CAS实现
2. **松弛阈值**：减少CAS操作
3. **自引用**：帮助GC回收
4. **弱一致性**：size()和迭代器
5. **高性能**：高并发下性能好

### 10.2 优缺点

```
优势：
✅ 无锁，高并发性能好
✅ 无界队列
✅ 线程安全

劣势：
❌ size()性能差
❌ 不支持阻塞
❌ 弱一致性
```

### 10.3 思考题

1. **为什么要使用松弛阈值？**
2. **自引用如何帮助GC？**
3. **为什么size()性能差？**
4. **什么时候不应该使用ConcurrentLinkedQueue？**

---

**下一章预告**：我们将学习阻塞队列BlockingQueue的实现原理。

---

**参考资料**：
- 《Java并发编程实战》第5章
- JDK源码：`java.util.concurrent.ConcurrentLinkedQueue`
- Michael & Scott的论文：Simple, Fast, and Practical Non-Blocking Queue
