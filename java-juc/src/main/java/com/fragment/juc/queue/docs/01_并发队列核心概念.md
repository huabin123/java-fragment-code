# 并发队列核心概念

> **本章目标**：从问题驱动的角度理解为什么需要并发队列，以及并发队列的分类和核心设计思想

---

## 一、为什么需要并发队列？

### 问题1：传统队列在多线程环境下的问题是什么？

#### 1.1 ArrayList/LinkedList的线程安全问题

**场景模拟**：多个线程同时操作普通队列

```java
// ❌ 线程不安全的代码
List<String> queue = new ArrayList<>();

// 线程1：添加元素
new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        queue.add("item-" + i);
    }
}).start();

// 线程2：移除元素
new Thread(() -> {
    for (int i = 0; i < 1000; i++) {
        if (!queue.isEmpty()) {
            queue.remove(0);
        }
    }
}).start();
```

**可能出现的问题**：
1. **数据丢失**：两个线程同时add，可能覆盖
2. **IndexOutOfBoundsException**：判断非空后，元素被其他线程移除
3. **ConcurrentModificationException**：迭代时被修改
4. **数据不一致**：size()返回值不准确

#### 1.2 问题根源分析

```
时间线：线程1和线程2同时操作ArrayList

T1: 线程1读取size=5
T2: 线程2读取size=5
T3: 线程1在index=5位置写入元素A
T4: 线程2在index=5位置写入元素B  ← 元素A被覆盖！
T5: size更新为6（实际应该是7）
```

**核心问题**：
- ❌ **非原子操作**：读取-修改-写入不是原子的
- ❌ **无可见性保证**：一个线程的修改其他线程可能看不到
- ❌ **无happens-before关系**：操作顺序无法保证

---

### 问题2：Collections.synchronizedList为什么不够用？

#### 2.1 synchronizedList的实现

```java
// JDK源码
public static <T> List<T> synchronizedList(List<T> list) {
    return new SynchronizedList<>(list);
}

static class SynchronizedList<E> extends SynchronizedCollection<E> {
    public E get(int index) {
        synchronized (mutex) { return list.get(index); }
    }
    public E set(int index, E element) {
        synchronized (mutex) { return list.set(index, element); }
    }
    public void add(int index, E element) {
        synchronized (mutex) { list.add(index, element); }
    }
    public E remove(int index) {
        synchronized (mutex) { return list.remove(index); }
    }
}
```

#### 2.2 存在的问题

**问题1：粗粒度锁，性能差**
```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());

// 所有操作都竞争同一把锁
syncList.add("A");  // 获取mutex锁
syncList.get(0);    // 获取mutex锁（与add互斥）
syncList.remove(0); // 获取mutex锁（与get互斥）
```

**性能瓶颈**：
- 读操作和写操作互斥（实际上读读可以并发）
- 队头操作和队尾操作互斥（实际上可以并发）
- 高并发下锁竞争激烈

**问题2：复合操作不是原子的**
```java
// ❌ 仍然不安全！
if (!syncList.isEmpty()) {  // 操作1：检查
    syncList.remove(0);     // 操作2：移除
}
// 两个操作之间，其他线程可能清空队列
```

**问题3：没有阻塞语义**
```java
// 需要手动实现忙等待
while (syncList.isEmpty()) {
    Thread.sleep(100); // 浪费CPU
}
Object item = syncList.remove(0);
```

---

### 问题3：并发队列解决了什么问题？

#### 3.1 线程安全 + 高性能

**对比表格**：

| 特性 | ArrayList | synchronizedList | BlockingQueue |
|-----|-----------|------------------|---------------|
| **线程安全** | ❌ | ✅ | ✅ |
| **读写并发** | ❌ | ❌ | ✅（部分实现） |
| **原子复合操作** | ❌ | ❌ | ✅ |
| **阻塞语义** | ❌ | ❌ | ✅ |
| **性能** | 高 | 低 | 高 |

#### 3.2 提供阻塞/非阻塞语义

**阻塞队列的核心价值**：
```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

// 生产者：队列满时自动阻塞
queue.put("item"); // 如果队列满，线程挂起等待

// 消费者：队列空时自动阻塞
String item = queue.take(); // 如果队列空，线程挂起等待
```

**优势**：
- ✅ **避免忙等待**：线程挂起，不消耗CPU
- ✅ **自动协调**：生产者和消费者自动同步
- ✅ **简化编程**：无需手动wait/notify

#### 3.3 支持多种并发策略

**策略1：锁分离（LinkedBlockingQueue）**
```java
// 读锁和写锁分离
private final ReentrantLock takeLock = new ReentrantLock();
private final ReentrantLock putLock = new ReentrantLock();

// 生产者和消费者可以并发执行
```

**策略2：CAS无锁（ConcurrentLinkedQueue）**
```java
// 使用CAS操作，完全无锁
private boolean casHead(Node<E> cmp, Node<E> val) {
    return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);
}
```

---

## 二、并发队列的分类体系

### 2.1 按阻塞特性分类

```
                    并发队列
                        │
        ┌───────────────┴───────────────┐
        │                               │
    阻塞队列                         非阻塞队列
  (BlockingQueue)              (ConcurrentLinkedQueue)
        │                               │
        │                               │
  - 队列满时阻塞                    - 队列满时返回false
  - 队列空时阻塞                    - 队列空时返回null
  - 适合生产者-消费者               - 适合高并发、低延迟
```

#### 阻塞队列（BlockingQueue）

**核心方法**：
```java
public interface BlockingQueue<E> extends Queue<E> {
    // 阻塞方法
    void put(E e) throws InterruptedException;      // 队列满时阻塞
    E take() throws InterruptedException;           // 队列空时阻塞
    
    // 超时方法
    boolean offer(E e, long timeout, TimeUnit unit); // 超时返回false
    E poll(long timeout, TimeUnit unit);             // 超时返回null
    
    // 非阻塞方法
    boolean offer(E e);  // 队列满时返回false
    E poll();            // 队列空时返回null
}
```

**方法对比**：

| 操作 | 抛异常 | 返回特殊值 | 阻塞 | 超时 |
|-----|-------|-----------|------|------|
| **插入** | add(e) | offer(e) | put(e) | offer(e, time, unit) |
| **移除** | remove() | poll() | take() | poll(time, unit) |
| **检查** | element() | peek() | - | - |

#### 非阻塞队列（ConcurrentLinkedQueue）

**核心方法**：
```java
public class ConcurrentLinkedQueue<E> extends AbstractQueue<E> {
    public boolean offer(E e);  // 永远返回true（无界）
    public E poll();            // 队列空返回null
    public E peek();            // 查看队头元素
}
```

**特点**：
- ✅ 完全无锁，使用CAS
- ✅ 无界队列
- ✅ 高并发性能好
- ❌ 无阻塞语义

---

### 2.2 按容量特性分类

#### 有界队列

**代表**：ArrayBlockingQueue、LinkedBlockingQueue（可选）

```java
// 固定容量
BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);

// 容量限制的意义
queue.put("item"); // 如果队列已有100个元素，阻塞等待
```

**优势**：
- ✅ **内存可控**：防止OOM
- ✅ **背压机制**：生产者速度过快时自动限流
- ✅ **资源保护**：限制系统负载

**劣势**：
- ❌ 需要合理设置容量
- ❌ 容量过小导致频繁阻塞

#### 无界队列

**代表**：LinkedBlockingQueue（默认）、PriorityBlockingQueue、LinkedTransferQueue

```java
// 无容量限制（理论上Integer.MAX_VALUE）
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// 永远不会因为队列满而阻塞
queue.put("item"); // 总是成功（除非OOM）
```

**优势**：
- ✅ 生产者永不阻塞
- ✅ 简化配置

**劣势**：
- ❌ **OOM风险**：内存可能耗尽
- ❌ 无背压机制

#### 零容量队列

**代表**：SynchronousQueue

```java
// 容量为0，直接传递
BlockingQueue<String> queue = new SynchronousQueue<>();

// 生产者必须等待消费者
queue.put("item"); // 阻塞，直到有消费者take()
```

**特点**：
- ✅ 直接传递，无中间存储
- ✅ 节省内存
- ✅ 适合线程池

---

### 2.3 按数据结构分类

#### 数组实现

**代表**：ArrayBlockingQueue、PriorityBlockingQueue

```java
// 底层是数组
final Object[] items;
int takeIndex;  // 取元素的索引
int putIndex;   // 放元素的索引
```

**特点**：
- ✅ 内存连续，缓存友好
- ✅ 随机访问快
- ❌ 容量固定（或扩容成本高）
- ❌ 入队/出队可能需要移动元素

#### 链表实现

**代表**：LinkedBlockingQueue、LinkedTransferQueue、ConcurrentLinkedQueue

```java
// 底层是链表
static class Node<E> {
    E item;
    Node<E> next;
}
```

**特点**：
- ✅ 动态扩容
- ✅ 入队/出队O(1)
- ❌ 内存不连续，缓存不友好
- ❌ 每个元素额外的Node开销

#### 堆实现

**代表**：PriorityBlockingQueue、DelayQueue

```java
// 底层是二叉堆（数组表示）
private transient Object[] queue;

// 堆排序，保证优先级
private void siftUp(int k, E x) { ... }
```

**特点**：
- ✅ 自动排序
- ✅ 取最小/最大元素O(1)
- ❌ 插入O(log n)

---

## 三、核心设计思想

### 3.1 锁机制对比

#### 单锁设计（ArrayBlockingQueue）

```java
public class ArrayBlockingQueue<E> {
    // 一把锁保护所有操作
    final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;
    
    public void put(E e) throws InterruptedException {
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }
}
```

**流程图**：
```
生产者线程              消费者线程
     │                      │
     ├─→ lock.lock()        │
     │   (阻塞等待)  ←──────┤ lock.lock()
     │                      │ (等待生产者释放锁)
     ├─→ 入队               │
     │                      │
     ├─→ lock.unlock() ─────┤
     │                      ├─→ 获得锁
     │                      ├─→ 出队
     │                      ├─→ lock.unlock()
```

**特点**：
- ✅ 实现简单
- ❌ 生产者和消费者互斥（性能瓶颈）

#### 双锁设计（LinkedBlockingQueue）

```java
public class LinkedBlockingQueue<E> {
    // 两把锁，读写分离
    private final ReentrantLock takeLock = new ReentrantLock();
    private final ReentrantLock putLock = new ReentrantLock();
    
    private final Condition notEmpty = takeLock.newCondition();
    private final Condition notFull = putLock.newCondition();
}
```

**流程图**：
```
生产者线程              消费者线程
     │                      │
     ├─→ putLock.lock()     ├─→ takeLock.lock()
     │                      │
     ├─→ 入队               ├─→ 出队
     │   (并发执行)         │   (并发执行)
     │                      │
     ├─→ putLock.unlock()   ├─→ takeLock.unlock()
```

**特点**：
- ✅ 读写并发，吞吐量高
- ❌ 实现复杂，需要协调两把锁

#### 无锁设计（ConcurrentLinkedQueue）

```java
public class ConcurrentLinkedQueue<E> {
    // 完全无锁，使用CAS
    private boolean casTail(Node<E> cmp, Node<E> val) {
        return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
    }
    
    public boolean offer(E e) {
        Node<E> newNode = new Node<>(e);
        for (Node<E> t = tail, p = t;;) {
            // CAS自旋，直到成功
            if (p.casNext(null, newNode)) {
                casTail(t, newNode);
                return true;
            }
        }
    }
}
```

**流程图**：
```
线程1: offer("A")        线程2: offer("B")
     │                      │
     ├─→ 读取tail           ├─→ 读取tail
     │                      │
     ├─→ CAS设置next ───────┤ CAS设置next
     │   (成功)             │ (失败，因为被线程1修改)
     │                      │
     ├─→ 返回true           ├─→ 重试(自旋)
     │                      ├─→ CAS设置next
     │                      ├─→ 返回true
```

**特点**：
- ✅ 完全无锁，性能极高
- ✅ 无线程阻塞
- ❌ 实现极其复杂
- ❌ ABA问题需要特殊处理

---

### 3.2 等待-通知机制

#### Condition的使用

```java
// 生产者
lock.lock();
try {
    while (队列满) {
        notFull.await();  // 释放锁，等待
    }
    入队();
    notEmpty.signal();    // 唤醒消费者
} finally {
    lock.unlock();
}

// 消费者
lock.lock();
try {
    while (队列空) {
        notEmpty.await(); // 释放锁，等待
    }
    出队();
    notFull.signal();     // 唤醒生产者
} finally {
    lock.unlock();
}
```

**为什么用while而不是if？**
```java
// ❌ 错误：使用if
if (队列空) {
    notEmpty.await();
}
// 被唤醒后，队列可能又被其他线程清空了！

// ✅ 正确：使用while
while (队列空) {
    notEmpty.await();
}
// 被唤醒后重新检查条件
```

**虚假唤醒问题**：
- 线程可能在没有被signal的情况下被唤醒
- 多个线程等待，一个signal可能唤醒多个
- 必须用while循环重新检查条件

---

### 3.3 内存模型与可见性

#### happens-before保证

```java
// 线程1：生产者
queue.put(item);  // 操作A

// 线程2：消费者
Item result = queue.take();  // 操作B

// JMM保证：操作A happens-before 操作B
// 即：线程1对item的所有修改，线程2都能看到
```

**实现机制**：
1. **锁的happens-before**：unlock happens-before 后续的lock
2. **volatile的happens-before**：写 happens-before 读
3. **传递性**：A hb B, B hb C => A hb C

---

## 四、并发队列 vs 传统方案

### 4.1 JDK 1.5之前的解决方案

#### 方案1：synchronized + wait/notify

```java
public class SimpleBlockingQueue<E> {
    private final Queue<E> queue = new LinkedList<>();
    private final int capacity;
    
    public synchronized void put(E e) throws InterruptedException {
        while (queue.size() == capacity) {
            wait();  // 队列满，等待
        }
        queue.add(e);
        notifyAll();  // 唤醒所有等待线程
    }
    
    public synchronized E take() throws InterruptedException {
        while (queue.isEmpty()) {
            wait();  // 队列空，等待
        }
        E e = queue.remove();
        notifyAll();  // 唤醒所有等待线程
        return e;
    }
}
```

**问题**：
- ❌ notifyAll()唤醒所有线程，效率低
- ❌ 粗粒度锁，并发度低
- ❌ 容易出错（忘记notify、死锁等）

#### 方案2：忙等待

```java
// ❌ 浪费CPU
while (queue.isEmpty()) {
    Thread.yield();  // 或者Thread.sleep(1)
}
E item = queue.poll();
```

---

### 4.2 并发队列的优势

| 对比项 | 传统方案 | 并发队列 |
|-------|---------|---------|
| **线程安全** | 需手动同步 | 内置保证 |
| **性能** | 粗粒度锁 | 细粒度锁/无锁 |
| **易用性** | 复杂，易出错 | 简单，API友好 |
| **阻塞语义** | 需手动实现 | 内置支持 |
| **可维护性** | 低 | 高 |

---

## 五、总结

### 核心要点

1. **并发队列解决的核心问题**：
   - 线程安全 + 高性能
   - 阻塞/非阻塞语义
   - 简化并发编程

2. **分类体系**：
   - 阻塞 vs 非阻塞
   - 有界 vs 无界
   - 数组 vs 链表 vs 堆

3. **设计思想**：
   - 锁分离（提高并发度）
   - CAS无锁（极致性能）
   - Condition精准唤醒

4. **选型原则**：
   - 固定容量 → ArrayBlockingQueue
   - 高吞吐量 → LinkedBlockingQueue
   - 优先级 → PriorityBlockingQueue
   - 延迟任务 → DelayQueue
   - 直接传递 → SynchronousQueue
   - 高并发非阻塞 → ConcurrentLinkedQueue

---

**下一章**：深入ArrayBlockingQueue的实现原理
