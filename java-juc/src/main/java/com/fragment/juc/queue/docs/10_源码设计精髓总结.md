# 源码设计精髓总结

> **本章目标**：从架构师视角总结JUC并发队列源码中的设计模式、编程技巧和最佳实践

---

## 一、设计模式

### 1.1 生产者-消费者模式

**应用**：所有阻塞队列

```java
// 生产者
queue.put(item);

// 消费者
Item item = queue.take();
```

**价值**：
- 解耦生产和消费
- 异步处理
- 削峰填谷

---

### 1.2 Leader-Follower模式

**应用**：DelayQueue

```java
// Leader：等待队头元素的线程
private Thread leader = null;

// Leader等待指定时间
if (leader == null) {
    leader = Thread.currentThread();
    available.awaitNanos(delay);
}

// Follower无限期等待
else {
    available.await();
}
```

**价值**：
- 减少不必要的唤醒
- 避免惊群效应
- 精准控制等待时间

---

### 1.3 双重检查锁（Double-Check）

**应用**：ConcurrentLinkedQueue

```java
// 第一次检查（无锁）
if (count.get() == capacity)
    return false;

// 获取锁
lock.lock();
try {
    // 第二次检查
    if (count.get() < capacity) {
        enqueue(node);
    }
} finally {
    lock.unlock();
}
```

**价值**：
- 减少锁竞争
- 提高性能

---

### 1.4 模板方法模式

**应用**：AbstractQueue

```java
public abstract class AbstractQueue<E> {
    // 模板方法
    public boolean add(E e) {
        if (offer(e))
            return true;
        else
            throw new IllegalStateException("Queue full");
    }
    
    // 子类实现
    public abstract boolean offer(E e);
}
```

---

## 二、并发控制技巧

### 2.1 锁分离

**应用**：LinkedBlockingQueue

```java
// 读写锁分离
private final ReentrantLock takeLock = new ReentrantLock();
private final ReentrantLock putLock = new ReentrantLock();

// 读写并发
public void put(E e) {
    putLock.lock();  // 只锁写
    // ...
}

public E take() {
    takeLock.lock();  // 只锁读
    // ...
}
```

**价值**：
- 提高并发度
- 读写并行
- 吞吐量提升2倍

---

### 2.2 CAS无锁

**应用**：ConcurrentLinkedQueue、LinkedTransferQueue

```java
// CAS操作
private boolean casTail(Node<E> cmp, Node<E> val) {
    return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);
}

// 自旋重试
for (;;) {
    if (casTail(t, newNode))
        return true;
    // 失败，重试
}
```

**价值**：
- 完全无锁
- 无线程阻塞
- 性能最高

---

### 2.3 Condition精准唤醒

**应用**：所有阻塞队列

```java
// 两个Condition
private final Condition notEmpty = lock.newCondition();
private final Condition notFull = lock.newCondition();

// 入队后唤醒消费者
enqueue(e);
notEmpty.signal();  // 只唤醒一个

// 出队后唤醒生产者
dequeue();
notFull.signal();   // 只唤醒一个
```

**价值**：
- 避免虚假唤醒
- 精准控制
- 避免惊群

---

### 2.4 松弛策略（Slack）

**应用**：ConcurrentLinkedQueue、LinkedTransferQueue

```java
// tail允许滞后
if (p.casNext(null, newNode)) {
    // 只有当p != t时才更新tail
    if (p != t)
        casTail(t, newNode);
}
```

**价值**：
- 减少CAS操作
- 提高并发度
- 性能优化

---

## 三、内存优化技巧

### 3.1 清空引用帮助GC

**应用**：所有队列

```java
// 出队时清空引用
private E dequeue() {
    E x = (E) items[takeIndex];
    items[takeIndex] = null;  // 帮助GC
    // ...
}
```

**价值**：
- 防止内存泄漏
- 加速GC回收

---

### 3.2 自引用帮助GC

**应用**：LinkedBlockingQueue、ConcurrentLinkedQueue

```java
// 旧节点自引用
h.next = h;  // 自引用

// 断开与链表的连接
// 可以被快速GC回收
```

---

### 3.3 哨兵节点

**应用**：LinkedBlockingQueue、ConcurrentLinkedQueue

```java
// 初始化哨兵节点
last = head = new Node<E>(null);

// 优势：
// 1. 简化边界条件
// 2. 避免空指针检查
// 3. 统一处理逻辑
```

---

### 3.4 局部变量缓存

**应用**：所有队列

```java
public void put(E e) {
    // 使用final局部变量
    final ReentrantLock lock = this.lock;
    final AtomicInteger count = this.count;
    
    lock.lock();
    // JVM可以优化，缓存到寄存器
}
```

**价值**：
- 减少字段访问
- JVM优化
- 性能提升

---

## 四、算法与数据结构

### 4.1 循环数组

**应用**：ArrayBlockingQueue

```java
// 循环索引
final int inc(int i) {
    return (++i == items.length) ? 0 : i;
}

// O(1)入队/出队
items[putIndex] = x;
putIndex = inc(putIndex);
```

**价值**：
- 避免数组移动
- O(1)性能
- 内存连续

---

### 4.2 堆排序

**应用**：PriorityBlockingQueue、DelayQueue

```java
// 上浮
private void siftUp(int k, E x) {
    while (k > 0) {
        int parent = (k - 1) >>> 1;
        if (x.compareTo(array[parent]) >= 0)
            break;
        array[k] = array[parent];
        k = parent;
    }
    array[k] = x;
}

// 下沉
private void siftDown(int k, E x) {
    // ...
}
```

**价值**：
- 自动排序
- 插入O(log n)
- 取最小O(1)

---

### 4.3 链表

**应用**：LinkedBlockingQueue、ConcurrentLinkedQueue

```java
static class Node<E> {
    E item;
    Node<E> next;
}

// 优势：
// - 动态扩容
// - 入队/出队O(1)
```

---

## 五、性能优化技巧

### 5.1 扩容时释放锁

**应用**：PriorityBlockingQueue

```java
private void tryGrow(Object[] array, int oldCap) {
    lock.unlock();  // 释放锁
    
    // 扩容（可能耗时）
    Object[] newArray = new Object[newCap];
    
    lock.lock();    // 重新获取锁
    // 复制数据
}
```

**价值**：
- 扩容时允许take操作
- 提高并发度

---

### 5.2 自旋+阻塞

**应用**：SynchronousQueue、LinkedTransferQueue

```java
// 先自旋
int spins = shouldSpin(s) ? maxSpins : 0;
for (;;) {
    if (spins > 0)
        spins--;  // 自旋
    else
        LockSupport.park(this);  // 阻塞
}
```

**价值**：
- 短等待避免阻塞开销
- 长等待挂起线程

---

### 5.3 批量操作

**应用**：所有队列

```java
// drainTo批量取出
public int drainTo(Collection<? super E> c, int maxElements) {
    lock.lock();
    try {
        // 只获取一次锁，批量操作
        int n = Math.min(maxElements, count);
        for (int i = 0; i < n; i++) {
            c.add(dequeue());
        }
        return n;
    } finally {
        lock.unlock();
    }
}
```

**价值**：
- 减少锁竞争
- 提高效率

---

## 六、线程安全保证

### 6.1 volatile保证可见性

```java
// 所有共享变量都是volatile
private transient volatile Node<E> head;
private transient volatile Node<E> tail;

volatile E item;
volatile Node<E> next;
```

---

### 6.2 happens-before关系

```java
// 锁的happens-before
lock.lock();
// 操作
lock.unlock();  // happens-before 后续的lock()

// volatile的happens-before
volatile int count;
count++;  // 写 happens-before 读
```

---

### 6.3 原子操作

```java
// AtomicInteger
private final AtomicInteger count = new AtomicInteger();
count.getAndIncrement();  // 原子操作

// CAS
UNSAFE.compareAndSwapObject(this, headOffset, h, newHead);
```

---

## 七、编程最佳实践

### 7.1 while循环检查条件

```java
// ✅ 正确：使用while
while (count == 0)
    notEmpty.await();

// ❌ 错误：使用if
if (count == 0)
    notEmpty.await();  // 虚假唤醒问题
```

---

### 7.2 中断处理

```java
// ✅ 正确：恢复中断状态
try {
    queue.put(item);
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();  // 恢复
    // 或向上抛出
}
```

---

### 7.3 锁的使用

```java
// ✅ 正确：finally释放锁
lock.lock();
try {
    // 操作
} finally {
    lock.unlock();  // 保证释放
}
```

---

### 7.4 空值检查

```java
// ✅ 正确：检查空值
if (e == null)
    throw new NullPointerException();
```

---

## 八、可借鉴的设计思想

### 8.1 分层设计

```
接口层：Queue、BlockingQueue、TransferQueue
   ↓
抽象层：AbstractQueue
   ↓
实现层：ArrayBlockingQueue、LinkedBlockingQueue等
```

---

### 8.2 职责分离

```java
// 数据结构：数组、链表、堆
// 并发控制：锁、CAS
// 阻塞控制：Condition、LockSupport
```

---

### 8.3 性能与功能的权衡

```java
// ArrayBlockingQueue：简单、内存友好
// LinkedBlockingQueue：复杂、高吞吐
// ConcurrentLinkedQueue：极致性能、无阻塞语义
```

---

### 8.4 渐进式优化

```java
// 1. 先保证正确性（单锁）
// 2. 再优化性能（双锁）
// 3. 最后极致优化（无锁）
```

---

## 九、总结

### 核心设计原则

1. **正确性优先**：先保证线程安全
2. **性能优化**：在正确基础上优化
3. **简单性**：能简单就不复杂
4. **可维护性**：代码清晰易懂

### 关键技术

1. **并发控制**：锁分离、CAS、Condition
2. **内存优化**：清空引用、自引用、哨兵节点
3. **算法优化**：循环数组、堆排序、松弛策略
4. **性能优化**：自旋、批量操作、扩容释放锁

### 实战建议

1. **理解原理**：知其然知其所以然
2. **选型合理**：根据场景选择队列
3. **正确使用**：避免常见陷阱
4. **性能测试**：验证选型是否合理
5. **持续优化**：监控并调优

---

**JUC并发队列学习完成！**
