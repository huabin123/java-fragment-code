# 队列选型与对比

> **本章目标**：从架构师视角全面对比各种并发队列，提供选型决策依据和最佳实践

---

## 一、队列全景对比

### 1.1 核心特性对比表

| 队列类型 | 底层结构 | 容量 | 锁机制 | 阻塞 | 排序 | 适用场景 |
|---------|---------|------|--------|------|------|---------|
| **ArrayBlockingQueue** | 数组 | 有界 | 单锁 | ✅ | FIFO | 固定容量、内存敏感 |
| **LinkedBlockingQueue** | 链表 | 可选 | 双锁 | ✅ | FIFO | 高并发、吞吐优先 |
| **PriorityBlockingQueue** | 堆 | 无界 | 单锁 | ✅ | 优先级 | 优先级任务调度 |
| **DelayQueue** | 优先级队列 | 无界 | 单锁 | ✅ | 延迟时间 | 延迟任务、定时任务 |
| **SynchronousQueue** | 无存储 | 0 | CAS | ✅ | - | 直接传递、线程池 |
| **LinkedTransferQueue** | 链表 | 无界 | CAS | ✅ | FIFO | 高性能传输 |
| **ConcurrentLinkedQueue** | 链表 | 无界 | CAS | ❌ | FIFO | 高并发、非阻塞 |

---

### 1.2 性能对比

#### 吞吐量对比（10生产者+10消费者，100万次操作）

```
ConcurrentLinkedQueue:     800万 ops/s  ████████████████
LinkedTransferQueue:       700万 ops/s  ██████████████
LinkedBlockingQueue:       500万 ops/s  ██████████
ArrayBlockingQueue:        300万 ops/s  ██████
PriorityBlockingQueue:     200万 ops/s  ████
DelayQueue:                150万 ops/s  ███
SynchronousQueue:          100万 ops/s  ██
```

**结论**：
- 无锁队列（CAS）> 双锁队列 > 单锁队列
- 非阻塞 > 阻塞
- 简单结构 > 复杂结构（堆、优先级）

---

### 1.3 内存占用对比（1000个元素）

```
ArrayBlockingQueue:        4KB   (数组)
LinkedBlockingQueue:       24KB  (链表+Node)
PriorityBlockingQueue:     8KB   (数组+堆)
DelayQueue:                8KB   (优先级队列)
ConcurrentLinkedQueue:     24KB  (链表+Node)
SynchronousQueue:          0KB   (无存储)
```

**结论**：
- 数组结构内存占用最小
- 链表结构有额外Node开销
- SynchronousQueue零内存占用

---

## 二、选型决策树

### 2.1 第一层：是否需要阻塞语义？

```
需要阻塞语义？
    │
    ├─ Yes → 阻塞队列
    │         │
    │         ├─ 需要容量限制？
    │         │    ├─ Yes → ArrayBlockingQueue / LinkedBlockingQueue
    │         │    └─ No  → LinkedBlockingQueue / PriorityBlockingQueue
    │         │
    │         ├─ 需要优先级？
    │         │    └─ Yes → PriorityBlockingQueue
    │         │
    │         ├─ 需要延迟获取？
    │         │    └─ Yes → DelayQueue
    │         │
    │         └─ 需要直接传递？
    │              └─ Yes → SynchronousQueue
    │
    └─ No  → 非阻塞队列
              └─ ConcurrentLinkedQueue
```

---

### 2.2 第二层：性能 vs 功能

```
性能优先 vs 功能优先？
    │
    ├─ 性能优先
    │    ├─ 极致性能 → ConcurrentLinkedQueue（无锁）
    │    ├─ 高吞吐   → LinkedBlockingQueue（双锁）
    │    └─ 低延迟   → SynchronousQueue（直接传递）
    │
    └─ 功能优先
         ├─ 优先级   → PriorityBlockingQueue
         ├─ 延迟     → DelayQueue
         ├─ 容量控制 → ArrayBlockingQueue
         └─ 公平性   → LinkedBlockingQueue（公平锁）
```

---

### 2.3 第三层：资源约束

```
资源约束？
    │
    ├─ 内存敏感
    │    ├─ 固定容量 → ArrayBlockingQueue
    │    └─ 零容量   → SynchronousQueue
    │
    ├─ CPU敏感
    │    └─ 减少锁竞争 → ConcurrentLinkedQueue / LinkedBlockingQueue
    │
    └─ GC敏感
         └─ 减少对象创建 → ArrayBlockingQueue
```

---

## 三、典型场景选型

### 3.1 生产者-消费者模式

#### 场景1：日志异步写入

```java
// 需求：
// - 固定容量（防止OOM）
// - 阻塞语义（背压控制）
// - 内存可控

// 选择：ArrayBlockingQueue
BlockingQueue<LogEvent> queue = new ArrayBlockingQueue<>(10000);
```

**理由**：
- 有界队列，内存可控
- 阻塞语义，自动背压
- 数组结构，内存占用小

#### 场景2：高并发消息处理

```java
// 需求：
// - 高并发（多生产者+多消费者）
// - 高吞吐量
// - 阻塞语义

// 选择：LinkedBlockingQueue
BlockingQueue<Message> queue = new LinkedBlockingQueue<>(100000);
```

**理由**：
- 双锁设计，读写并发
- 吞吐量高
- 可选容量限制

---

### 3.2 任务调度

#### 场景1：优先级任务调度

```java
// 需求：
// - 任务有优先级
// - 高优先级先执行
// - 阻塞等待

// 选择：PriorityBlockingQueue
BlockingQueue<Task> queue = new PriorityBlockingQueue<>();
```

**理由**：
- 自动按优先级排序
- 阻塞语义
- 无界队列（任务数量不确定）

#### 场景2：延迟任务调度

```java
// 需求：
// - 任务延迟执行
// - 按到期时间排序
// - 阻塞到任务到期

// 选择：DelayQueue
DelayQueue<DelayedTask> queue = new DelayQueue<>();
```

**理由**：
- 延迟获取机制
- 自动按到期时间排序
- Leader-Follower优化

---

### 3.3 线程池

#### 场景1：固定线程池

```java
// 需求：
// - 固定线程数
// - 任务排队
// - 容量限制

// 选择：LinkedBlockingQueue（有界）
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10, 10, 0L, TimeUnit.MILLISECONDS,
    new LinkedBlockingQueue<>(1000)
);
```

**理由**：
- 有界队列，防止OOM
- 高吞吐量
- 适合固定线程池

#### 场景2：缓存线程池

```java
// 需求：
// - 线程数动态调整
// - 任务立即执行
// - 无排队

// 选择：SynchronousQueue
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
    new SynchronousQueue<>()
);
```

**理由**：
- 零容量，任务不排队
- 直接传递，立即执行或创建线程
- 适合大量短期任务

---

### 3.4 高并发场景

#### 场景1：高并发非阻塞队列

```java
// 需求：
// - 极高并发
// - 不需要阻塞
// - 追求性能

// 选择：ConcurrentLinkedQueue
Queue<Event> queue = new ConcurrentLinkedQueue<>();
```

**理由**：
- CAS无锁，性能最高
- 非阻塞，无上下文切换
- 适合高并发、低延迟

#### 场景2：实时数据处理

```java
// 需求：
// - 实时处理
// - 零延迟
// - 直接传递

// 选择：SynchronousQueue
SynchronousQueue<Data> queue = new SynchronousQueue<>();
```

**理由**：
- 零容量，直接传递
- 零延迟，实时处理
- 生产者和消费者直接交互

---

## 四、常见误区

### 4.1 误区1：盲目追求性能

```java
// ❌ 错误：只看性能，忽略需求
Queue<Task> queue = new ConcurrentLinkedQueue<>();  // 性能最高

// 问题：
// 1. 无阻塞语义（需要轮询）
// 2. 无容量限制（可能OOM）
// 3. 不适合生产者-消费者

// ✅ 正确：根据需求选择
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(1000);
```

---

### 4.2 误区2：容量设置不合理

```java
// ❌ 错误：容量过小
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(10);
// 问题：频繁阻塞，吞吐量低

// ❌ 错误：容量过大
BlockingQueue<Task> queue = new LinkedBlockingQueue<>(1000000);
// 问题：内存占用高，可能OOM

// ✅ 正确：根据业务评估
// 容量 = 峰值TPS × 平均处理时间 × 安全系数
int capacity = 1000 * 0.1 * 2;  // 200
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(capacity);
```

---

### 4.3 误区3：忽略GC影响

```java
// ❌ 错误：高频场景使用链表队列
Queue<Task> queue = new LinkedBlockingQueue<>();
// 问题：频繁创建Node，GC压力大

// ✅ 正确：使用数组队列
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(1000);
// 优势：无额外对象创建，GC友好
```

---

### 4.4 误区4：使用错误的方法

```java
// ❌ 错误：使用add/remove
queue.add(task);     // 队列满时抛异常
queue.remove();      // 队列空时抛异常

// ✅ 正确：使用put/take或offer/poll
queue.put(task);     // 队列满时阻塞
queue.take();        // 队列空时阻塞

// 或
queue.offer(task);   // 队列满时返回false
queue.poll();        // 队列空时返回null
```

---

## 五、性能优化建议

### 5.1 减少锁竞争

```java
// 策略1：选择双锁队列
LinkedBlockingQueue<Task> queue = new LinkedBlockingQueue<>();
// 读写并发，减少竞争

// 策略2：选择无锁队列
ConcurrentLinkedQueue<Task> queue = new ConcurrentLinkedQueue<>();
// 完全无锁，无竞争
```

---

### 5.2 批量操作

```java
// ❌ 低效：逐个操作
for (Task task : tasks) {
    queue.put(task);  // 每次获取锁
}

// ✅ 高效：批量操作
queue.addAll(tasks);  // 只获取一次锁

// 或使用drainTo
List<Task> batch = new ArrayList<>();
queue.drainTo(batch, 100);  // 批量取出
```

---

### 5.3 避免频繁size()

```java
// ❌ 低效：频繁调用size
while (queue.size() > 0) {  // 每次都要获取锁
    Task task = queue.poll();
}

// ✅ 高效：直接poll
Task task;
while ((task = queue.poll()) != null) {
    // 处理
}
```

---

### 5.4 选择合适的公平性

```java
// 非公平锁（默认）：性能高
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(100);

// 公平锁：公平性好，性能略低
BlockingQueue<Task> queue = new ArrayBlockingQueue<>(100, true);

// 选择依据：
// - 性能优先 → 非公平锁
// - 公平性优先 → 公平锁
```

---

## 六、监控与诊断

### 6.1 关键指标

```java
// 队列大小
int size = queue.size();

// 剩余容量
int remaining = queue.remainingCapacity();

// 使用率
double usage = (double) size / (size + remaining);

// 告警阈值
if (usage > 0.8) {
    alert("队列使用率超过80%");
}
```

---

### 6.2 性能监控

```java
public class QueueMonitor {
    private final BlockingQueue<Task> queue;
    private final AtomicLong offerCount = new AtomicLong();
    private final AtomicLong pollCount = new AtomicLong();
    private final AtomicLong blockCount = new AtomicLong();
    
    public void offer(Task task) throws InterruptedException {
        long start = System.currentTimeMillis();
        boolean success = queue.offer(task, 1, TimeUnit.SECONDS);
        long duration = System.currentTimeMillis() - start;
        
        offerCount.incrementAndGet();
        if (duration > 100) {
            blockCount.incrementAndGet();
        }
    }
    
    public void printStatistics() {
        System.out.println("Offer: " + offerCount.get());
        System.out.println("Poll: " + pollCount.get());
        System.out.println("Block: " + blockCount.get());
        System.out.println("Queue size: " + queue.size());
    }
}
```

---

## 七、选型决策表

### 7.1 快速决策表

| 需求 | 推荐队列 | 备选队列 |
|-----|---------|---------|
| **固定容量** | ArrayBlockingQueue | LinkedBlockingQueue(有界) |
| **高吞吐量** | LinkedBlockingQueue | ConcurrentLinkedQueue |
| **低延迟** | SynchronousQueue | ConcurrentLinkedQueue |
| **优先级** | PriorityBlockingQueue | - |
| **延迟执行** | DelayQueue | - |
| **直接传递** | SynchronousQueue | - |
| **非阻塞** | ConcurrentLinkedQueue | - |
| **内存敏感** | ArrayBlockingQueue | SynchronousQueue |
| **GC敏感** | ArrayBlockingQueue | - |
| **公平性** | LinkedBlockingQueue(公平) | ArrayBlockingQueue(公平) |

---

### 7.2 场景决策表

| 场景 | 推荐队列 | 容量建议 |
|-----|---------|---------|
| **日志异步写入** | ArrayBlockingQueue | 10000 |
| **消息队列** | LinkedBlockingQueue | 100000 |
| **任务调度** | DelayQueue | 无界 |
| **线程池（固定）** | LinkedBlockingQueue | 1000 |
| **线程池（缓存）** | SynchronousQueue | 0 |
| **事件总线** | ConcurrentLinkedQueue | 无界 |
| **实时处理** | SynchronousQueue | 0 |

---

## 八、总结

### 核心原则

1. **需求驱动**：根据业务需求选择，不盲目追求性能
2. **权衡取舍**：性能、功能、资源之间的平衡
3. **容量规划**：合理设置容量，避免OOM或频繁阻塞
4. **监控诊断**：持续监控，及时调整

### 选型口诀

```
阻塞非阻塞，首先要分清
容量有无界，内存要考虑
性能看锁机制，双锁优于单
特殊需求看功能，优先级延迟
线程池看场景，固定缓存不同
高并发选无锁，CAS性能高
```

---

**至此，JUC并发队列学习体系完成！**
