# 第三章：独占模式源码深度分析

> **学习目标**：深入理解acquire和release的完整实现流程

---

## 一、独占模式概述

### 1.1 什么是独占模式？

**独占模式（Exclusive Mode）**：同一时刻只有一个线程可以获取资源

```
典型应用：
✅ ReentrantLock - 互斥锁
✅ ReentrantReadWriteLock.WriteLock - 写锁
✅ 自定义互斥锁
```

### 1.2 核心方法

```java
// 子类需要实现的方法
protected boolean tryAcquire(int arg);
protected boolean tryRelease(int arg);

// AQS提供的模板方法
public final void acquire(int arg);                    // 获取（阻塞）
public final void acquireInterruptibly(int arg);       // 获取（可中断）
public final boolean tryAcquireNanos(int arg, long ns);// 获取（超时）
public final boolean release(int arg);                 // 释放
```

---

## 二、acquire()源码深度剖析

### 2.1 acquire()的完整流程

```java
/**
 * 独占模式获取，忽略中断
 * 
 * 流程：
 * 1. tryAcquire()尝试获取
 * 2. 失败则加入队列
 * 3. 在队列中阻塞等待
 * 4. 被唤醒后重试
 */
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

**流程图**：

```
                    acquire(arg)
                         ↓
                  tryAcquire(arg)
                    ↙        ↘
                 成功          失败
                  ↓            ↓
                返回      addWaiter(EXCLUSIVE)
                              ↓
                         加入队列尾部
                              ↓
                      acquireQueued(node, arg)
                              ↓
                      ┌───────┴───────┐
                      ↓               ↓
                  前驱是head       前驱不是head
                      ↓               ↓
                tryAcquire(arg)    shouldPark?
                  ↙      ↘            ↓
               成功      失败         park()
                ↓        ↓            ↓
              出队      继续        被唤醒
                ↓                     ↓
              返回              重新尝试获取
```

---

### 2.2 第一步：tryAcquire()

#### 方法定义

```java
/**
 * 尝试以独占模式获取
 * 
 * @param arg 获取参数
 * @return true表示成功，false表示失败
 */
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
```

**为什么抛出异常？**

```
设计思想：
- AQS是抽象框架，不知道具体的获取逻辑
- 强制子类实现，否则运行时报错
- 比abstract方法更灵活（子类可以只实现需要的方法）
```

#### ReentrantLock的实现

```java
// 非公平锁的实现
static final class NonfairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    // 情况1：锁空闲
    if (c == 0) {
        // 非公平：直接CAS抢锁，不管队列
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 情况2：可重入
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // 溢出检查
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    
    // 情况3：获取失败
    return false;
}
```

#### 公平锁的实现

```java
static final class FairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        
        if (c == 0) {
            // 公平：先检查队列，没有前驱才CAS
            if (!hasQueuedPredecessors() &&
                compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
}

// 检查是否有前驱节点
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t &&
        ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

**公平锁 vs 非公平锁**：

```
场景：Thread A持有锁，Thread B在队列中等待

非公平锁：
Thread A释放锁
Thread C刚好到来 ──> 直接CAS抢锁 ──> 成功！
Thread B被唤醒 ──────────────────────> 继续等待

公平锁：
Thread A释放锁
Thread C刚好到来 ──> 检查队列 ──> 发现有Thread B ──> 加入队列
Thread B被唤醒 ──> 获取锁成功

优缺点：
非公平锁：
  ✅ 吞吐量高（减少线程切换）
  ❌ 可能饥饿

公平锁：
  ✅ 严格FIFO，不会饥饿
  ❌ 吞吐量低（更多线程切换）
```

---

### 2.3 第二步：addWaiter()

#### 源码实现

```java
/**
 * 为当前线程创建节点并加入队列
 * 
 * @param mode Node.EXCLUSIVE独占模式，Node.SHARED共享模式
 * @return 新创建的节点
 */
private Node addWaiter(Node mode) {
    // 1. 创建节点
    Node node = new Node(Thread.currentThread(), mode);
    
    // 2. 快速尝试入队（优化路径）
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    
    // 3. 快速入队失败，进入完整入队流程
    enq(node);
    return node;
}
```

**为什么分快速路径和慢速路径？**

```
快速路径（Fast Path）：
- 队列已初始化
- 一次CAS成功
- 最常见的情况
- 性能最优

慢速路径（Slow Path）：
- 队列未初始化
- CAS失败（高竞争）
- 需要自旋重试
- 保证最终成功
```

#### 完整入队流程（enq）

```java
/**
 * 完整的入队流程，处理初始化和CAS失败
 * 
 * @param node 要入队的节点
 * @return 前驱节点
 */
private Node enq(final Node node) {
    for (;;) { // 自旋，直到成功
        Node t = tail;
        
        // 情况1：队列未初始化
        if (t == null) {
            // 创建哨兵节点
            if (compareAndSetHead(new Node()))
                tail = head;
        }
        // 情况2：队列已初始化
        else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

**入队过程图解**：

```
初始状态：head = null, tail = null

Thread A竞争失败，入队：

1. 创建哨兵节点
   ┌────┐
   │哨兵│
   └────┘
    ↑  ↑
   head tail

2. 加入Thread A的节点
   ┌────┐    ┌────────┐
   │哨兵│ ←→ │Thread A│
   └────┘    └────────┘
    ↑              ↑
   head           tail

Thread B也竞争失败，入队：

3. 加入Thread B的节点
   ┌────┐    ┌────────┐    ┌────────┐
   │哨兵│ ←→ │Thread A│ ←→ │Thread B│
   └────┘    └────────┘    └────────┘
    ↑                            ↑
   head                         tail
```

---

### 2.4 第三步：acquireQueued()

#### 源码实现

```java
/**
 * 已在队列中的线程，尝试获取锁
 * 
 * @param node 当前线程的节点
 * @param arg 获取参数
 * @return 是否被中断过
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        
        // 自旋
        for (;;) {
            // 1. 获取前驱节点
            final Node p = node.predecessor();
            
            // 2. 如果前驱是head，尝试获取
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null; // 帮助GC
                failed = false;
                return interrupted;
            }
            
            // 3. 判断是否需要阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        // 4. 异常时取消节点
        if (failed)
            cancelAcquire(node);
    }
}
```

**为什么只有前驱是head才尝试获取？**

```
原因1：公平性
- head是哨兵或刚释放锁的节点
- head.next是第一个等待的线程
- 保证FIFO顺序

原因2：避免无效尝试
- 如果前驱不是head，说明前面还有线程在等待
- 即使尝试也会失败
- 不如直接阻塞，减少CPU消耗

示例：
head → Thread A → Thread B → Thread C

Thread C的前驱是Thread B，不是head
→ Thread C不应该尝试获取
→ 应该等Thread A和Thread B都获取后再尝试
```

#### shouldParkAfterFailedAcquire()

```java
/**
 * 检查并更新获取失败节点的状态
 * 
 * @param pred 前驱节点
 * @param node 当前节点
 * @return 是否应该阻塞
 */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    
    // 情况1：前驱状态是SIGNAL
    if (ws == Node.SIGNAL)
        // 前驱会唤醒我，可以安心阻塞
        return true;
    
    // 情况2：前驱已取消
    if (ws > 0) {
        // 跳过所有已取消的前驱
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus > 0);
        pred.next = node;
    }
    // 情况3：前驱状态是0或PROPAGATE
    else {
        // 设置前驱状态为SIGNAL
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    
    return false;
}
```

**为什么需要SIGNAL状态？**

```
问题：如何知道释放锁时需要唤醒后继节点？

方案1：总是唤醒
unlock() {
    if (head.next != null)
        unpark(head.next.thread);
}
问题：如果后继节点还在自旋，唤醒是浪费的

方案2：使用SIGNAL标记
unlock() {
    if (head.waitStatus == SIGNAL)
        unpark(head.next.thread);
}
优势：只有在需要时才唤醒
```

**状态转换过程**：

```
1. 节点刚加入队列
   pred.waitStatus = 0
   node.waitStatus = 0

2. 第一次shouldParkAfterFailedAcquire
   pred.waitStatus = 0 → SIGNAL
   返回false（不阻塞，再试一次）

3. 第二次shouldParkAfterFailedAcquire
   pred.waitStatus = SIGNAL
   返回true（可以阻塞了）

4. parkAndCheckInterrupt
   LockSupport.park() → 阻塞
```

#### parkAndCheckInterrupt()

```java
/**
 * 阻塞当前线程并检查中断状态
 * 
 * @return 是否被中断
 */
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this); // 阻塞
    return Thread.interrupted(); // 返回并清除中断标志
}
```

**LockSupport.park()的工作原理**：

```java
// LockSupport基于Unsafe实现
public static void park(Object blocker) {
    Thread t = Thread.currentThread();
    setBlocker(t, blocker); // 设置阻塞对象，便于诊断
    UNSAFE.park(false, 0L); // 阻塞
    setBlocker(t, null);
}

// 唤醒
public static void unpark(Thread thread) {
    if (thread != null)
        UNSAFE.unpark(thread);
}
```

**park vs wait**：

| 特性 | park/unpark | wait/notify |
|------|-------------|-------------|
| 前置条件 | 无 | 必须在synchronized块内 |
| 顺序 | unpark可以先于park | notify必须在wait之后 |
| 灵活性 | 高 | 低 |
| 性能 | 更好 | 较差 |

---

### 2.5 完整的acquire流程示例

```java
// 场景：3个线程竞争锁

// 1. Thread A获取锁
Thread A: tryAcquire() → 成功 → 返回

// 2. Thread B竞争失败
Thread B: tryAcquire() → 失败
         ↓
         addWaiter(EXCLUSIVE)
         ↓
         初始化队列，加入节点
         head → Thread B
         ↓
         acquireQueued()
         ↓
         前驱是head，tryAcquire() → 失败
         ↓
         shouldParkAfterFailedAcquire()
         ↓
         设置head.waitStatus = SIGNAL
         ↓
         返回false，再次循环
         ↓
         shouldParkAfterFailedAcquire()
         ↓
         head.waitStatus == SIGNAL，返回true
         ↓
         parkAndCheckInterrupt() → 阻塞

// 3. Thread C也竞争失败
Thread C: tryAcquire() → 失败
         ↓
         addWaiter(EXCLUSIVE)
         ↓
         head → Thread B → Thread C
         ↓
         acquireQueued()
         ↓
         前驱不是head，不尝试获取
         ↓
         shouldParkAfterFailedAcquire()
         ↓
         设置Thread B.waitStatus = SIGNAL
         ↓
         parkAndCheckInterrupt() → 阻塞

// 队列状态
head(SIGNAL) → Thread B(SIGNAL) → Thread C(0)
```

---

## 三、release()源码深度剖析

### 3.1 release()的完整流程

```java
/**
 * 独占模式释放
 * 
 * @param arg 释放参数
 * @return 是否完全释放
 */
public final boolean release(int arg) {
    // 1. 尝试释放
    if (tryRelease(arg)) {
        Node h = head;
        // 2. 唤醒后继节点
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

**流程图**：

```
           release(arg)
                ↓
          tryRelease(arg)
            ↙        ↘
         成功          失败
          ↓            ↓
    head != null?    返回false
          ↓
    waitStatus != 0?
          ↓
   unparkSuccessor(head)
          ↓
      唤醒后继节点
          ↓
       返回true
```

---

### 3.2 第一步：tryRelease()

#### ReentrantLock的实现

```java
protected final boolean tryRelease(int releases) {
    // 1. 计算释放后的state
    int c = getState() - releases;
    
    // 2. 检查是否是持有锁的线程
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    
    // 3. 判断是否完全释放
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    
    // 4. 更新state
    setState(c);
    return free;
}
```

**为什么要检查线程？**

```java
// 场景：Thread A持有锁，Thread B尝试释放

Thread A: lock.lock();    // state = 1
Thread B: lock.unlock();  // 抛出IllegalMonitorStateException

// 如果不检查：
Thread B: unlock() → state = 0
Thread A: 认为自己还持有锁，继续执行
结果：逻辑错误！
```

**为什么返回boolean？**

```java
// 场景：重入锁

lock.lock();    // state = 1
lock.lock();    // state = 2

lock.unlock();  // state = 1, 返回false（未完全释放）
lock.unlock();  // state = 0, 返回true（完全释放，唤醒后继）
```

---

### 3.3 第二步：unparkSuccessor()

#### 源码实现

```java
/**
 * 唤醒后继节点
 * 
 * @param node 当前节点（通常是head）
 */
private void unparkSuccessor(Node node) {
    // 1. 清除当前节点的waitStatus
    int ws = node.waitStatus;
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);
    
    // 2. 找到下一个需要唤醒的节点
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        // 从后向前找第一个非取消节点
        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    
    // 3. 唤醒
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

**为什么从后向前找？**

```
问题：为什么不直接用node.next？

场景1：next为null
head → Node1 → Node2

Node2刚入队，还没设置Node1.next
此时释放锁，Node1.next == null
但Node2.prev已经设置好了

从后向前找：
tail.prev → Node1 → head
可以找到Node2

场景2：next已取消
head(SIGNAL) → Node1(CANCELLED) → Node2(0)

从前向后：找到Node1，但已取消
从后向前：跳过Node1，找到Node2
```

**为什么要清除waitStatus？**

```
head.waitStatus = SIGNAL → 0

原因：
1. SIGNAL表示"需要唤醒后继"
2. 已经唤醒了，不再需要这个标记
3. 为下一次释放做准备
```

---

### 3.4 完整的release流程示例

```java
// 场景：Thread A释放锁，唤醒Thread B

// 初始状态
head(SIGNAL) → Thread B(SIGNAL) → Thread C(0)
Thread A持有锁，state = 1

// 1. Thread A释放锁
Thread A: release(1)
         ↓
         tryRelease(1)
         ↓
         state = 0, 返回true
         ↓
         unparkSuccessor(head)
         ↓
         head.waitStatus = SIGNAL → 0
         ↓
         找到Thread B
         ↓
         unpark(Thread B)

// 2. Thread B被唤醒
Thread B: parkAndCheckInterrupt() → 返回
         ↓
         继续acquireQueued的循环
         ↓
         前驱是head，tryAcquire() → 成功
         ↓
         setHead(Thread B)
         ↓
         head → Thread B(0) → Thread C(0)
         ↓
         返回

// 3. Thread B获取锁成功
Thread B持有锁，state = 1

// 队列状态
head(Thread B, 0) → Thread C(0)
```

---

## 四、可中断和超时版本

### 4.1 acquireInterruptibly()

```java
/**
 * 可中断的获取
 */
public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    // 1. 检查中断
    if (Thread.interrupted())
        throw new InterruptedException();
    
    // 2. 尝试获取
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null;
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                // 关键区别：检测到中断立即抛出异常
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

**vs acquire()**：

```
acquire():
- 忽略中断
- 获取锁后再处理中断
- 适合不能被中断的场景

acquireInterruptibly():
- 响应中断
- 检测到中断立即抛异常
- 适合可以被中断的场景
```

---

### 4.2 tryAcquireNanos()

```java
/**
 * 超时获取
 */
public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) ||
        doAcquireNanos(arg, nanosTimeout);
}

private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout <= 0L)
        return false;
    
    // 计算截止时间
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head && tryAcquire(arg)) {
                setHead(node);
                p.next = null;
                failed = false;
                return true;
            }
            
            // 计算剩余时间
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout <= 0L)
                return false; // 超时
            
            if (shouldParkAfterFailedAcquire(p, node) &&
                nanosTimeout > spinForTimeoutThreshold)
                // 超时阻塞
                LockSupport.parkNanos(this, nanosTimeout);
            
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

**spinForTimeoutThreshold**：

```java
static final long spinForTimeoutThreshold = 1000L; // 1微秒

// 为什么需要这个阈值？
if (nanosTimeout > 1000L)
    LockSupport.parkNanos(nanosTimeout);
else
    // 剩余时间太短，自旋更高效
    continue;

原因：
- park/unpark有开销
- 剩余时间很短时，自旋更快
- 1微秒是经验值
```

---

## 五、总结

### 5.1 acquire流程总结

```
1. tryAcquire() - 子类实现
   ├─ 成功 → 返回
   └─ 失败 → 继续

2. addWaiter() - 加入队列
   ├─ 快速路径：一次CAS成功
   └─ 慢速路径：自旋直到成功

3. acquireQueued() - 在队列中等待
   ├─ 前驱是head → tryAcquire()
   │  ├─ 成功 → 出队，返回
   │  └─ 失败 → 继续
   └─ 前驱不是head → shouldPark()
      ├─ 设置前驱SIGNAL
      └─ park()阻塞
```

### 5.2 release流程总结

```
1. tryRelease() - 子类实现
   ├─ 未完全释放 → 返回false
   └─ 完全释放 → 继续

2. unparkSuccessor() - 唤醒后继
   ├─ 清除waitStatus
   ├─ 找到下一个非取消节点
   └─ unpark()唤醒
```

### 5.3 关键设计点

1. **自旋 + 阻塞**：平衡CPU和响应时间
2. **SIGNAL状态**：按需唤醒，避免浪费
3. **从后向前遍历**：处理并发入队
4. **哨兵节点**：简化逻辑
5. **CAS + volatile**：无锁并发

---

## 六、思考题

1. **为什么acquireQueued返回中断状态而不是抛异常？**
2. **为什么只有前驱是head才尝试获取？**
3. **为什么需要自旋两次才阻塞？**
4. **如果unparkSuccessor从前向后遍历会有什么问题？**

---

**下一章预告**：我们将分析共享模式的实现，理解acquireShared和releaseShared的传播机制。
