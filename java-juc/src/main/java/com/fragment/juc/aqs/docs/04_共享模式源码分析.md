# 第四章：共享模式源码深度分析

> **学习目标**：深入理解共享模式的传播机制和acquireShared/releaseShared的实现

---

## 一、共享模式概述

### 1.1 什么是共享模式？

**共享模式（Shared Mode）**：同一时刻可以有多个线程获取资源

```
典型应用：
✅ Semaphore - 信号量
✅ CountDownLatch - 倒计时门栓
✅ ReentrantReadWriteLock.ReadLock - 读锁
```

### 1.2 共享模式 vs 独占模式

| 特性 | 独占模式 | 共享模式 |
|------|---------|---------|
| 同时获取线程数 | 1个 | 多个 |
| 典型应用 | 互斥锁 | 信号量、读锁 |
| 返回值 | boolean | int |
| 传播机制 | 无 | 有 |
| 唤醒策略 | 唤醒一个 | 可能唤醒多个 |

### 1.3 核心方法

```java
// 子类需要实现的方法
protected int tryAcquireShared(int arg);
protected boolean tryReleaseShared(int arg);

// AQS提供的模板方法
public final void acquireShared(int arg);
public final void acquireSharedInterruptibly(int arg);
public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout);
public final boolean releaseShared(int arg);
```

---

## 二、tryAcquireShared()的返回值含义

### 2.1 返回值的设计

```java
/**
 * 尝试以共享模式获取
 * 
 * @param arg 获取参数
 * @return 负数表示失败；0表示成功但后继不能再获取；正数表示成功且后继可能也能获取
 */
protected int tryAcquireShared(int arg) {
    throw new UnsupportedOperationException();
}
```

**返回值含义**：

```
< 0  → 获取失败，需要进入队列等待
= 0  → 获取成功，但资源已用完，不传播
> 0  → 获取成功，还有剩余资源，需要传播给后继
```

**为什么不是boolean？**

```
boolean的局限：
- 只能表示成功/失败
- 无法表示"是否需要传播"

int的优势：
- 可以表示剩余资源数量
- 可以控制传播行为
- 更灵活
```

---

### 2.2 Semaphore的实现

```java
// Semaphore的tryAcquireShared实现
protected int tryAcquireShared(int acquires) {
    for (;;) {
        int available = getState(); // 可用许可数
        int remaining = available - acquires;
        
        // 如果许可不足，或者CAS成功
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}

// 示例
state = 3, acquires = 1
→ remaining = 2
→ 返回2（成功，还有2个许可，需要传播）

state = 1, acquires = 1
→ remaining = 0
→ 返回0（成功，但许可用完，不传播）

state = 0, acquires = 1
→ remaining = -1
→ 返回-1（失败，进入队列）
```

---

### 2.3 CountDownLatch的实现

```java
// CountDownLatch的tryAcquireShared实现
protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1;
}

// 示例
state = 0 → 返回1（倒计时完成，唤醒所有等待线程）
state > 0 → 返回-1（倒计时未完成，进入队列）
```

**为什么返回1而不是0？**

```
返回1：
- state = 0时，所有等待线程都应该被唤醒
- 返回正数，触发传播机制
- 唤醒所有等待的线程

返回0：
- 不会传播
- 只唤醒一个线程
- 不符合CountDownLatch的语义
```

---

## 三、acquireShared()源码深度剖析

### 3.1 acquireShared()的完整流程

```java
/**
 * 共享模式获取，忽略中断
 * 
 * @param arg 获取参数
 */
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0)
        doAcquireShared(arg);
}
```

**流程图**：

```
                acquireShared(arg)
                        ↓
                tryAcquireShared(arg)
                    ↙        ↘
                 >= 0         < 0
                  ↓            ↓
                返回      doAcquireShared(arg)
                              ↓
                         加入队列(SHARED)
                              ↓
                      ┌───────┴───────┐
                      ↓               ↓
                  前驱是head       前驱不是head
                      ↓               ↓
            tryAcquireShared(arg)  shouldPark?
                  ↙      ↘            ↓
               >= 0      < 0         park()
                ↓        ↓            ↓
            setHeadAndPropagate   被唤醒
                ↓                     ↓
            可能唤醒后继        重新尝试获取
```

---

### 3.2 doAcquireShared()源码分析

```java
/**
 * 共享模式的获取流程
 * 
 * @param arg 获取参数
 */
private void doAcquireShared(int arg) {
    // 1. 加入队列（SHARED模式）
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        
        // 2. 自旋
        for (;;) {
            final Node p = node.predecessor();
            
            // 3. 如果前驱是head，尝试获取
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r >= 0) {
                    // 关键：设置head并传播
                    setHeadAndPropagate(node, r);
                    p.next = null; // 帮助GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            
            // 4. 判断是否需要阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

**vs doAcquire()**：

```
相同点：
✅ 都是加入队列等待
✅ 都是自旋 + 阻塞
✅ 都是前驱是head才尝试获取

不同点：
❌ doAcquire调用setHead()
✅ doAcquireShared调用setHeadAndPropagate()
   → 关键区别：传播机制
```

---

### 3.3 setHeadAndPropagate()：传播的核心

```java
/**
 * 设置head并传播唤醒
 * 
 * @param node 当前节点
 * @param propagate tryAcquireShared的返回值
 */
private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // 记录旧的head
    
    // 1. 设置新的head
    setHead(node);
    
    // 2. 判断是否需要传播
    if (propagate > 0 || h == null || h.waitStatus < 0 ||
        (h = head) == null || h.waitStatus < 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            // 3. 传播：唤醒后继节点
            doReleaseShared();
    }
}
```

**为什么需要传播？**

```
场景：Semaphore有3个许可，3个线程等待

head → Thread1 → Thread2 → Thread3

释放3个许可：
1. Thread1被唤醒，获取1个许可
   → propagate = 2（还有2个许可）
   → 唤醒Thread2（传播）

2. Thread2被唤醒，获取1个许可
   → propagate = 1（还有1个许可）
   → 唤醒Thread3（传播）

3. Thread3被唤醒，获取1个许可
   → propagate = 0（许可用完）
   → 不再传播

如果没有传播：
- 只有Thread1被唤醒
- Thread2和Thread3继续等待
- 资源浪费！
```

**传播条件分析**：

```java
if (propagate > 0 ||                    // 条件1：还有剩余资源
    h == null ||                        // 条件2：旧head为null（罕见）
    h.waitStatus < 0 ||                 // 条件3：旧head状态<0（SIGNAL/PROPAGATE）
    (h = head) == null ||               // 条件4：新head为null（罕见）
    h.waitStatus < 0)                   // 条件5：新head状态<0
```

**为什么条件这么复杂？**

```
JDK 1.5-1.6的bug：
- 只检查propagate > 0
- 并发释放时可能丢失唤醒

JDK 1.7+的修复：
- 增加了h.waitStatus < 0的检查
- 检查新旧head的状态
- 保证不丢失唤醒

详细场景：
Thread A: releaseShared() → doReleaseShared()
Thread B: acquireShared() → setHeadAndPropagate()

如果只检查propagate：
- Thread B的propagate可能是0
- 但Thread A正在释放，应该传播
- 通过检查waitStatus捕获这种情况
```

---

### 3.4 doReleaseShared()：传播的实现

```java
/**
 * 共享模式的释放/传播
 */
private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null && h != tail) {
            int ws = h.waitStatus;
            
            // 情况1：需要唤醒后继
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue; // CAS失败，重试
                unparkSuccessor(h); // 唤醒后继
            }
            // 情况2：状态是0，设置为PROPAGATE
            else if (ws == 0 &&
                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue; // CAS失败，重试
        }
        
        // 如果head没变，退出
        if (h == head)
            break;
    }
}
```

**PROPAGATE状态的作用**：

```
问题：为什么需要PROPAGATE状态？

场景：
Thread A: releaseShared() → doReleaseShared()
          head.waitStatus = SIGNAL → 0
          unparkSuccessor(head)

Thread B: 被唤醒，setHeadAndPropagate()
          此时head.waitStatus = 0
          如果只检查SIGNAL，不会传播

解决：
- 将0设置为PROPAGATE
- setHeadAndPropagate检查waitStatus < 0
- 包括SIGNAL和PROPAGATE
- 保证传播不丢失
```

**为什么要循环？**

```java
for (;;) {
    Node h = head;
    // ...
    if (h == head)
        break;
}
```

**原因**：

```
场景：并发释放

Thread A: doReleaseShared()
          h = head1
          unparkSuccessor(head1)
          
Thread B: 被唤醒，setHead(node)
          head = head2
          
Thread A: if (h == head) // head1 != head2
          继续循环，处理新的head

优势：
- 保证所有等待线程都被唤醒
- 处理并发场景
```

---

## 四、releaseShared()源码深度剖析

### 4.1 releaseShared()的完整流程

```java
/**
 * 共享模式释放
 * 
 * @param arg 释放参数
 * @return 是否释放成功
 */
public final boolean releaseShared(int arg) {
    // 1. 尝试释放
    if (tryReleaseShared(arg)) {
        // 2. 传播唤醒
        doReleaseShared();
        return true;
    }
    return false;
}
```

---

### 4.2 Semaphore的tryReleaseShared

```java
protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        
        // 溢出检查
        if (next < current)
            throw new Error("Maximum permit count exceeded");
        
        if (compareAndSetState(current, next))
            return true;
    }
}

// 示例
state = 2, releases = 1
→ next = 3
→ CAS成功，返回true
→ 触发doReleaseShared()
```

---

### 4.3 CountDownLatch的tryReleaseShared

```java
protected boolean tryReleaseShared(int releases) {
    for (;;) {
        int c = getState();
        if (c == 0)
            return false; // 已经是0，无需释放
        
        int nextc = c - 1;
        if (compareAndSetState(c, nextc))
            return nextc == 0; // 减到0时返回true
    }
}

// 示例
state = 1, countDown()
→ nextc = 0
→ 返回true
→ 触发doReleaseShared()，唤醒所有等待线程

state = 0, countDown()
→ 返回false
→ 不触发doReleaseShared()
```

---

## 五、完整的共享模式示例

### 5.1 Semaphore场景

```java
Semaphore semaphore = new Semaphore(2); // state = 2

// 初始队列为空

// Thread A获取
Thread A: tryAcquireShared(1)
         → state = 2 - 1 = 1
         → 返回1（成功，还有1个许可）
         → 直接返回，不入队

// Thread B获取
Thread B: tryAcquireShared(1)
         → state = 1 - 1 = 0
         → 返回0（成功，许可用完）
         → 直接返回，不入队

// Thread C获取
Thread C: tryAcquireShared(1)
         → state = 0 - 1 = -1
         → 返回-1（失败）
         → doAcquireShared()
         → 加入队列
         head → Thread C
         → park()阻塞

// Thread D获取
Thread D: tryAcquireShared(1)
         → 返回-1（失败）
         → 加入队列
         head → Thread C → Thread D
         → park()阻塞

// Thread A释放
Thread A: releaseShared(1)
         → tryReleaseShared(1)
         → state = 0 + 1 = 1
         → 返回true
         → doReleaseShared()
         → unparkSuccessor(head)
         → 唤醒Thread C

// Thread C被唤醒
Thread C: tryAcquireShared(1)
         → state = 1 - 1 = 0
         → 返回0（成功，许可用完）
         → setHeadAndPropagate(node, 0)
         → propagate = 0，不传播
         → 出队

// Thread B释放
Thread B: releaseShared(1)
         → state = 0 + 1 = 1
         → doReleaseShared()
         → 唤醒Thread D

// Thread D被唤醒
Thread D: tryAcquireShared(1)
         → state = 1 - 1 = 0
         → 返回0
         → 出队
```

---

### 5.2 CountDownLatch场景

```java
CountDownLatch latch = new CountDownLatch(3); // state = 3

// Thread Main等待
Thread Main: await()
            → tryAcquireShared(1)
            → state = 3, 返回-1（失败）
            → doAcquireShared()
            → 加入队列
            head → Thread Main
            → park()阻塞

// Thread 1完成
Thread 1: countDown()
         → tryReleaseShared(1)
         → state = 3 - 1 = 2
         → 返回false（未减到0）
         → 不触发doReleaseShared()

// Thread 2完成
Thread 2: countDown()
         → state = 2 - 1 = 1
         → 返回false

// Thread 3完成
Thread 3: countDown()
         → state = 1 - 1 = 0
         → 返回true（减到0）
         → doReleaseShared()
         → unparkSuccessor(head)
         → 唤醒Thread Main

// Thread Main被唤醒
Thread Main: tryAcquireShared(1)
            → state = 0, 返回1（成功）
            → setHeadAndPropagate(node, 1)
            → propagate = 1 > 0，传播
            → doReleaseShared()
            → 但队列已空，退出
```

---

## 六、共享模式的关键设计

### 6.1 传播机制

```
传播的触发时机：
1. setHeadAndPropagate()
   - 获取成功后
   - propagate > 0或waitStatus < 0

2. doReleaseShared()
   - releaseShared()调用
   - setHeadAndPropagate()调用

传播的实现：
1. unparkSuccessor() - 唤醒后继
2. 设置PROPAGATE状态 - 标记传播
3. 循环检查head - 处理并发
```

---

### 6.2 PROPAGATE状态

```
引入原因：
- 修复JDK 1.6的并发bug
- 防止丢失唤醒

状态转换：
0 → PROPAGATE → 0
↓
SIGNAL → 0

作用：
- 标记需要传播
- 配合waitStatus < 0检查
- 保证传播不丢失
```

---

### 6.3 并发安全性

```
关键点：
1. CAS更新state
2. CAS更新waitStatus
3. 循环检查head变化
4. 从后向前遍历

保证：
✅ 不丢失唤醒
✅ 不重复唤醒
✅ 正确传播
```

---

## 七、总结

### 7.1 共享模式的核心要点

1. **返回值**：int表示剩余资源，控制传播
2. **传播机制**：setHeadAndPropagate + doReleaseShared
3. **PROPAGATE状态**：防止丢失唤醒
4. **循环检查**：处理并发场景

### 7.2 vs 独占模式

| 特性 | 独占模式 | 共享模式 |
|------|---------|---------|
| 返回值 | boolean | int |
| 设置head | setHead() | setHeadAndPropagate() |
| 释放 | unparkSuccessor() | doReleaseShared() |
| 传播 | 无 | 有 |
| 状态 | SIGNAL | SIGNAL + PROPAGATE |

### 7.3 思考题

1. **为什么tryAcquireShared返回int而不是boolean？**
2. **为什么需要PROPAGATE状态？**
3. **doReleaseShared为什么要循环检查head？**
4. **如果不传播会有什么问题？**

---

**下一章预告**：我们将实践自定义同步器，加深对AQS的理解。
