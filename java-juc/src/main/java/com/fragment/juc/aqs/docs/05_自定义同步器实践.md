# ç¬¬äº”ç« ï¼šè‡ªå®šä¹‰åŒæ­¥å™¨å®è·µä¸æœ€ä½³å®è·µ

> **å­¦ä¹ ç›®æ ‡**ï¼šé€šè¿‡å®è·µæŒæ¡AQSçš„ä½¿ç”¨ï¼Œç†è§£è®¾è®¡è¦ç‚¹å’Œå¸¸è§é™·é˜±

---

## ä¸€ã€è‡ªå®šä¹‰åŒæ­¥å™¨çš„æ­¥éª¤

### 1.1 å®ç°æ­¥éª¤

```
1. ç»§æ‰¿AbstractQueuedSynchronizer
2. å®šä¹‰stateçš„å«ä¹‰
3. å®ç°tryAcquire/tryReleaseï¼ˆç‹¬å ï¼‰æˆ–tryAcquireShared/tryReleaseSharedï¼ˆå…±äº«ï¼‰
4. å®ç°isHeldExclusively()ï¼ˆå¯é€‰ï¼‰
5. æä¾›å¤–éƒ¨API
```

### 1.2 è®¾è®¡è€ƒè™‘

```
å…³é”®é—®é¢˜ï¼š
1. ä½¿ç”¨ç‹¬å æ¨¡å¼è¿˜æ˜¯å…±äº«æ¨¡å¼ï¼Ÿ
2. stateè¡¨ç¤ºä»€ä¹ˆå«ä¹‰ï¼Ÿ
3. å¦‚ä½•åˆ¤æ–­èƒ½å¦è·å–ï¼Ÿ
4. å¦‚ä½•åˆ¤æ–­èƒ½å¦é‡Šæ”¾ï¼Ÿ
5. æ˜¯å¦éœ€è¦å…¬å¹³æ€§ï¼Ÿ
```

---

## äºŒã€å®è·µ1ï¼šè‡ªå®šä¹‰äº’æ–¥é”

### 2.1 éœ€æ±‚åˆ†æ

```
éœ€æ±‚ï¼šå®ç°ä¸€ä¸ªç®€å•çš„äº’æ–¥é”
- åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–
- æ”¯æŒé‡å…¥
- ä¸æ”¯æŒå…¬å¹³æ€§ï¼ˆç®€åŒ–ï¼‰
```

### 2.2 è®¾è®¡

```
æ¨¡å¼ï¼šç‹¬å æ¨¡å¼
stateå«ä¹‰ï¼š
  0 - é”ç©ºé—²
  n - é”è¢«å ç”¨næ¬¡ï¼ˆé‡å…¥ï¼‰
```

### 2.3 å®Œæ•´å®ç°

```java
package com.fragment.juc.aqs.project;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

/**
 * è‡ªå®šä¹‰äº’æ–¥é”
 * 
 * ç‰¹æ€§ï¼š
 * 1. ç‹¬å æ¨¡å¼
 * 2. æ”¯æŒé‡å…¥
 * 3. éå…¬å¹³
 * 
 * @author huabin
 */
public class CustomMutex implements Lock {
    
    // åŒæ­¥å™¨
    private final Sync sync = new Sync();
    
    /**
     * å†…éƒ¨åŒæ­¥å™¨
     */
    private static class Sync extends AbstractQueuedSynchronizer {
        
        /**
         * å°è¯•è·å–é”
         * 
         * @param arg è·å–å‚æ•°ï¼ˆé€šå¸¸æ˜¯1ï¼‰
         * @return trueè¡¨ç¤ºæˆåŠŸ
         */
        @Override
        protected boolean tryAcquire(int arg) {
            final Thread current = Thread.currentThread();
            int c = getState();
            
            // æƒ…å†µ1ï¼šé”ç©ºé—²
            if (c == 0) {
                // CASè·å–é”
                if (compareAndSetState(0, arg)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
            // æƒ…å†µ2ï¼šå¯é‡å…¥
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + arg;
                if (nextc < 0) // æº¢å‡ºæ£€æŸ¥
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            
            // æƒ…å†µ3ï¼šè·å–å¤±è´¥
            return false;
        }
        
        /**
         * å°è¯•é‡Šæ”¾é”
         * 
         * @param arg é‡Šæ”¾å‚æ•°ï¼ˆé€šå¸¸æ˜¯1ï¼‰
         * @return trueè¡¨ç¤ºå®Œå…¨é‡Šæ”¾
         */
        @Override
        protected boolean tryRelease(int arg) {
            int c = getState() - arg;
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æŒæœ‰é”çš„çº¿ç¨‹
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            
            boolean free = false;
            if (c == 0) {
                // å®Œå…¨é‡Šæ”¾
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
        
        /**
         * æ˜¯å¦è¢«å½“å‰çº¿ç¨‹ç‹¬å 
         */
        @Override
        protected boolean isHeldExclusively() {
            return getExclusiveOwnerThread() == Thread.currentThread();
        }
        
        /**
         * åˆ›å»ºæ¡ä»¶å˜é‡
         */
        Condition newCondition() {
            return new ConditionObject();
        }
    }
    
    // ========== Lockæ¥å£å®ç° ==========
    
    @Override
    public void lock() {
        sync.acquire(1);
    }
    
    @Override
    public void lockInterruptibly() throws InterruptedException {
        sync.acquireInterruptibly(1);
    }
    
    @Override
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }
    
    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireNanos(1, unit.toNanos(time));
    }
    
    @Override
    public void unlock() {
        sync.release(1);
    }
    
    @Override
    public Condition newCondition() {
        return sync.newCondition();
    }
    
    // ========== è¾…åŠ©æ–¹æ³• ==========
    
    /**
     * æ˜¯å¦è¢«é”å®š
     */
    public boolean isLocked() {
        return sync.getState() != 0;
    }
    
    /**
     * æ˜¯å¦è¢«å½“å‰çº¿ç¨‹æŒæœ‰
     */
    public boolean isHeldByCurrentThread() {
        return sync.isHeldExclusively();
    }
    
    /**
     * è·å–é‡å…¥æ¬¡æ•°
     */
    public int getHoldCount() {
        return sync.getState();
    }
}
```

### 2.4 æµ‹è¯•ä»£ç 

```java
public static void testCustomMutex() throws InterruptedException {
    CustomMutex lock = new CustomMutex();
    
    // æµ‹è¯•1ï¼šåŸºæœ¬åŠ é”è§£é”
    System.out.println("=== æµ‹è¯•1ï¼šåŸºæœ¬åŠ é”è§£é” ===");
    lock.lock();
    System.out.println("è·å–é”æˆåŠŸï¼ŒisLocked=" + lock.isLocked());
    lock.unlock();
    System.out.println("é‡Šæ”¾é”æˆåŠŸï¼ŒisLocked=" + lock.isLocked());
    
    // æµ‹è¯•2ï¼šé‡å…¥
    System.out.println("\n=== æµ‹è¯•2ï¼šé‡å…¥ ===");
    lock.lock();
    System.out.println("ç¬¬1æ¬¡åŠ é”ï¼ŒholdCount=" + lock.getHoldCount());
    lock.lock();
    System.out.println("ç¬¬2æ¬¡åŠ é”ï¼ŒholdCount=" + lock.getHoldCount());
    lock.unlock();
    System.out.println("ç¬¬1æ¬¡è§£é”ï¼ŒholdCount=" + lock.getHoldCount());
    lock.unlock();
    System.out.println("ç¬¬2æ¬¡è§£é”ï¼ŒholdCount=" + lock.getHoldCount());
    
    // æµ‹è¯•3ï¼šå¤šçº¿ç¨‹ç«äº‰
    System.out.println("\n=== æµ‹è¯•3ï¼šå¤šçº¿ç¨‹ç«äº‰ ===");
    for (int i = 0; i < 3; i++) {
        final int threadId = i + 1;
        new Thread(() -> {
            lock.lock();
            try {
                System.out.println("Thread-" + threadId + " è·å–é”");
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                System.out.println("Thread-" + threadId + " é‡Šæ”¾é”");
                lock.unlock();
            }
        }).start();
    }
}
```

---

## ä¸‰ã€å®è·µ2ï¼šè‡ªå®šä¹‰ä¿¡å·é‡

### 3.1 éœ€æ±‚åˆ†æ

```
éœ€æ±‚ï¼šå®ç°ä¸€ä¸ªç®€å•çš„ä¿¡å·é‡
- é™åˆ¶åŒæ—¶è®¿é—®çš„çº¿ç¨‹æ•°
- æ”¯æŒä¸€æ¬¡è·å–/é‡Šæ”¾å¤šä¸ªè®¸å¯
- å…¬å¹³æ¨¡å¼
```

### 3.2 è®¾è®¡

```
æ¨¡å¼ï¼šå…±äº«æ¨¡å¼
stateå«ä¹‰ï¼šå¯ç”¨è®¸å¯æ•°
```

### 3.3 å®Œæ•´å®ç°

```java
package com.fragment.juc.aqs.project;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * è‡ªå®šä¹‰ä¿¡å·é‡
 * 
 * ç‰¹æ€§ï¼š
 * 1. å…±äº«æ¨¡å¼
 * 2. é™åˆ¶å¹¶å‘æ•°
 * 3. æ”¯æŒå…¬å¹³/éå…¬å¹³
 * 
 * @author huabin
 */
public class CustomSemaphore {
    
    private final Sync sync;
    
    /**
     * æ„é€ å‡½æ•°
     * 
     * @param permits è®¸å¯æ•°
     * @param fair æ˜¯å¦å…¬å¹³
     */
    public CustomSemaphore(int permits, boolean fair) {
        sync = fair ? new FairSync(permits) : new NonfairSync(permits);
    }
    
    public CustomSemaphore(int permits) {
        this(permits, false);
    }
    
    /**
     * åŒæ­¥å™¨åŸºç±»
     */
    abstract static class Sync extends AbstractQueuedSynchronizer {
        Sync(int permits) {
            setState(permits);
        }
        
        final int getPermits() {
            return getState();
        }
        
        /**
         * éå…¬å¹³è·å–
         */
        final int nonfairTryAcquireShared(int acquires) {
            for (;;) {
                int available = getState();
                int remaining = available - acquires;
                
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
        
        /**
         * é‡Šæ”¾
         */
        @Override
        protected final boolean tryReleaseShared(int releases) {
            for (;;) {
                int current = getState();
                int next = current + releases;
                
                if (next < current) // æº¢å‡ºæ£€æŸ¥
                    throw new Error("Maximum permit count exceeded");
                
                if (compareAndSetState(current, next))
                    return true;
            }
        }
    }
    
    /**
     * éå…¬å¹³åŒæ­¥å™¨
     */
    static final class NonfairSync extends Sync {
        NonfairSync(int permits) {
            super(permits);
        }
        
        @Override
        protected int tryAcquireShared(int acquires) {
            return nonfairTryAcquireShared(acquires);
        }
    }
    
    /**
     * å…¬å¹³åŒæ­¥å™¨
     */
    static final class FairSync extends Sync {
        FairSync(int permits) {
            super(permits);
        }
        
        @Override
        protected int tryAcquireShared(int acquires) {
            for (;;) {
                // å…¬å¹³ï¼šå…ˆæ£€æŸ¥é˜Ÿåˆ—
                if (hasQueuedPredecessors())
                    return -1;
                
                int available = getState();
                int remaining = available - acquires;
                
                if (remaining < 0 ||
                    compareAndSetState(available, remaining))
                    return remaining;
            }
        }
    }
    
    // ========== å…¬å…±API ==========
    
    /**
     * è·å–è®¸å¯
     */
    public void acquire() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    /**
     * è·å–å¤šä¸ªè®¸å¯
     */
    public void acquire(int permits) throws InterruptedException {
        if (permits < 0) throw new IllegalArgumentException();
        sync.acquireSharedInterruptibly(permits);
    }
    
    /**
     * å°è¯•è·å–è®¸å¯
     */
    public boolean tryAcquire() {
        return sync.nonfairTryAcquireShared(1) >= 0;
    }
    
    /**
     * è¶…æ—¶è·å–è®¸å¯
     */
    public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    
    /**
     * é‡Šæ”¾è®¸å¯
     */
    public void release() {
        sync.releaseShared(1);
    }
    
    /**
     * é‡Šæ”¾å¤šä¸ªè®¸å¯
     */
    public void release(int permits) {
        if (permits < 0) throw new IllegalArgumentException();
        sync.releaseShared(permits);
    }
    
    /**
     * è·å–å¯ç”¨è®¸å¯æ•°
     */
    public int availablePermits() {
        return sync.getPermits();
    }
}
```

### 3.4 æµ‹è¯•ä»£ç 

```java
public static void testCustomSemaphore() throws InterruptedException {
    CustomSemaphore semaphore = new CustomSemaphore(2);
    
    System.out.println("=== æµ‹è¯•ï¼šé™åˆ¶å¹¶å‘æ•°ä¸º2 ===");
    System.out.println("åˆå§‹è®¸å¯æ•°ï¼š" + semaphore.availablePermits());
    
    for (int i = 0; i < 5; i++) {
        final int threadId = i + 1;
        new Thread(() -> {
            try {
                System.out.println("Thread-" + threadId + " ç­‰å¾…è®¸å¯...");
                semaphore.acquire();
                System.out.println("Thread-" + threadId + " è·å–è®¸å¯ï¼Œå‰©ä½™ï¼š" + 
                                 semaphore.availablePermits());
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                semaphore.release();
                System.out.println("Thread-" + threadId + " é‡Šæ”¾è®¸å¯ï¼Œå‰©ä½™ï¼š" + 
                                 semaphore.availablePermits());
            }
        }).start();
        Thread.sleep(200);
    }
}
```

---

## å››ã€å®è·µ3ï¼šè‡ªå®šä¹‰å€’è®¡æ—¶é—¨æ “

### 4.1 éœ€æ±‚åˆ†æ

```
éœ€æ±‚ï¼šå®ç°ä¸€ä¸ªç®€å•çš„å€’è®¡æ—¶é—¨æ “
- ä¸»çº¿ç¨‹ç­‰å¾…å¤šä¸ªå·¥ä½œçº¿ç¨‹å®Œæˆ
- å€’è®¡æ—¶åˆ°0åå”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
- ä¸€æ¬¡æ€§ä½¿ç”¨ï¼ˆä¸å¯é‡ç½®ï¼‰
```

### 4.2 è®¾è®¡

```
æ¨¡å¼ï¼šå…±äº«æ¨¡å¼
stateå«ä¹‰ï¼šå€’è®¡æ—¶æ•°é‡
```

### 4.3 å®Œæ•´å®ç°

```java
package com.fragment.juc.aqs.project;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;

/**
 * è‡ªå®šä¹‰å€’è®¡æ—¶é—¨æ “
 * 
 * ç‰¹æ€§ï¼š
 * 1. å…±äº«æ¨¡å¼
 * 2. å€’è®¡æ—¶åˆ°0å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
 * 3. ä¸€æ¬¡æ€§ä½¿ç”¨
 * 
 * @author huabin
 */
public class CustomCountDownLatch {
    
    private final Sync sync;
    
    /**
     * æ„é€ å‡½æ•°
     * 
     * @param count å€’è®¡æ—¶æ•°é‡
     */
    public CustomCountDownLatch(int count) {
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);
    }
    
    /**
     * åŒæ­¥å™¨
     */
    private static final class Sync extends AbstractQueuedSynchronizer {
        Sync(int count) {
            setState(count);
        }
        
        int getCount() {
            return getState();
        }
        
        /**
         * å°è¯•è·å–ï¼ˆawaitï¼‰
         * 
         * @return 1è¡¨ç¤ºæˆåŠŸï¼ˆå€’è®¡æ—¶å®Œæˆï¼‰ï¼Œ-1è¡¨ç¤ºå¤±è´¥ï¼ˆéœ€è¦ç­‰å¾…ï¼‰
         */
        @Override
        protected int tryAcquireShared(int acquires) {
            return (getState() == 0) ? 1 : -1;
        }
        
        /**
         * å°è¯•é‡Šæ”¾ï¼ˆcountDownï¼‰
         * 
         * @return trueè¡¨ç¤ºå‡åˆ°0ï¼ˆå”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹ï¼‰
         */
        @Override
        protected boolean tryReleaseShared(int releases) {
            for (;;) {
                int c = getState();
                
                // å·²ç»æ˜¯0ï¼Œæ— éœ€é‡Šæ”¾
                if (c == 0)
                    return false;
                
                int nextc = c - 1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0; // å‡åˆ°0æ—¶è¿”å›true
            }
        }
    }
    
    // ========== å…¬å…±API ==========
    
    /**
     * ç­‰å¾…å€’è®¡æ—¶å®Œæˆ
     */
    public void await() throws InterruptedException {
        sync.acquireSharedInterruptibly(1);
    }
    
    /**
     * è¶…æ—¶ç­‰å¾…
     */
    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    }
    
    /**
     * å€’è®¡æ—¶
     */
    public void countDown() {
        sync.releaseShared(1);
    }
    
    /**
     * è·å–å½“å‰è®¡æ•°
     */
    public long getCount() {
        return sync.getCount();
    }
    
    @Override
    public String toString() {
        return super.toString() + "[Count = " + sync.getCount() + "]";
    }
}
```

### 4.4 æµ‹è¯•ä»£ç 

```java
public static void testCustomCountDownLatch() throws InterruptedException {
    CustomCountDownLatch latch = new CustomCountDownLatch(3);
    
    System.out.println("=== æµ‹è¯•ï¼šå€’è®¡æ—¶é—¨æ “ ===");
    System.out.println("åˆå§‹è®¡æ•°ï¼š" + latch.getCount());
    
    // ä¸»çº¿ç¨‹ç­‰å¾…
    new Thread(() -> {
        try {
            System.out.println("[ä¸»çº¿ç¨‹] ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹å®Œæˆ...");
            latch.await();
            System.out.println("[ä¸»çº¿ç¨‹] æ‰€æœ‰å·¥ä½œçº¿ç¨‹å·²å®Œæˆï¼");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
    
    // å·¥ä½œçº¿ç¨‹
    for (int i = 0; i < 3; i++) {
        final int threadId = i + 1;
        new Thread(() -> {
            try {
                Thread.sleep(threadId * 1000);
                System.out.println("[å·¥ä½œçº¿ç¨‹" + threadId + "] å®Œæˆä»»åŠ¡");
                latch.countDown();
                System.out.println("å‰©ä½™è®¡æ•°ï¼š" + latch.getCount());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }
}
```

---

## äº”ã€æœ€ä½³å®è·µä¸å¸¸è§é™·é˜±

### 5.1 æœ€ä½³å®è·µ

#### 1. æ­£ç¡®å®šä¹‰stateçš„å«ä¹‰

```java
// âœ… å¥½çš„åšæ³•ï¼šæ¸…æ™°çš„æ³¨é‡Š
/**
 * stateçš„å«ä¹‰ï¼š
 * 0 - é”ç©ºé—²
 * n - é”è¢«å ç”¨næ¬¡ï¼ˆé‡å…¥ï¼‰
 */
private static class Sync extends AbstractQueuedSynchronizer {
    // ...
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šæ²¡æœ‰æ³¨é‡Š
private static class Sync extends AbstractQueuedSynchronizer {
    // stateæ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ
}
```

#### 2. æ£€æŸ¥æº¢å‡º

```java
// âœ… å¥½çš„åšæ³•ï¼šæ£€æŸ¥æº¢å‡º
protected boolean tryAcquire(int acquires) {
    int nextc = c + acquires;
    if (nextc < 0) // æº¢å‡ºæ£€æŸ¥
        throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šä¸æ£€æŸ¥æº¢å‡º
protected boolean tryAcquire(int acquires) {
    setState(c + acquires); // å¯èƒ½æº¢å‡º
    return true;
}
```

#### 3. æ£€æŸ¥çº¿ç¨‹æ‰€æœ‰æƒ

```java
// âœ… å¥½çš„åšæ³•ï¼šæ£€æŸ¥çº¿ç¨‹
protected boolean tryRelease(int releases) {
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    // ...
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šä¸æ£€æŸ¥çº¿ç¨‹
protected boolean tryRelease(int releases) {
    setState(getState() - releases); // ä»»ä½•çº¿ç¨‹éƒ½èƒ½é‡Šæ”¾
    return true;
}
```

#### 4. ä½¿ç”¨CASæ›´æ–°state

```java
// âœ… å¥½çš„åšæ³•ï¼šä½¿ç”¨CAS
protected int tryAcquireShared(int acquires) {
    for (;;) {
        int available = getState();
        int remaining = available - acquires;
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}

// âŒ ä¸å¥½çš„åšæ³•ï¼šç›´æ¥è®¾ç½®
protected int tryAcquireShared(int acquires) {
    int available = getState();
    setState(available - acquires); // ç«æ€æ¡ä»¶ï¼
    return available - acquires;
}
```

---

### 5.2 å¸¸è§é™·é˜±

#### é™·é˜±1ï¼šå¿˜è®°é‡Šæ”¾é”

```java
// âŒ é”™è¯¯ï¼šæ²¡æœ‰finally
lock.lock();
doSomething(); // å¯èƒ½æŠ›å¼‚å¸¸
lock.unlock(); // å¯èƒ½ä¸æ‰§è¡Œ

// âœ… æ­£ç¡®ï¼šä½¿ç”¨finally
lock.lock();
try {
    doSomething();
} finally {
    lock.unlock(); // æ€»æ˜¯æ‰§è¡Œ
}
```

#### é™·é˜±2ï¼šé‡å¤é‡Šæ”¾

```java
// âŒ é”™è¯¯ï¼šé‡å¤é‡Šæ”¾
lock.lock();
try {
    doSomething();
    lock.unlock(); // ç¬¬1æ¬¡é‡Šæ”¾
} finally {
    lock.unlock(); // ç¬¬2æ¬¡é‡Šæ”¾ï¼ŒæŠ›å¼‚å¸¸
}

// âœ… æ­£ç¡®ï¼šåªåœ¨finallyä¸­é‡Šæ”¾
lock.lock();
try {
    doSomething();
} finally {
    lock.unlock(); // åªé‡Šæ”¾ä¸€æ¬¡
}
```

#### é™·é˜±3ï¼šæ­»é”

```java
// âŒ é”™è¯¯ï¼šå¯èƒ½æ­»é”
void method1() {
    lock1.lock();
    lock2.lock();
    // ...
    lock2.unlock();
    lock1.unlock();
}

void method2() {
    lock2.lock(); // é¡ºåºç›¸å
    lock1.lock();
    // ...
    lock1.unlock();
    lock2.unlock();
}

// âœ… æ­£ç¡®ï¼šç»Ÿä¸€é¡ºåº
void method1() {
    lock1.lock();
    lock2.lock();
    // ...
}

void method2() {
    lock1.lock(); // ç›¸åŒé¡ºåº
    lock2.lock();
    // ...
}
```

#### é™·é˜±4ï¼šä¸­æ–­å¤„ç†ä¸å½“

```java
// âŒ é”™è¯¯ï¼šå¿½ç•¥ä¸­æ–­
lock.lockInterruptibly();
try {
    doSomething();
} catch (InterruptedException e) {
    // ä»€ä¹ˆéƒ½ä¸åš
}

// âœ… æ­£ç¡®ï¼šæ¢å¤ä¸­æ–­çŠ¶æ€
lock.lockInterruptibly();
try {
    doSomething();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // æ¢å¤ä¸­æ–­çŠ¶æ€
    throw e; // æˆ–è€…é€‚å½“å¤„ç†
}
```

---

## å…­ã€æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 6.1 å‡å°‘CASå¤±è´¥

```java
// ä¼˜åŒ–å‰ï¼šæ€»æ˜¯CAS
protected boolean tryAcquire(int acquires) {
    if (compareAndSetState(0, acquires)) {
        setExclusiveOwnerThread(Thread.currentThread());
        return true;
    }
    return false;
}

// ä¼˜åŒ–åï¼šå…ˆæ£€æŸ¥å†CAS
protected boolean tryAcquire(int acquires) {
    int c = getState();
    if (c == 0) { // å…ˆæ£€æŸ¥
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
    }
    return false;
}
```

### 6.2 å¿«é€Ÿè·¯å¾„ä¼˜åŒ–

```java
// å‚è€ƒAQSçš„addWaiter
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    
    // å¿«é€Ÿè·¯å¾„ï¼šé˜Ÿåˆ—å·²åˆå§‹åŒ–ï¼Œä¸€æ¬¡CASæˆåŠŸ
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    
    // æ…¢é€Ÿè·¯å¾„ï¼šå¤„ç†åˆå§‹åŒ–å’ŒCASå¤±è´¥
    enq(node);
    return node;
}
```

---

## ä¸ƒã€æ€»ç»“

### 7.1 è‡ªå®šä¹‰åŒæ­¥å™¨çš„å…³é”®ç‚¹

1. **æ˜ç¡®stateå«ä¹‰**ï¼šæ¸…æ™°å®šä¹‰stateçš„è¯­ä¹‰
2. **é€‰æ‹©æ­£ç¡®æ¨¡å¼**ï¼šç‹¬å è¿˜æ˜¯å…±äº«
3. **å®ç°æ ¸å¿ƒæ–¹æ³•**ï¼štryAcquire/tryReleaseæˆ–tryAcquireShared/tryReleaseShared
4. **å¤„ç†è¾¹ç•Œæƒ…å†µ**ï¼šæº¢å‡ºã€çº¿ç¨‹æ£€æŸ¥ã€ä¸­æ–­
5. **æä¾›å‹å¥½API**ï¼šå°è£…AQSçš„å¤æ‚æ€§

### 7.2 æœ€ä½³å®è·µæ€»ç»“

```
âœ… ä½¿ç”¨finallyé‡Šæ”¾é”
âœ… æ£€æŸ¥æº¢å‡º
âœ… æ£€æŸ¥çº¿ç¨‹æ‰€æœ‰æƒ
âœ… ä½¿ç”¨CASæ›´æ–°state
âœ… æ­£ç¡®å¤„ç†ä¸­æ–­
âœ… é¿å…æ­»é”
âœ… æ·»åŠ æ¸…æ™°çš„æ³¨é‡Š
```

### 7.3 æ€è€ƒé¢˜

1. **ä¸ºä»€ä¹ˆè‡ªå®šä¹‰åŒæ­¥å™¨é€šå¸¸ä½¿ç”¨å†…éƒ¨ç±»ï¼Ÿ**
2. **å¦‚ä½•å®ç°ä¸€ä¸ªå¯é‡ç½®çš„CountDownLatchï¼Ÿ**
3. **å¦‚ä½•å®ç°ä¸€ä¸ªè¯»å†™é”ï¼Ÿ**
4. **å¦‚ä½•å®ç°ä¸€ä¸ªå…¬å¹³çš„äº’æ–¥é”ï¼Ÿ**

---

## å…«ã€è¿›é˜¶è¯é¢˜

### 8.1 Conditionçš„ä½¿ç”¨

```java
// ä½¿ç”¨ConditionObjectå®ç°æ¡ä»¶é˜Ÿåˆ—
class BoundedBuffer {
    final Lock lock = new ReentrantLock();
    final Condition notFull = lock.newCondition();
    final Condition notEmpty = lock.newCondition();
    
    final Object[] items = new Object[100];
    int putptr, takeptr, count;
    
    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length)
                notFull.await(); // é˜Ÿåˆ—æ»¡ï¼Œç­‰å¾…
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal(); // é€šçŸ¥æ¶ˆè´¹è€…
        } finally {
            lock.unlock();
        }
    }
    
    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0)
                notEmpty.await(); // é˜Ÿåˆ—ç©ºï¼Œç­‰å¾…
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal(); // é€šçŸ¥ç”Ÿäº§è€…
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

### 8.2 è‡ªå®šä¹‰å…¬å¹³ç­–ç•¥

```java
// å®ç°è‡ªå®šä¹‰çš„å…¬å¹³ç­–ç•¥
protected boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    if (c == 0) {
        // è‡ªå®šä¹‰å…¬å¹³ç­–ç•¥ï¼šæ£€æŸ¥æ˜¯å¦æœ‰ç­‰å¾…æ›´ä¹…çš„çº¿ç¨‹
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // ...
}
```

---

**å‚è€ƒèµ„æ–™**ï¼š
- JDKæºç ï¼š`java.util.concurrent.locks.ReentrantLock`
- JDKæºç ï¼š`java.util.concurrent.Semaphore`
- JDKæºç ï¼š`java.util.concurrent.CountDownLatch`
- ã€ŠJavaå¹¶å‘ç¼–ç¨‹å®æˆ˜ã€‹ç¬¬14ç« ï¼šæ„å»ºè‡ªå®šä¹‰çš„åŒæ­¥å·¥å…·

---

**æ­å–œï¼ä½ å·²ç»å®Œæˆäº†AQSçš„æ·±åº¦å­¦ä¹ ï¼** ğŸ‰
