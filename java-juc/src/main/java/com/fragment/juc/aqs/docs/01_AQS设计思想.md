# ç¬¬ä¸€ç« ï¼šAQSè®¾è®¡æ€æƒ³ä¸æ ¸å¿ƒåŸç†

> **å­¦ä¹ ç›®æ ‡**ï¼šç†è§£ä¸ºä»€ä¹ˆéœ€è¦AQSï¼Œä»¥åŠAQSçš„æ ¸å¿ƒè®¾è®¡æ€æƒ³

---

## ä¸€ã€ä¸ºä»€ä¹ˆéœ€è¦AQSï¼Ÿ

### 1.1 é—®é¢˜èƒŒæ™¯ï¼šé‡å¤é€ è½®å­çš„å›°å¢ƒ

åœ¨AQSå‡ºç°ä¹‹å‰ï¼Œå¦‚æœæˆ‘ä»¬è¦å®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„åŒæ­¥å™¨ï¼ˆå¦‚é”ã€ä¿¡å·é‡ç­‰ï¼‰ï¼Œä¼šé‡åˆ°ä»¥ä¸‹é—®é¢˜ï¼š

#### é—®é¢˜1ï¼šæ¯ä¸ªåŒæ­¥å™¨éƒ½è¦é‡å¤å®ç°ç›¸åŒçš„é€»è¾‘

```java
// å®ç°ä¸€ä¸ªç®€å•çš„äº’æ–¥é”ï¼Œéœ€è¦è€ƒè™‘ï¼š
public class SimpleLock {
    private volatile boolean locked = false;
    
    public void lock() {
        // âŒ é—®é¢˜1ï¼šå¦‚ä½•å®ç°ç­‰å¾…ï¼Ÿå¿™ç­‰å¾…(busy-wait)ä¼šæµªè´¹CPU
        while (locked) {
            // è‡ªæ—‹ç­‰å¾…ï¼ŒCPUç©ºè½¬
        }
        locked = true;
    }
    
    public void unlock() {
        locked = false;
    }
}
```

**å­˜åœ¨çš„é—®é¢˜**ï¼š
- âŒ å¿™ç­‰å¾…æµªè´¹CPUèµ„æº
- âŒ æ²¡æœ‰å…¬å¹³æ€§ä¿è¯
- âŒ ä¸æ”¯æŒä¸­æ–­
- âŒ ä¸æ”¯æŒè¶…æ—¶

#### é—®é¢˜2ï¼šå¦‚ä½•é«˜æ•ˆåœ°ç®¡ç†ç­‰å¾…çº¿ç¨‹ï¼Ÿ

```java
// å°è¯•ç”¨wait/notifyå®ç°
public class WaitNotifyLock {
    private boolean locked = false;
    
    public synchronized void lock() throws InterruptedException {
        // âŒ é—®é¢˜2ï¼šå¦‚ä½•ä¿è¯FIFOé¡ºåºï¼Ÿ
        while (locked) {
            wait(); // æ‰€æœ‰çº¿ç¨‹éƒ½åœ¨ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œæ— åºå”¤é†’
        }
        locked = true;
    }
    
    public synchronized void unlock() {
        locked = false;
        notify(); // âŒ é—®é¢˜3ï¼šå”¤é†’å“ªä¸ªçº¿ç¨‹ï¼Ÿä¸å¯æ§
    }
}
```

**å­˜åœ¨çš„é—®é¢˜**ï¼š
- âŒ wait/notifyæ— æ³•ä¿è¯FIFOé¡ºåº
- âŒ notify()éšæœºå”¤é†’ï¼Œæ— æ³•ç²¾ç¡®æ§åˆ¶
- âŒ éœ€è¦åœ¨synchronizedå—å†…è°ƒç”¨ï¼Œé™åˆ¶äº†çµæ´»æ€§

#### é—®é¢˜3ï¼šå¦‚ä½•å®ç°å¯é‡å…¥ã€å…¬å¹³æ€§ã€å…±äº«ç­‰é«˜çº§ç‰¹æ€§ï¼Ÿ

æ¯ä¸ªåŒæ­¥å™¨éƒ½éœ€è¦ï¼š
- å®ç°çº¿ç¨‹ç­‰å¾…é˜Ÿåˆ—
- å®ç°é˜»å¡å’Œå”¤é†’æœºåˆ¶
- å¤„ç†ä¸­æ–­å’Œè¶…æ—¶
- ä¿è¯å†…å­˜å¯è§æ€§
- å®ç°å…¬å¹³æ€§ç­–ç•¥

**è¿™äº›é€»è¾‘é«˜åº¦ç›¸ä¼¼ï¼Œä½†æ¯æ¬¡éƒ½è¦é‡æ–°å®ç°ï¼**

---

### 1.2 AQSçš„è§£å†³æ–¹æ¡ˆï¼šæä¾›åŒæ­¥å™¨æ¡†æ¶

Doug Leaè®¾è®¡AQSçš„æ ¸å¿ƒæ€æƒ³ï¼š

> **å°†åŒæ­¥å™¨çš„"å…±æ€§"æŠ½å–å‡ºæ¥ï¼Œå½¢æˆæ¡†æ¶ï¼›å°†"ä¸ªæ€§"ç•™ç»™å­ç±»å®ç°**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           AQSæ¡†æ¶ï¼ˆå…±æ€§ï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ âœ… ç­‰å¾…é˜Ÿåˆ—ç®¡ç†ï¼ˆCLHé˜Ÿåˆ—ï¼‰                â”‚
â”‚ âœ… çº¿ç¨‹é˜»å¡å’Œå”¤é†’ï¼ˆLockSupportï¼‰          â”‚
â”‚ âœ… ä¸­æ–­å¤„ç†                              â”‚
â”‚ âœ… è¶…æ—¶æ§åˆ¶                              â”‚
â”‚ âœ… å…¬å¹³æ€§ç­–ç•¥                            â”‚
â”‚ âœ… ç‹¬å /å…±äº«æ¨¡å¼                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘
              â”‚ ç»§æ‰¿å¹¶å®ç°æ¨¡æ¿æ–¹æ³•
              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        å­ç±»åŒæ­¥å™¨ï¼ˆä¸ªæ€§ï¼‰                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”§ tryAcquire()    - å¦‚ä½•è·å–é”          â”‚
â”‚ ğŸ”§ tryRelease()    - å¦‚ä½•é‡Šæ”¾é”          â”‚
â”‚ ğŸ”§ tryAcquireShared() - å¦‚ä½•å…±äº«è·å–     â”‚
â”‚ ğŸ”§ tryReleaseShared() - å¦‚ä½•å…±äº«é‡Šæ”¾     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€AQSçš„æ ¸å¿ƒè®¾è®¡æ€æƒ³

### 2.1 è®¾è®¡æ€æƒ³1ï¼šæ¨¡æ¿æ–¹æ³•æ¨¡å¼

#### ä»€ä¹ˆæ˜¯æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Ÿ

```java
// AQSå®šä¹‰ç®—æ³•éª¨æ¶
public abstract class AbstractQueuedSynchronizer {
    
    // æ¨¡æ¿æ–¹æ³•ï¼šå®šä¹‰è·å–é”çš„å®Œæ•´æµç¨‹ï¼ˆfinalï¼Œä¸å¯é‡å†™ï¼‰
    public final void acquire(int arg) {
        // 1. å…ˆå°è¯•è·å–ï¼ˆå­ç±»å®ç°ï¼‰
        if (!tryAcquire(arg)) {
            // 2. è·å–å¤±è´¥ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—ï¼ˆAQSå®ç°ï¼‰
            Node node = addWaiter(Node.EXCLUSIVE);
            // 3. åœ¨é˜Ÿåˆ—ä¸­é˜»å¡ç­‰å¾…ï¼ˆAQSå®ç°ï¼‰
            acquireQueued(node, arg);
        }
    }
    
    // é’©å­æ–¹æ³•ï¼šç”±å­ç±»å®ç°å…·ä½“çš„è·å–é€»è¾‘
    protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
}
```

#### ä¸ºä»€ä¹ˆä½¿ç”¨æ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Ÿ

**ä¼˜åŠ¿**ï¼š
1. **ä»£ç å¤ç”¨**ï¼šé˜Ÿåˆ—ç®¡ç†ã€é˜»å¡å”¤é†’ç­‰å¤æ‚é€»è¾‘åªéœ€å®ç°ä¸€æ¬¡
2. **å…³æ³¨ç‚¹åˆ†ç¦»**ï¼šå­ç±»åªéœ€å…³æ³¨"å¦‚ä½•åˆ¤æ–­èƒ½å¦è·å–é”"
3. **æ‰©å±•æ€§å¼º**ï¼šå¯ä»¥è½»æ¾å®ç°å„ç§åŒæ­¥å™¨

**ç¤ºä¾‹ï¼šReentrantLockçš„å®ç°**

```java
// ReentrantLockåªéœ€å®ç°tryAcquire
static final class NonfairSync extends Sync {
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        
        // ä¸ªæ€§åŒ–é€»è¾‘ï¼šåˆ¤æ–­èƒ½å¦è·å–é”
        if (c == 0) {
            // é”ç©ºé—²ï¼Œå°è¯•CASè·å–
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        } else if (current == getExclusiveOwnerThread()) {
            // å¯é‡å…¥ï¼šå½“å‰çº¿ç¨‹å·²æŒæœ‰é”
            int nextc = c + acquires;
            setState(nextc);
            return true;
        }
        return false;
    }
}
```

**å¯¹æ¯”ï¼šå¦‚æœæ²¡æœ‰AQS**

```java
// æ¯ä¸ªé”éƒ½è¦å®ç°å®Œæ•´çš„é˜Ÿåˆ—ç®¡ç†
public class MyLock {
    private Queue<Thread> waitQueue = new LinkedList<>(); // æ‰‹åŠ¨ç®¡ç†é˜Ÿåˆ—
    private volatile int state = 0;
    
    public void lock() {
        if (!tryAcquire()) {
            // æ‰‹åŠ¨å®ç°é˜Ÿåˆ—ç®¡ç†
            waitQueue.add(Thread.currentThread());
            // æ‰‹åŠ¨å®ç°é˜»å¡
            LockSupport.park();
            // æ‰‹åŠ¨å¤„ç†ä¸­æ–­
            // æ‰‹åŠ¨å¤„ç†è¶…æ—¶
            // ... å¤§é‡é‡å¤ä»£ç 
        }
    }
}
```

---

### 2.2 è®¾è®¡æ€æƒ³2ï¼šçŠ¶æ€ç®¡ç†ï¼ˆstateï¼‰

#### ä¸ºä»€ä¹ˆéœ€è¦stateï¼Ÿ

**é—®é¢˜**ï¼šå¦‚ä½•ç”¨ä¸€ä¸ªå˜é‡è¡¨ç¤ºåŒæ­¥å™¨çš„çŠ¶æ€ï¼Ÿ

AQSä½¿ç”¨ä¸€ä¸ª`volatile int state`è¡¨ç¤ºåŒæ­¥çŠ¶æ€ï¼š

```java
public abstract class AbstractQueuedSynchronizer {
    /**
     * åŒæ­¥çŠ¶æ€
     * - volatileä¿è¯å¯è§æ€§
     * - é€šè¿‡CASä¿è¯åŸå­æ€§
     */
    private volatile int state;
    
    // è·å–çŠ¶æ€
    protected final int getState() {
        return state;
    }
    
    // è®¾ç½®çŠ¶æ€
    protected final void setState(int newState) {
        state = newState;
    }
    
    // CASæ›´æ–°çŠ¶æ€
    protected final boolean compareAndSetState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
}
```

#### stateçš„å«ä¹‰ç”±å­ç±»å®šä¹‰

ä¸åŒçš„åŒæ­¥å™¨ï¼Œstateæœ‰ä¸åŒçš„å«ä¹‰ï¼š

```java
// 1. ReentrantLockï¼šstateè¡¨ç¤ºé‡å…¥æ¬¡æ•°
state = 0  â†’ é”ç©ºé—²
state = 1  â†’ é”è¢«å ç”¨1æ¬¡
state = 2  â†’ é”è¢«é‡å…¥2æ¬¡

// 2. Semaphoreï¼šstateè¡¨ç¤ºå¯ç”¨è®¸å¯æ•°
state = 3  â†’ è¿˜æœ‰3ä¸ªè®¸å¯å¯ç”¨
state = 0  â†’ è®¸å¯å·²ç”¨å®Œ

// 3. CountDownLatchï¼šstateè¡¨ç¤ºå€’è®¡æ—¶æ•°é‡
state = 5  â†’ è¿˜éœ€è¦5æ¬¡countDown
state = 0  â†’ å€’è®¡æ—¶å®Œæˆ

// 4. ReentrantReadWriteLockï¼šstateçš„é«˜16ä½å’Œä½16ä½åˆ†åˆ«è¡¨ç¤ºè¯»é”å’Œå†™é”
state = 0x00010000  â†’ 1ä¸ªè¯»é”
state = 0x00000001  â†’ 1ä¸ªå†™é”
state = 0x00020001  â†’ 2ä¸ªè¯»é” + 1ä¸ªå†™é”
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

**ä¼˜åŠ¿**ï¼š
1. **çµæ´»æ€§**ï¼šä¸€ä¸ªintå¯ä»¥è¡¨ç¤ºå¤šç§å«ä¹‰
2. **é«˜æ•ˆæ€§**ï¼šintæ“ä½œé«˜æ•ˆï¼ŒCASæ€§èƒ½å¥½
3. **ç®€æ´æ€§**ï¼šé¿å…å¤æ‚çš„çŠ¶æ€å¯¹è±¡

**ç¤ºä¾‹ï¼šSemaphoreçš„å®ç°**

```java
// Semaphoreä½¿ç”¨stateè¡¨ç¤ºè®¸å¯æ•°
protected int tryAcquireShared(int acquires) {
    for (;;) {
        int available = getState(); // è·å–å¯ç”¨è®¸å¯æ•°
        int remaining = available - acquires;
        
        // å¦‚æœè®¸å¯ä¸è¶³ï¼Œæˆ–è€…CASæˆåŠŸï¼Œè¿”å›
        if (remaining < 0 ||
            compareAndSetState(available, remaining))
            return remaining;
    }
}
```

---

### 2.3 è®¾è®¡æ€æƒ³3ï¼šCLHé˜Ÿåˆ—ï¼ˆç­‰å¾…é˜Ÿåˆ—ï¼‰

#### ä¸ºä»€ä¹ˆéœ€è¦é˜Ÿåˆ—ï¼Ÿ

**é—®é¢˜**ï¼šå½“å¤šä¸ªçº¿ç¨‹ç«äº‰é”å¤±è´¥æ—¶ï¼Œå¦‚ä½•ç®¡ç†è¿™äº›ç­‰å¾…çš„çº¿ç¨‹ï¼Ÿ

**è¦æ±‚**ï¼š
- âœ… FIFOé¡ºåºï¼ˆå…¬å¹³æ€§ï¼‰
- âœ… é«˜æ•ˆçš„å…¥é˜Ÿ/å‡ºé˜Ÿ
- âœ… æ”¯æŒä¸­æ–­å’Œè¶…æ—¶
- âœ… é¿å…æƒŠç¾¤æ•ˆåº”ï¼ˆåªå”¤é†’ä¸‹ä¸€ä¸ªçº¿ç¨‹ï¼‰

#### CLHé˜Ÿåˆ—çš„ç»“æ„

AQSä½¿ç”¨**å˜ç§çš„CLHé˜Ÿåˆ—**ï¼ˆåŒå‘é“¾è¡¨ï¼‰ï¼š

```
head                                    tail
  â†“                                       â†“
â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”
â”‚Nodeâ”‚ â†â†’ â”‚Nodeâ”‚ â†â†’ â”‚Nodeâ”‚ â†â†’ â”‚Nodeâ”‚
â”‚ 1  â”‚    â”‚ 2  â”‚    â”‚ 3  â”‚    â”‚ 4  â”‚
â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”˜
 å“¨å…µ      ç­‰å¾…      ç­‰å¾…      ç­‰å¾…
 èŠ‚ç‚¹      çº¿ç¨‹1     çº¿ç¨‹2     çº¿ç¨‹3
```

#### NodeèŠ‚ç‚¹çš„ç»“æ„

```java
static final class Node {
    // èŠ‚ç‚¹æ¨¡å¼
    static final Node SHARED = new Node();    // å…±äº«æ¨¡å¼
    static final Node EXCLUSIVE = null;       // ç‹¬å æ¨¡å¼
    
    // ç­‰å¾…çŠ¶æ€
    static final int CANCELLED =  1;  // å–æ¶ˆ
    static final int SIGNAL    = -1;  // éœ€è¦å”¤é†’åç»§èŠ‚ç‚¹
    static final int CONDITION = -2;  // åœ¨æ¡ä»¶é˜Ÿåˆ—ä¸­
    static final int PROPAGATE = -3;  // å…±äº«æ¨¡å¼ä¸‹ä¼ æ’­
    
    volatile int waitStatus;          // ç­‰å¾…çŠ¶æ€
    volatile Node prev;               // å‰é©±èŠ‚ç‚¹
    volatile Node next;               // åç»§èŠ‚ç‚¹
    volatile Thread thread;           // ç­‰å¾…çš„çº¿ç¨‹
    Node nextWaiter;                  // æ¡ä»¶é˜Ÿåˆ—çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
}
```

#### ä¸ºä»€ä¹ˆä½¿ç”¨åŒå‘é“¾è¡¨ï¼Ÿ

**å•å‘é“¾è¡¨çš„é—®é¢˜**ï¼š
```
head â†’ Node1 â†’ Node2 â†’ Node3 â†’ tail

// å¦‚æœNode2è¢«å–æ¶ˆï¼Œå¦‚ä½•è®©Node1æŒ‡å‘Node3ï¼Ÿ
// å•å‘é“¾è¡¨éœ€è¦ä»headéå†ï¼Œæ•ˆç‡ä½
```

**åŒå‘é“¾è¡¨çš„ä¼˜åŠ¿**ï¼š
```
head â†â†’ Node1 â†â†’ Node2 â†â†’ Node3 â†â†’ tail

// Node2è¢«å–æ¶ˆæ—¶ï¼Œå¯ä»¥ç›´æ¥ï¼š
Node1.next = Node3
Node3.prev = Node1
// O(1)æ—¶é—´å¤æ‚åº¦
```

#### å…¥é˜Ÿæ“ä½œï¼ˆenqï¼‰

```java
private Node enq(final Node node) {
    for (;;) {  // è‡ªæ—‹CAS
        Node t = tail;
        if (t == null) {
            // é˜Ÿåˆ—ä¸ºç©ºï¼Œåˆå§‹åŒ–
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            // åŠ å…¥é˜Ÿå°¾
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
```

**ä¸ºä»€ä¹ˆä½¿ç”¨è‡ªæ—‹CASï¼Ÿ**
- âœ… é¿å…é”ç«äº‰
- âœ… ä¿è¯çº¿ç¨‹å®‰å…¨
- âœ… é«˜å¹¶å‘ä¸‹æ€§èƒ½å¥½

---

### 2.4 è®¾è®¡æ€æƒ³4ï¼šç‹¬å æ¨¡å¼ vs å…±äº«æ¨¡å¼

#### ä¸ºä»€ä¹ˆéœ€è¦ä¸¤ç§æ¨¡å¼ï¼Ÿ

**ç‹¬å æ¨¡å¼ï¼ˆExclusiveï¼‰**ï¼š
- åŒä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–
- ä¾‹å¦‚ï¼šReentrantLockã€å†™é”

**å…±äº«æ¨¡å¼ï¼ˆSharedï¼‰**ï¼š
- åŒä¸€æ—¶åˆ»å¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹è·å–
- ä¾‹å¦‚ï¼šSemaphoreã€è¯»é”ã€CountDownLatch

#### ä¸¤ç§æ¨¡å¼çš„åŒºåˆ«

```java
// ç‹¬å æ¨¡å¼ï¼šacquire
public final void acquire(int arg) {
    if (!tryAcquire(arg)) {
        // åŠ å…¥ç‹¬å é˜Ÿåˆ—
        Node node = addWaiter(Node.EXCLUSIVE);
        acquireQueued(node, arg);
    }
}

// å…±äº«æ¨¡å¼ï¼šacquireShared
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) < 0) {
        // åŠ å…¥å…±äº«é˜Ÿåˆ—
        doAcquireShared(arg);
    }
}
```

**å…³é”®åŒºåˆ«**ï¼š

| ç‰¹æ€§ | ç‹¬å æ¨¡å¼ | å…±äº«æ¨¡å¼ |
|------|---------|---------|
| è·å–æ–¹æ³• | tryAcquire() è¿”å›boolean | tryAcquireShared() è¿”å›int |
| é‡Šæ”¾ä¼ æ’­ | åªå”¤é†’ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ | å¯èƒ½å”¤é†’å¤šä¸ªèŠ‚ç‚¹ï¼ˆä¼ æ’­ï¼‰ |
| å…¸å‹åº”ç”¨ | äº’æ–¥é” | ä¿¡å·é‡ã€è¯»é” |

#### å…±äº«æ¨¡å¼çš„ä¼ æ’­æœºåˆ¶

```
åœºæ™¯ï¼šSemaphoreæœ‰3ä¸ªè®¸å¯ï¼Œ4ä¸ªçº¿ç¨‹ç­‰å¾…

head â†’ Thread1 â†’ Thread2 â†’ Thread3 â†’ Thread4
       (ç­‰å¾…1)   (ç­‰å¾…1)   (ç­‰å¾…1)   (ç­‰å¾…1)

é‡Šæ”¾3ä¸ªè®¸å¯åï¼š
1. Thread1è¢«å”¤é†’ï¼Œè·å–1ä¸ªè®¸å¯ï¼Œå‰©ä½™2ä¸ª
2. Thread1å”¤é†’Thread2ï¼ˆä¼ æ’­ï¼‰
3. Thread2è·å–1ä¸ªè®¸å¯ï¼Œå‰©ä½™1ä¸ª
4. Thread2å”¤é†’Thread3ï¼ˆä¼ æ’­ï¼‰
5. Thread3è·å–1ä¸ªè®¸å¯ï¼Œå‰©ä½™0ä¸ª
6. Thread4ç»§ç»­ç­‰å¾…
```

---

## ä¸‰ã€AQSçš„æ ¸å¿ƒç»„ä»¶

### 3.1 æ ¸å¿ƒå­—æ®µ

```java
public abstract class AbstractQueuedSynchronizer {
    // 1. åŒæ­¥çŠ¶æ€
    private volatile int state;
    
    // 2. é˜Ÿåˆ—å¤´èŠ‚ç‚¹
    private transient volatile Node head;
    
    // 3. é˜Ÿåˆ—å°¾èŠ‚ç‚¹
    private transient volatile Node tail;
    
    // 4. ç‹¬å æ¨¡å¼ä¸‹çš„æŒæœ‰çº¿ç¨‹
    private transient Thread exclusiveOwnerThread;
}
```

### 3.2 æ ¸å¿ƒæ–¹æ³•

#### éœ€è¦å­ç±»å®ç°çš„æ–¹æ³•ï¼ˆé’©å­æ–¹æ³•ï¼‰

```java
// ç‹¬å æ¨¡å¼
protected boolean tryAcquire(int arg);        // å°è¯•è·å–
protected boolean tryRelease(int arg);        // å°è¯•é‡Šæ”¾

// å…±äº«æ¨¡å¼
protected int tryAcquireShared(int arg);      // å°è¯•å…±äº«è·å–
protected boolean tryReleaseShared(int arg);  // å°è¯•å…±äº«é‡Šæ”¾

// å…¶ä»–
protected boolean isHeldExclusively();        // æ˜¯å¦è¢«å½“å‰çº¿ç¨‹ç‹¬å 
```

#### AQSæä¾›çš„æ¨¡æ¿æ–¹æ³•ï¼ˆfinalï¼‰

```java
// ç‹¬å æ¨¡å¼
public final void acquire(int arg);                    // è·å–ï¼ˆé˜»å¡ï¼‰
public final void acquireInterruptibly(int arg);       // è·å–ï¼ˆå¯ä¸­æ–­ï¼‰
public final boolean tryAcquireNanos(int arg, long ns);// è·å–ï¼ˆè¶…æ—¶ï¼‰
public final boolean release(int arg);                 // é‡Šæ”¾

// å…±äº«æ¨¡å¼
public final void acquireShared(int arg);              // å…±äº«è·å–
public final void acquireSharedInterruptibly(int arg); // å…±äº«è·å–ï¼ˆå¯ä¸­æ–­ï¼‰
public final boolean tryAcquireSharedNanos(int arg, long ns); // å…±äº«è·å–ï¼ˆè¶…æ—¶ï¼‰
public final boolean releaseShared(int arg);           // å…±äº«é‡Šæ”¾
```

---

## å››ã€AQSçš„è®¾è®¡ä¼˜åŠ¿

### 4.1 å¯¹æ¯”ï¼šæ²¡æœ‰AQSçš„æ—¶ä»£

åœ¨JDK 1.5ä¹‹å‰ï¼ˆAQSå‡ºç°ä¹‹å‰ï¼‰ï¼š

```java
// åªèƒ½ä½¿ç”¨synchronized
public class Counter {
    private int count = 0;
    
    public synchronized void increment() {
        count++;
    }
}
```

**synchronizedçš„å±€é™**ï¼š
- âŒ ä¸æ”¯æŒéé˜»å¡è·å–ï¼ˆtryLockï¼‰
- âŒ ä¸æ”¯æŒè¶…æ—¶è·å–
- âŒ ä¸æ”¯æŒä¸­æ–­
- âŒ ä¸æ”¯æŒå…¬å¹³æ€§é€‰æ‹©
- âŒ ä¸æ”¯æŒè¯»å†™åˆ†ç¦»
- âŒ æ€§èƒ½è¾ƒå·®ï¼ˆæ—©æœŸç‰ˆæœ¬ï¼‰

### 4.2 AQSå¸¦æ¥çš„å˜é©

```java
// åŸºäºAQSçš„ReentrantLock
ReentrantLock lock = new ReentrantLock();

// âœ… æ”¯æŒéé˜»å¡è·å–
if (lock.tryLock()) {
    try {
        // ä¸šåŠ¡é€»è¾‘
    } finally {
        lock.unlock();
    }
}

// âœ… æ”¯æŒè¶…æ—¶
if (lock.tryLock(1, TimeUnit.SECONDS)) {
    // ...
}

// âœ… æ”¯æŒä¸­æ–­
lock.lockInterruptibly();

// âœ… æ”¯æŒå…¬å¹³æ€§
ReentrantLock fairLock = new ReentrantLock(true);
```

### 4.3 AQSçš„æ ¸å¿ƒä»·å€¼

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          AQSçš„æ ¸å¿ƒä»·å€¼                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. ä»£ç å¤ç”¨                              â”‚
â”‚    - é˜Ÿåˆ—ç®¡ç†ã€é˜»å¡å”¤é†’ç­‰é€»è¾‘åªéœ€å®ç°ä¸€æ¬¡  â”‚
â”‚                                          â”‚
â”‚ 2. æ€§èƒ½ä¼˜åŒ–                              â”‚
â”‚    - CAS + volatileï¼Œé¿å…é‡é‡çº§é”         â”‚
â”‚    - è‡ªæ—‹ + é˜»å¡ï¼Œå¹³è¡¡CPUå’Œå“åº”æ—¶é—´       â”‚
â”‚                                          â”‚
â”‚ 3. åŠŸèƒ½ä¸°å¯Œ                              â”‚
â”‚    - æ”¯æŒä¸­æ–­ã€è¶…æ—¶ã€å…¬å¹³æ€§               â”‚
â”‚    - æ”¯æŒç‹¬å å’Œå…±äº«æ¨¡å¼                   â”‚
â”‚                                          â”‚
â”‚ 4. æ‰©å±•æ€§å¼º                              â”‚
â”‚    - è½»æ¾å®ç°è‡ªå®šä¹‰åŒæ­¥å™¨                 â”‚
â”‚    - JUCä¸­å¤§é‡åŒæ­¥å™¨éƒ½åŸºäºAQS             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äº”ã€æ€»ç»“

### 5.1 ä¸ºä»€ä¹ˆéœ€è¦AQSï¼Ÿ

1. **é¿å…é‡å¤é€ è½®å­**ï¼šé˜Ÿåˆ—ç®¡ç†ã€é˜»å¡å”¤é†’ç­‰é€»è¾‘é«˜åº¦ç›¸ä¼¼
2. **æä¾›ç»Ÿä¸€æ¡†æ¶**ï¼šæ¨¡æ¿æ–¹æ³•æ¨¡å¼ï¼Œå­ç±»åªéœ€å®ç°æ ¸å¿ƒé€»è¾‘
3. **æå‡æ€§èƒ½**ï¼šCAS + volatileï¼Œé¿å…é‡é‡çº§é”
4. **å¢å¼ºåŠŸèƒ½**ï¼šæ”¯æŒä¸­æ–­ã€è¶…æ—¶ã€å…¬å¹³æ€§ç­‰é«˜çº§ç‰¹æ€§

### 5.2 AQSçš„æ ¸å¿ƒè®¾è®¡

1. **æ¨¡æ¿æ–¹æ³•æ¨¡å¼**ï¼šæ¡†æ¶å®šä¹‰æµç¨‹ï¼Œå­ç±»å®ç°ç»†èŠ‚
2. **çŠ¶æ€ç®¡ç†ï¼ˆstateï¼‰**ï¼šä¸€ä¸ªintè¡¨ç¤ºå¤šç§å«ä¹‰
3. **CLHé˜Ÿåˆ—**ï¼šFIFOé˜Ÿåˆ—ç®¡ç†ç­‰å¾…çº¿ç¨‹
4. **ç‹¬å /å…±äº«æ¨¡å¼**ï¼šæ”¯æŒä¸åŒçš„åŒæ­¥è¯­ä¹‰

### 5.3 AQSçš„åœ°ä½

```
AQSæ˜¯JUCçš„åŸºçŸ³ï¼š

ReentrantLock â”€â”€â”
Semaphore â”€â”€â”€â”€â”€â”€â”¤
CountDownLatch â”€â”¼â”€â”€> åŸºäºAQSå®ç°
ReadWriteLock â”€â”€â”¤
ThreadPoolExecutor (é—´æ¥) â”€â”˜
```

---

## å…­ã€æ€è€ƒé¢˜

1. **ä¸ºä»€ä¹ˆAQSä½¿ç”¨intè€Œä¸æ˜¯booleanè¡¨ç¤ºçŠ¶æ€ï¼Ÿ**
   - æç¤ºï¼šè€ƒè™‘å¯é‡å…¥é”ã€ä¿¡å·é‡ç­‰åœºæ™¯

2. **ä¸ºä»€ä¹ˆAQSä½¿ç”¨åŒå‘é“¾è¡¨è€Œä¸æ˜¯å•å‘é“¾è¡¨ï¼Ÿ**
   - æç¤ºï¼šè€ƒè™‘èŠ‚ç‚¹å–æ¶ˆçš„åœºæ™¯

3. **ä¸ºä»€ä¹ˆéœ€è¦ç‹¬å å’Œå…±äº«ä¸¤ç§æ¨¡å¼ï¼Ÿ**
   - æç¤ºï¼šå¯¹æ¯”äº’æ–¥é”å’Œä¿¡å·é‡çš„åŒºåˆ«

4. **å¦‚æœæ²¡æœ‰AQSï¼Œå®ç°ä¸€ä¸ªå…¬å¹³é”éœ€è¦è€ƒè™‘å“ªäº›é—®é¢˜ï¼Ÿ**
   - æç¤ºï¼šé˜Ÿåˆ—ç®¡ç†ã€é˜»å¡å”¤é†’ã€ä¸­æ–­å¤„ç†ç­‰

---

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šæˆ‘ä»¬å°†æ·±å…¥åˆ†æAQSçš„åŒæ­¥çŠ¶æ€ç®¡ç†å’ŒCLHé˜Ÿåˆ—çš„å®ç°ç»†èŠ‚ã€‚

---

**å‚è€ƒèµ„æ–™**ï¼š
- [AQSè®ºæ–‡](http://gee.cs.oswego.edu/dl/papers/aqs.pdf) - Doug Lea
- ã€ŠJavaå¹¶å‘ç¼–ç¨‹çš„è‰ºæœ¯ã€‹ç¬¬5ç« 
- JDKæºç ï¼š`java.util.concurrent.locks.AbstractQueuedSynchronizer`
