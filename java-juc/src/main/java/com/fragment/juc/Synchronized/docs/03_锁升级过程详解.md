# 锁升级过程详解

## 1. 为什么需要锁升级？

### 1.1 问题1：重量级锁有什么问题？

在上一章我们了解到，重量级锁（Monitor）的性能开销非常大：

```
重量级锁的开销：
- 用户态 ↔ 内核态切换：1000-1500 CPU周期
- 线程阻塞/唤醒：10000 CPU周期
- 上下文切换：5000-10000 CPU周期

总开销：约 16000-21500 CPU周期
```

**对比**：

```
CAS操作：10-50 CPU周期
普通方法调用：5-10 CPU周期
```

**问题场景**：

```java
public class Counter {
    private int count = 0;
    
    // 每次count++都要经历重量级锁的开销
    public synchronized void increment() {
        count++; // 只需要几个CPU周期的操作
    }
}

// 如果有1000次调用
for (int i = 0; i < 1000; i++) {
    counter.increment(); // 每次都要16000+CPU周期的锁开销！
}
```

**矛盾**：
- 锁保护的操作很轻量（几个CPU周期）
- 锁本身的开销很重（上万个CPU周期）
- **锁的开销 >> 业务逻辑的开销**

---

### 1.2 问题2：什么情况下不需要重量级锁？

**观察1：大多数情况下，锁只被一个线程访问**

```java
// 单线程场景：99%的情况下只有一个线程访问
public synchronized void process() {
    // 业务逻辑
}
```

**观察2：即使有竞争，持锁时间通常很短**

```java
public synchronized void quickOperation() {
    count++; // 只需要几纳秒
}
```

**观察3：线程竞争通常是短暂的**

```java
// 线程A持有锁100ns，线程B稍等一下就能获取到
synchronized (obj) {
    // 快速操作
}
```

**结论**：
- **大多数情况不需要重量级锁**
- 可以使用更轻量的锁机制
- 只有在真正发生竞争时才升级为重量级锁

---

### 1.3 问题3：JDK是如何优化锁性能的？

**JDK 1.6引入了锁升级机制**：

```
锁升级路径：
无锁 → 偏向锁 → 轻量锁 → 重量锁

特点：
- 锁只能升级，不能降级（JDK 1.8）
- 根据竞争情况自动升级
- 优先使用轻量级锁
```

**设计思想**：

```
┌─────────────────────────────────────────┐
│           锁升级的设计思想               │
├─────────────────────────────────────────┤
│  偏向锁：假设只有一个线程访问           │
│         → 消除同步操作                  │
├─────────────────────────────────────────┤
│  轻量锁：假设竞争不激烈                 │
│         → 使用CAS避免阻塞               │
├─────────────────────────────────────────┤
│  重量锁：竞争激烈                       │
│         → 使用Monitor阻塞线程           │
└─────────────────────────────────────────┘
```

---

## 2. 偏向锁（Biased Locking）

### 2.1 问题4：什么是偏向锁？

**定义**：偏向锁是一种针对**单线程访问**优化的锁机制。

**核心思想**：
- 锁会"偏向"第一个获取它的线程
- 该线程再次进入同步块时，**不需要任何同步操作**
- 连CAS都不需要，直接执行

**Mark Word结构（偏向锁状态）**：

```
64位JVM：
┌────────────────────────────────────────────────────┐
│ 线程ID(54bit) │ epoch(2bit) │ age(4bit) │ 1 │ 01 │
└────────────────────────────────────────────────────┘
                                            ↑   ↑
                                      偏向标志 锁标志
```

---

### 2.2 问题5：偏向锁的工作原理是什么？

#### **场景：线程A第一次获取锁**

**初始状态（无锁）**：

```
Mark Word:
┌────────────────────────────────────────────────────┐
│ unused(25) │ hashCode(31) │ age(4) │ 0 │ 01      │
└────────────────────────────────────────────────────┘
```

**线程A执行synchronized**：

```java
synchronized (obj) {
    // 线程A第一次进入
}
```

**步骤1：检查是否可偏向**

```
检查Mark Word的偏向标志位：
- biased_lock = 0 → 无锁状态
- biased_lock = 1 → 已偏向状态
```

**步骤2：CAS设置线程ID**

```
使用CAS将Mark Word替换为：
┌────────────────────────────────────────────────────┐
│ 线程A的ID │ epoch(2) │ age(4) │ 1 │ 01           │
└────────────────────────────────────────────────────┘
```

**步骤3：成功获取偏向锁**

```
线程A持有偏向锁，执行同步代码
```

#### **场景：线程A再次获取锁（重入）**

```java
synchronized (obj) {
    // 线程A再次进入
    synchronized (obj) {
        // 线程A重入
    }
}
```

**步骤1：检查线程ID**

```
Mark Word中的线程ID == 当前线程ID？
- 是 → 直接执行（不需要任何同步操作！）
- 否 → 发生竞争，需要撤销偏向锁
```

**性能对比**：

```
重量级锁：16000+ CPU周期
轻量级锁：50-100 CPU周期（CAS）
偏向锁：  0 CPU周期（直接执行）
```

---

### 2.3 问题6：偏向锁什么时候会被撤销？

#### **情况1：其他线程尝试获取锁**

```java
// 线程A持有偏向锁
synchronized (obj) {
    // 线程A执行
}

// 线程B尝试获取锁
synchronized (obj) {
    // 触发偏向锁撤销
}
```

**撤销流程**：

```
1. 暂停持有偏向锁的线程（STW - Stop The World）
2. 检查线程是否还在执行同步代码
   ├─ 是：升级为轻量锁
   └─ 否：恢复为无锁状态
3. 恢复线程执行
```

#### **情况2：调用hashCode()方法**

```java
Object obj = new Object();

// 1. 先获取偏向锁
synchronized (obj) {
    // obj处于偏向锁状态
}

// 2. 调用hashCode()
int hash = obj.hashCode(); // 触发偏向锁撤销！
```

**为什么？**

```
偏向锁状态的Mark Word：
┌────────────────────────────────────────────────────┐
│ 线程ID(54bit) │ epoch(2bit) │ age(4bit) │ 1 │ 01 │
└────────────────────────────────────────────────────┘
                ↑
        没有空间存储hashCode！

无锁状态的Mark Word：
┌────────────────────────────────────────────────────┐
│ unused(25) │ hashCode(31) │ age(4) │ 0 │ 01      │
└────────────────────────────────────────────────────┘
              ↑
      有空间存储hashCode
```

**结论**：
- 偏向锁状态下，Mark Word被线程ID占用
- 无法存储hashCode
- 调用hashCode()会撤销偏向锁

#### **情况3：调用wait()/notify()**

```java
synchronized (obj) {
    obj.wait(); // 触发偏向锁撤销，升级为重量锁
}
```

**原因**：
- wait()/notify()需要Monitor机制
- 偏向锁没有Monitor对象
- 必须升级为重量锁

---

### 2.4 问题7：偏向锁的撤销为什么需要STW？

**原因**：需要检查持有偏向锁的线程状态。

**场景**：

```
时间  线程A（持有偏向锁）        线程B（尝试获取锁）
T1   进入synchronized块
T2                              尝试获取锁
T3                              需要检查线程A的状态
T4   可能正在执行
T5   也可能已经退出
```

**问题**：
- 线程A可能正在执行同步代码
- 也可能已经退出同步块
- 需要**准确判断**线程A的状态

**解决方案**：
- 暂停线程A（STW）
- 检查线程A的栈帧
- 判断是否还在同步块内
- 决定升级策略

**STW的影响**：
- 暂停时间很短（微秒级）
- 只暂停持有偏向锁的线程
- 不影响其他线程

---

## 3. 轻量锁（Lightweight Locking）

### 3.1 问题8：什么是轻量锁？

**定义**：轻量锁是一种针对**竞争不激烈**场景优化的锁机制。

**核心思想**：
- 使用CAS操作代替Monitor
- 在线程栈上创建Lock Record
- 避免线程阻塞和唤醒

**Mark Word结构（轻量锁状态）**：

```
64位JVM：
┌────────────────────────────────────────────────────┐
│ 指向栈中Lock Record的指针(62bit)         │ 00    │
└────────────────────────────────────────────────────┘
                                            ↑
                                         锁标志
```

---

### 3.2 问题9：轻量锁的工作原理是什么？

#### **Lock Record的结构**

```
线程栈：
┌─────────────────────────────────┐
│      Lock Record                │
├─────────────────────────────────┤
│  Displaced Mark Word            │  ← 保存原始Mark Word
│  (对象原始的Mark Word)          │
├─────────────────────────────────┤
│  Object Reference               │  ← 指向锁对象
│  (指向obj)                      │
└─────────────────────────────────┘
```

#### **加锁流程**

**初始状态（无锁）**：

```
对象obj的Mark Word：
┌────────────────────────────────────────────────────┐
│ unused(25) │ hashCode(31) │ age(4) │ 0 │ 01      │
└────────────────────────────────────────────────────┘
```

**线程A执行synchronized**：

```java
synchronized (obj) {
    // 线程A尝试获取轻量锁
}
```

**步骤1：在栈上创建Lock Record**

```
线程A的栈：
┌─────────────────────────────────┐
│      Lock Record                │
├─────────────────────────────────┤
│  Displaced Mark Word:           │
│  [hashCode | age | 0 | 01]      │  ← 复制obj的Mark Word
├─────────────────────────────────┤
│  Object Reference: obj          │
└─────────────────────────────────┘
```

**步骤2：CAS替换对象的Mark Word**

```
尝试将obj的Mark Word替换为Lock Record的地址：

CAS操作：
  期望值：[hashCode | age | 0 | 01]  （无锁状态）
  新值：  [Lock Record地址 | 00]     （轻量锁状态）
```

**步骤3：CAS成功，获取轻量锁**

```
对象obj的Mark Word：
┌────────────────────────────────────────────────────┐
│ Lock Record地址(0x7fff5fbff700)          │ 00    │
└────────────────────────────────────────────────────┘
```

**完整状态**：

```
┌─────────────────────────────────┐
│  线程A的栈                      │
│  ┌───────────────────────────┐  │
│  │  Lock Record              │  │
│  │  ┌─────────────────────┐  │  │
│  │  │ Displaced Mark Word │  │  │
│  │  │ [hash|age|0|01]     │  │  │
│  │  └─────────────────────┘  │  │
│  │  ┌─────────────────────┐  │  │
│  │  │ Object Ref: obj     │  │  │
│  │  └─────────────────────┘  │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
                │
                │ 指向
                ▼
┌─────────────────────────────────┐
│  对象obj                        │
│  ┌───────────────────────────┐  │
│  │ Mark Word                 │  │
│  │ [Lock Record地址 | 00]   │  │
│  └───────────────────────────┘  │
└─────────────────────────────────┘
```

#### **解锁流程**

**步骤1：使用CAS恢复Mark Word**

```
CAS操作：
  期望值：[Lock Record地址 | 00]  （轻量锁状态）
  新值：  [hashCode | age | 0 | 01]  （从Displaced Mark Word恢复）
```

**步骤2：CAS成功，释放轻量锁**

```
对象obj的Mark Word恢复为无锁状态：
┌────────────────────────────────────────────────────┐
│ unused(25) │ hashCode(31) │ age(4) │ 0 │ 01      │
└────────────────────────────────────────────────────┘
```

---

### 3.3 问题10：轻量锁什么时候会膨胀为重量锁？

#### **情况1：CAS加锁失败（有竞争）**

```java
// 线程A持有轻量锁
synchronized (obj) {
    // 线程A执行
}

// 线程B尝试获取锁
synchronized (obj) {
    // CAS失败，触发锁膨胀
}
```

**膨胀流程**：

```
1. 线程B的CAS操作失败（obj的Mark Word已经是Lock Record地址）
2. 线程B进入自旋等待
3. 自旋一定次数后仍未获取到锁
4. 创建Monitor对象
5. 将obj的Mark Word替换为Monitor地址
6. 线程B进入Monitor的_EntryList阻塞
```

**详细步骤**：

```
步骤1：线程B自旋等待
for (int i = 0; i < 自旋次数; i++) {
    if (CAS成功) {
        获取轻量锁;
        return;
    }
}

步骤2：自旋失败，创建Monitor
Monitor monitor = new Monitor();
monitor._owner = 线程A;
monitor._EntryList.add(线程B);

步骤3：膨胀为重量锁
obj的Mark Word：
┌────────────────────────────────────────────────────┐
│ Monitor对象地址                          │ 10    │
└────────────────────────────────────────────────────┘

步骤4：线程B阻塞
线程B进入BLOCKED状态，等待线程A释放锁
```

#### **情况2：CAS解锁失败**

```java
synchronized (obj) {
    // 线程A持有轻量锁
    // 此时线程B尝试获取锁，触发了锁膨胀
}
// 线程A退出时，CAS恢复Mark Word会失败
```

**原因**：
- 线程A加锁时，Mark Word是Lock Record地址
- 线程B竞争时，Mark Word被替换为Monitor地址
- 线程A解锁时，CAS期望值不匹配，失败

**处理**：
- 线程A释放Monitor锁
- 唤醒Monitor中等待的线程

---

### 3.4 问题11：自旋次数如何确定？

**JDK 1.6之前：固定自旋次数**

```
默认自旋次数：10次
可通过参数调整：-XX:PreBlockSpin=N
```

**JDK 1.6之后：自适应自旋**

```
自适应策略：
- 如果上次自旋成功，增加自旋次数
- 如果上次自旋失败，减少自旋次数
- 根据历史数据动态调整
```

**示例**：

```
第1次竞争：自旋10次，成功获取锁
  → 下次自旋20次

第2次竞争：自旋20次，成功获取锁
  → 下次自旋40次

第3次竞争：自旋40次，失败
  → 下次自旋20次
```

---

## 4. 锁升级的完整流程

### 4.1 问题12：锁升级的完整路径是什么？

```
┌─────────────────────────────────────────────────────────┐
│                    锁升级完整流程                        │
└─────────────────────────────────────────────────────────┘

无锁状态
  │
  │ 线程A第一次获取锁
  ▼
偏向锁（偏向线程A）
  │
  │ 线程B尝试获取锁
  ▼
撤销偏向锁
  │
  ├─ 线程A已退出 → 恢复无锁状态 → 线程B获取偏向锁
  │
  └─ 线程A仍持有 → 升级为轻量锁
                    │
                    │ 线程C尝试获取锁
                    ▼
                  轻量锁（线程A持有）
                    │
                    │ 线程C自旋等待
                    ▼
                  ┌─────────────┐
                  │ 自旋成功？  │
                  └─────────────┘
                    │         │
              成功  │         │ 失败
                    │         │
                    ▼         ▼
            获取轻量锁    膨胀为重量锁
                              │
                              ▼
                        重量锁（Monitor）
                              │
                              │ 线程进入_EntryList
                              ▼
                          阻塞等待
```

---

### 4.2 问题13：不同锁状态的Mark Word对比

```
┌────────────────────────────────────────────────────────────┐
│                  Mark Word 状态对比（64位）                 │
├────────────────────────────────────────────────────────────┤
│  无锁状态：                                                │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ unused(25) │ hashCode(31) │ age(4) │ 0 │ 01        │  │
│  └──────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────┤
│  偏向锁状态：                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 线程ID(54) │ epoch(2) │ age(4) │ 1 │ 01            │  │
│  └──────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────┤
│  轻量锁状态：                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ Lock Record指针(62)                      │ 00        │  │
│  └──────────────────────────────────────────────────────┘  │
├────────────────────────────────────────────────────────────┤
│  重量锁状态：                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ Monitor指针(62)                          │ 10        │  │
│  └──────────────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────────────┘
```

---

### 4.3 问题14：锁升级的性能对比

```
┌─────────────────────────────────────────────────────────┐
│                  锁性能对比                              │
├─────────────────────────────────────────────────────────┤
│  无锁：                                                 │
│    开销：0 CPU周期                                      │
│    适用：无并发访问                                     │
├─────────────────────────────────────────────────────────┤
│  偏向锁：                                               │
│    开销：0 CPU周期（检查线程ID）                        │
│    适用：单线程反复进入同步块                           │
│    缺点：撤销需要STW                                    │
├─────────────────────────────────────────────────────────┤
│  轻量锁：                                               │
│    开销：50-100 CPU周期（CAS操作）                      │
│    适用：竞争不激烈，持锁时间短                         │
│    缺点：自旋消耗CPU                                    │
├─────────────────────────────────────────────────────────┤
│  重量锁：                                               │
│    开销：16000-21500 CPU周期（系统调用）                │
│    适用：竞争激烈，持锁时间长                           │
│    优点：不消耗CPU（线程阻塞）                          │
└─────────────────────────────────────────────────────────┘
```

---

## 5. 锁降级

### 5.1 问题15：锁能否降级？

**JDK 1.8及之前：不支持锁降级**

```
锁只能升级，不能降级：
无锁 → 偏向锁 → 轻量锁 → 重量锁
                          ↑
                    不能降级回去
```

**原因**：
- 实现复杂度高
- 降级时机难以判断
- 可能导致性能抖动

**JDK 15+：支持锁降级（实验性）**

```
启用参数：-XX:+UseHeavyMonitors
可以从重量锁降级为轻量锁
```

---

### 5.2 问题16：为什么锁降级很难实现？

**难点1：时机判断**

```
什么时候降级？
- 竞争减少？如何定义"减少"？
- 等待线程数量？阈值是多少？
- 持锁时间？如何统计？
```

**难点2：状态一致性**

```
降级过程中：
- 可能有线程正在等待
- 可能有线程正在自旋
- 如何保证状态一致性？
```

**难点3：性能抖动**

```
频繁升级降级：
重量锁 → 轻量锁 → 重量锁 → 轻量锁
       ↑                    ↑
   降级开销              升级开销

可能比一直保持重量锁更慢！
```

---

## 6. 锁升级的设计思想

### 6.1 问题17：锁升级为什么要这样设计？

**设计原则1：乐观假设**

```
偏向锁：假设只有一个线程访问
  → 大多数情况下是正确的
  → 性能最优

轻量锁：假设竞争不激烈
  → 短暂等待就能获取锁
  → 避免阻塞开销

重量锁：竞争激烈
  → 自旋浪费CPU
  → 阻塞更合适
```

**设计原则2：渐进式优化**

```
从最乐观的假设开始：
1. 先尝试偏向锁（最快）
2. 失败则尝试轻量锁（较快）
3. 再失败则使用重量锁（最慢但最稳定）
```

**设计原则3：适应性**

```
根据实际运行情况自动调整：
- 单线程 → 偏向锁
- 少量竞争 → 轻量锁
- 激烈竞争 → 重量锁
```

---

### 6.2 问题18：锁升级的核心流程为什么要这么设计？

**问题：为什么不直接使用重量锁？**

```
如果所有锁都是重量锁：
- 单线程访问也要16000+ CPU周期
- 大量不必要的系统调用
- 性能严重下降
```

**问题：为什么不直接使用CAS？**

```
如果所有锁都用CAS（轻量锁）：
- 竞争激烈时，自旋浪费CPU
- 可能导致CPU 100%占用
- 反而比重量锁更慢
```

**问题：为什么需要偏向锁？**

```
大多数锁只被一个线程访问：
- 轻量锁仍需要CAS操作（50-100 CPU周期）
- 偏向锁直接执行（0 CPU周期）
- 性能提升50-100倍
```

**结论**：
- 锁升级是一种**自适应优化**
- 根据实际情况选择最优策略
- 平衡了性能和正确性

---

## 7. 实际应用建议

### 7.1 问题19：如何选择合适的锁策略？

```
┌─────────────────────────────────────────────────────────┐
│                  锁选择决策树                            │
└─────────────────────────────────────────────────────────┘

是否有并发访问？
  │
  ├─ 否 → 无锁（最快）
  │
  └─ 是 → 是否只有一个线程反复访问？
          │
          ├─ 是 → 偏向锁（推荐）
          │       注意：调用hashCode()会撤销
          │
          └─ 否 → 竞争是否激烈？
                  │
                  ├─ 不激烈 → 轻量锁（推荐）
                  │           持锁时间短
                  │           线程数量少
                  │
                  └─ 激烈 → 重量锁
                            持锁时间长
                            线程数量多
```

---

### 7.2 问题20：如何禁用偏向锁？

**场景：不适合使用偏向锁的情况**

```
1. 大量线程竞争同一把锁
2. 频繁调用hashCode()
3. 使用了大量的wait()/notify()
```

**禁用方法**：

```bash
# 禁用偏向锁
-XX:-UseBiasedLocking

# 延迟启用偏向锁（默认4秒后启用）
-XX:BiasedLockingStartupDelay=0  # 立即启用
-XX:BiasedLockingStartupDelay=10000  # 10秒后启用
```

---

## 8. 核心问题总结

### Q1: 为什么需要锁升级？
**A**: 重量级锁开销大（16000+ CPU周期），而大多数情况下锁竞争不激烈，使用轻量级锁可以大幅提升性能。

### Q2: 锁升级的路径是什么？
**A**: 无锁 → 偏向锁 → 轻量锁 → 重量锁（只升级不降级）。

### Q3: 偏向锁的原理是什么？
**A**: 锁偏向第一个获取它的线程，该线程再次进入时不需要任何同步操作（0开销）。

### Q4: 轻量锁的原理是什么？
**A**: 使用CAS在栈上创建Lock Record，避免Monitor的阻塞开销（50-100 CPU周期）。

### Q5: 偏向锁什么时候会被撤销？
**A**: 
- 其他线程尝试获取锁
- 调用hashCode()方法
- 调用wait()/notify()

### Q6: 轻量锁什么时候会膨胀为重量锁？
**A**: 
- CAS加锁失败且自旋超过次数
- CAS解锁失败（已被膨胀）

### Q7: 锁能否降级？
**A**: JDK 1.8不支持，JDK 15+实验性支持。

### Q8: 如何选择锁策略？
**A**: 
- 单线程 → 偏向锁
- 少量竞争 → 轻量锁
- 激烈竞争 → 重量锁

---

## 9. 思考题

1. **为什么偏向锁的撤销需要STW？能否避免？**
2. **轻量锁的Lock Record为什么要在栈上创建？**
3. **自适应自旋的算法是如何实现的？**
4. **如果锁支持降级，应该在什么时机降级？**
5. **为什么调用hashCode()会撤销偏向锁？有没有解决方案？**

---

## 下一章预告

下一章我们将深入学习：

- **锁消除（Lock Elimination）**：JIT如何消除不必要的锁？
- **锁粗化（Lock Coarsening）**：如何合并相邻的锁？
- **自旋锁优化**：自适应自旋的详细算法
- **逃逸分析**：如何判断对象是否逃逸？
- **JIT编译器优化**：锁优化在编译期的实现

让我们继续深入！🚀
