# JVM命令行工具详解

## 📚 概述

JVM提供了一系列强大的命令行工具，用于监控、诊断和调优Java应用。这些工具是JDK自带的，无需额外安装，是每个Java开发者必须掌握的利器。

## 🎯 核心问题

- ❓ 为什么需要这些命令行工具？
- ❓ 每个工具的核心功能是什么？
- ❓ 如何在生产环境使用这些工具？
- ❓ 这些工具的工作原理是什么？
- ❓ 使用时有哪些注意事项？
- ❓ 如何组合使用这些工具排查问题？

---

## 一、为什么需要命令行工具

### 1.1 生产环境的挑战

```
生产环境问题：

1. 应用突然变慢
   - CPU飙高
   - 响应时间长
   - 吞吐量下降

2. 内存问题
   - 内存泄漏
   - 频繁Full GC
   - OOM错误

3. 线程问题
   - 死锁
   - 线程阻塞
   - 线程数过多

4. 类加载问题
   - 类冲突
   - 类加载失败
   - 内存泄漏

需求：
快速定位问题
    ↓
无需重启应用
    ↓
最小化性能影响
    ↓
命令行工具
```

### 1.2 图形化工具的局限

```
图形化工具的问题：

1. 生产环境限制
   - 无法安装GUI
   - 网络隔离
   - 安全限制

2. 性能开销
   - 占用资源多
   - 影响应用性能
   - 不适合长期监控

3. 灵活性差
   - 功能固定
   - 难以自动化
   - 无法集成到脚本

命令行工具优势：
- 轻量级
- 灵活
- 可脚本化
- 适合生产环境
```

---

## 二、jps - 虚拟机进程状态工具

### 2.1 工具介绍

```
jps（JVM Process Status Tool）：
显示系统中所有HotSpot虚拟机进程

作用：
1. 查看Java进程
2. 获取进程ID（LVMID）
3. 查看主类名称
4. 查看JVM参数

为什么需要jps？
- 其他工具需要进程ID
- 快速定位Java进程
- 查看进程基本信息
```

### 2.2 使用方法

```bash
# 基本用法
jps

# 输出完整的包名
jps -l

# 输出JVM参数
jps -v

# 输出传递给main方法的参数
jps -m

# 示例输出
12345 org.apache.catalina.startup.Bootstrap
12346 com.example.Application -Xmx2g -Xms2g
12347 sun.tools.jps.Jps
```

### 2.3 常用选项

| 选项 | 说明 | 示例 |
|------|------|------|
| `-q` | 只输出LVMID | `jps -q` |
| `-l` | 输出主类全名 | `jps -l` |
| `-m` | 输出main参数 | `jps -m` |
| `-v` | 输出JVM参数 | `jps -v` |
| `-V` | 输出通过flag文件传递的参数 | `jps -V` |

### 2.4 实战案例

```bash
# 场景1：查找特定应用的进程ID
jps -l | grep "com.example.Application"

# 场景2：查看应用的JVM参数
jps -v | grep "Application"

# 场景3：批量查看所有Java进程
jps -lvm

# 场景4：监控Java进程数量
watch -n 1 'jps | wc -l'
```

### 2.5 工作原理

```
jps工作原理：

1. 扫描临时目录
   - Linux: /tmp/hsperfdata_<username>
   - Windows: C:\Users\<username>\AppData\Local\Temp\hsperfdata_<username>

2. 读取性能数据文件
   - 每个Java进程创建一个文件
   - 文件名为进程ID
   - 包含进程信息

3. 解析并显示
   - 读取文件内容
   - 提取进程信息
   - 格式化输出

注意：
- jps只能看到当前用户的进程
- 需要有读取临时目录的权限
- 进程异常退出可能留下残留文件
```

---

## 三、jstat - 虚拟机统计信息监控工具

### 3.1 工具介绍

```
jstat（JVM Statistics Monitoring Tool）：
监控虚拟机各种运行状态信息

核心功能：
1. 类加载统计
2. 垃圾回收统计
3. 编译统计
4. 内存使用统计

为什么需要jstat？
- 实时监控GC情况
- 分析内存使用
- 定位性能问题
- 无需重启应用
```

### 3.2 使用方法

```bash
# 基本语法
jstat [option] <vmid> [interval] [count]

# 参数说明
vmid      - 虚拟机ID（进程ID）
interval  - 查询间隔（毫秒）
count     - 查询次数

# 示例
jstat -gc 12345           # 查看GC情况（一次）
jstat -gc 12345 1000      # 每秒查看一次
jstat -gc 12345 1000 10   # 每秒查看一次，共10次
```

### 3.3 常用选项详解

#### 3.3.1 类加载统计（-class）

```bash
jstat -class 12345

# 输出示例
Loaded  Bytes  Unloaded  Bytes     Time   
  7035  14154.3      0     0.0       3.67

# 字段说明
Loaded   - 已加载的类数量
Bytes    - 已加载类的大小（KB）
Unloaded - 已卸载的类数量
Bytes    - 已卸载类的大小（KB）
Time     - 类加载耗时（秒）
```

#### 3.3.2 垃圾回收统计（-gc）

```bash
jstat -gc 12345

# 输出示例
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
10752.0 10752.0  0.0   8192.0 65536.0  23456.0   175104.0   87552.0  21248.0 20512.0 2560.0 2304.0    16    0.242   2      0.068    0.310

# 字段说明（容量单位：KB，时间单位：秒）
S0C  - Survivor0区容量
S1C  - Survivor1区容量
S0U  - Survivor0区使用量
S1U  - Survivor1区使用量
EC   - Eden区容量
EU   - Eden区使用量
OC   - 老年代容量
OU   - 老年代使用量
MC   - 元空间容量
MU   - 元空间使用量
CCSC - 压缩类空间容量
CCSU - 压缩类空间使用量
YGC  - Young GC次数
YGCT - Young GC总耗时
FGC  - Full GC次数
FGCT - Full GC总耗时
GCT  - GC总耗时
```

#### 3.3.3 GC统计百分比（-gcutil）

```bash
jstat -gcutil 12345

# 输出示例
  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   
  0.00  76.19  35.79  50.00  96.54  90.00    16    0.242     2    0.068    0.310

# 字段说明（百分比）
S0   - Survivor0区使用率
S1   - Survivor1区使用率
E    - Eden区使用率
O    - 老年代使用率
M    - 元空间使用率
CCS  - 压缩类空间使用率
YGC  - Young GC次数
YGCT - Young GC总耗时
FGC  - Full GC次数
FGCT - Full GC总耗时
GCT  - GC总耗时
```

#### 3.3.4 新生代统计（-gcnew）

```bash
jstat -gcnew 12345

# 输出示例
 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  
10752.0 10752.0    0.0 8192.0 15  15 5376.0  65536.0  23456.0    16    0.242

# 字段说明
TT  - 对象在新生代存活次数
MTT - 对象在新生代存活的最大次数
DSS - 期望的Survivor区大小
```

#### 3.3.5 老年代统计（-gcold）

```bash
jstat -gcold 12345

# 输出示例
   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   
 21248.0  20512.0   2560.0   2304.0    175104.0     87552.0     16     2    0.068    0.310
```

#### 3.3.6 编译统计（-compiler）

```bash
jstat -compiler 12345

# 输出示例
Compiled Failed Invalid   Time   FailedType FailedMethod
    2573      1       0     5.23          1 com/example/MyClass myMethod

# 字段说明
Compiled     - 编译任务执行次数
Failed       - 编译任务失败次数
Invalid      - 编译任务无效次数
Time         - 编译耗时
FailedType   - 最后一次失败的编译类型
FailedMethod - 最后一次失败的方法
```

### 3.4 实战案例

#### 案例1：监控GC频率

```bash
# 每秒输出一次GC统计，持续监控
jstat -gcutil 12345 1000

# 分析要点
1. YGC频率
   - 正常：几秒到几分钟一次
   - 异常：每秒多次

2. FGC频率
   - 正常：几小时到几天一次
   - 异常：频繁Full GC

3. 内存使用率
   - Eden区：应该有波动
   - 老年代：缓慢增长
   - 元空间：相对稳定
```

#### 案例2：分析内存泄漏

```bash
# 持续监控老年代使用情况
jstat -gcold 12345 5000 100

# 判断标准
1. 老年代持续增长
   OU值不断增加
   Full GC后不下降

2. Full GC频繁
   FGC次数快速增加
   FGCT时间长

3. 内存回收效果差
   Full GC前后OU变化小
   可能存在内存泄漏
```

#### 案例3：评估GC性能

```bash
# 查看GC时间占比
jstat -gcutil 12345 1000 10

# 计算公式
GC时间占比 = GCT / (运行时间) * 100%

# 评估标准
< 1%   - 优秀
1-3%   - 良好
3-5%   - 一般
> 5%   - 需要优化
> 10%  - 严重问题
```

### 3.5 使用技巧

```bash
# 技巧1：输出到文件
jstat -gc 12345 1000 > gc.log

# 技巧2：结合watch命令
watch -n 1 'jstat -gcutil 12345'

# 技巧3：格式化输出
jstat -gcutil 12345 1000 | awk '{printf "Eden: %.2f%%, Old: %.2f%%\n", $3, $4}'

# 技巧4：监控多个进程
for pid in $(jps -q); do
    echo "PID: $pid"
    jstat -gcutil $pid
    echo "---"
done
```

---

## 四、jinfo - 配置信息工具

### 4.1 工具介绍

```
jinfo（Configuration Info for Java）：
查看和修改虚拟机配置参数

核心功能：
1. 查看JVM参数
2. 查看系统属性
3. 动态修改参数（部分）

为什么需要jinfo？
- 查看运行时配置
- 动态调整参数
- 无需重启应用
- 快速验证配置
```

### 4.2 使用方法

```bash
# 查看所有参数
jinfo 12345

# 查看特定参数
jinfo -flag MaxHeapSize 12345

# 查看所有JVM参数
jinfo -flags 12345

# 查看系统属性
jinfo -sysprops 12345

# 动态修改参数（仅支持部分参数）
jinfo -flag +PrintGC 12345           # 开启GC日志
jinfo -flag -PrintGC 12345           # 关闭GC日志
jinfo -flag PrintGCDetails=true 12345 # 设置参数值
```

### 4.3 可动态修改的参数

```bash
# 查看可动态修改的参数
java -XX:+PrintFlagsFinal -version | grep manageable

# 常见可修改参数
PrintGC                    # GC日志开关
PrintGCDetails             # GC详细日志
PrintGCTimeStamps          # GC时间戳
HeapDumpOnOutOfMemoryError # OOM时生成堆转储
HeapDumpPath               # 堆转储路径
```

### 4.4 实战案例

```bash
# 案例1：查看堆大小配置
jinfo -flag MaxHeapSize 12345
jinfo -flag InitialHeapSize 12345

# 案例2：动态开启GC日志
jinfo -flag +PrintGC 12345
jinfo -flag +PrintGCDetails 12345
jinfo -flag +PrintGCTimeStamps 12345

# 案例3：查看所有JVM参数
jinfo -flags 12345 | grep -i gc

# 案例4：查看类路径
jinfo -sysprops 12345 | grep java.class.path
```

---

## 五、jmap - 内存映像工具

### 5.1 工具介绍

```
jmap（Memory Map for Java）：
生成堆转储快照和查询内存信息

核心功能：
1. 生成堆转储（heap dump）
2. 查看堆内存使用
3. 查看对象统计
4. 查看类加载器信息

为什么需要jmap？
- 分析内存泄漏
- 查看对象分布
- 生成堆快照
- 定位内存问题
```

### 5.2 使用方法

```bash
# 生成堆转储文件
jmap -dump:format=b,file=heap.hprof 12345

# 生成堆转储（只包含存活对象）
jmap -dump:live,format=b,file=heap.hprof 12345

# 查看堆内存使用情况
jmap -heap 12345

# 查看对象统计信息
jmap -histo 12345

# 查看对象统计（只包含存活对象）
jmap -histo:live 12345

# 查看类加载器统计
jmap -clstats 12345
```

### 5.3 堆内存信息（-heap）

```bash
jmap -heap 12345

# 输出示例
Attaching to process ID 12345, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.191-b12

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 44564480 (42.5MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 89653248 (85.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 33554432 (32.0MB)
   used     = 10485760 (10.0MB)
   free     = 23068672 (22.0MB)
   31.25% used
From Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
To Space:
   capacity = 5242880 (5.0MB)
   used     = 0 (0.0MB)
   free     = 5242880 (5.0MB)
   0.0% used
PS Old Generation
   capacity = 89653248 (85.5MB)
   used     = 44826624 (42.75MB)
   free     = 44826624 (42.75MB)
   50.0% used
```

### 5.4 对象统计（-histo）

```bash
jmap -histo 12345 | head -20

# 输出示例
 num     #instances         #bytes  class name
----------------------------------------------
   1:         45678        3654240  [C
   2:         12345        2469000  java.lang.String
   3:          8901        1780200  [B
   4:          5678        1135600  java.util.HashMap$Node
   5:          3456         691200  [I
   6:          2345         468900  java.util.concurrent.ConcurrentHashMap$Node
   7:          1234         246800  java.lang.Object
   8:           987         197400  com.example.MyClass
   9:           876         175200  java.util.ArrayList
  10:           765         153000  java.lang.Long

# 字段说明
num        - 序号
#instances - 实例数量
#bytes     - 占用内存（字节）
class name - 类名
```

### 5.5 实战案例

#### 案例1：生成堆转储分析内存泄漏

```bash
# 步骤1：生成堆转储
jmap -dump:live,format=b,file=/tmp/heap_$(date +%Y%m%d_%H%M%S).hprof 12345

# 步骤2：使用MAT分析
# 1. 打开MAT（Memory Analyzer Tool）
# 2. 加载heap.hprof文件
# 3. 查看Leak Suspects报告
# 4. 分析Dominator Tree
# 5. 查找内存泄漏对象

# 注意事项
1. 生成堆转储会触发Full GC
2. 文件大小约等于堆内存大小
3. 生成过程中应用会暂停
4. 建议在业务低峰期执行
```

#### 案例2：查找占用内存最多的对象

```bash
# 查看前20个占用内存最多的对象
jmap -histo:live 12345 | head -20

# 分析要点
1. 查看异常对象
   - 实例数量异常多
   - 占用内存异常大
   - 不应该存在的对象

2. 关注业务对象
   - 自定义类的实例
   - 是否符合预期
   - 是否有泄漏

3. 对比不同时间点
   - 定期执行
   - 观察变化趋势
   - 发现异常增长
```

#### 案例3：监控堆内存使用趋势

```bash
# 定期记录堆内存使用情况
while true; do
    echo "=== $(date) ===" >> heap_usage.log
    jmap -heap 12345 | grep "used" >> heap_usage.log
    sleep 300  # 每5分钟记录一次
done

# 分析趋势
1. Eden区使用率
   - 应该有波动
   - 周期性下降（Young GC）

2. 老年代使用率
   - 缓慢增长正常
   - 快速增长异常
   - 持续增长可能泄漏

3. 元空间使用率
   - 相对稳定
   - 持续增长可能类泄漏
```

### 5.6 注意事项

```
使用jmap的注意事项：

1. 性能影响
   - -dump会触发Full GC
   - -histo:live会触发Full GC
   - 应用会暂停（STW）
   - 建议业务低峰期使用

2. 文件大小
   - 堆转储文件很大
   - 约等于堆内存大小
   - 确保磁盘空间充足

3. 权限问题
   - 需要与Java进程相同用户
   - 或root权限

4. 生产环境建议
   - 使用-XX:+HeapDumpOnOutOfMemoryError
   - 自动生成堆转储
   - 无需手动执行jmap
```

---

## 六、jstack - 线程堆栈跟踪工具

### 6.1 工具介绍

```
jstack（Stack Trace for Java）：
生成虚拟机当前时刻的线程快照

核心功能：
1. 查看线程状态
2. 分析死锁
3. 定位线程阻塞
4. 分析CPU飙高

为什么需要jstack？
- 定位死锁问题
- 分析线程阻塞
- 排查CPU飙高
- 了解线程状态
```

### 6.2 使用方法

```bash
# 基本用法
jstack 12345

# 输出到文件
jstack 12345 > thread_dump.txt

# 强制输出（进程挂起时）
jstack -F 12345

# 输出额外的锁信息
jstack -l 12345

# 输出混合模式（Java + Native）
jstack -m 12345
```

### 6.3 线程状态解析

```
线程状态（Thread State）：

1. NEW
   - 新创建，未启动

2. RUNNABLE
   - 运行中或等待CPU
   - 包括Running和Ready

3. BLOCKED
   - 等待获取锁
   - 被synchronized阻塞

4. WAITING
   - 无限期等待
   - Object.wait()
   - Thread.join()
   - LockSupport.park()

5. TIMED_WAITING
   - 有时限的等待
   - Thread.sleep()
   - Object.wait(timeout)
   - Thread.join(timeout)

6. TERMINATED
   - 已终止
```

### 6.4 输出示例解析

```
"http-nio-8080-exec-1" #23 daemon prio=5 os_prio=0 tid=0x00007f8c3c001000 nid=0x1234 waiting on condition [0x00007f8c3b000000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at com.example.MyService.process(MyService.java:45)
        at com.example.MyController.handle(MyController.java:23)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        ...

字段说明：
"http-nio-8080-exec-1" - 线程名称
#23                     - 线程编号
daemon                  - 守护线程
prio=5                  - Java优先级（1-10）
os_prio=0               - 操作系统优先级
tid=0x00007f8c3c001000  - 线程ID
nid=0x1234              - 本地线程ID（16进制）
waiting on condition    - 线程状态描述
[0x00007f8c3b000000]    - 栈地址范围
java.lang.Thread.State  - Java线程状态
堆栈信息                 - 方法调用栈
```

### 6.5 实战案例

#### 案例1：分析死锁

```bash
# 生成线程转储
jstack 12345 > deadlock.txt

# 查找死锁信息
grep -A 20 "Found one Java-level deadlock" deadlock.txt

# 死锁示例输出
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00007f8c3c002000 (object 0x00000000d5f10000, a java.lang.Object),
  which is held by "Thread-2"
"Thread-2":
  waiting to lock monitor 0x00007f8c3c003000 (object 0x00000000d5f10010, a java.lang.Object),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.example.DeadlockDemo.method1(DeadlockDemo.java:20)
        - waiting to lock <0x00000000d5f10000> (a java.lang.Object)
        - locked <0x00000000d5f10010> (a java.lang.Object)
"Thread-2":
        at com.example.DeadlockDemo.method2(DeadlockDemo.java:30)
        - waiting to lock <0x00000000d5f10010> (a java.lang.Object)
        - locked <0x00000000d5f10000> (a java.lang.Object)

Found 1 deadlock.

# 分析步骤
1. 找到死锁的线程
2. 查看锁的持有和等待关系
3. 定位代码位置
4. 分析死锁原因
5. 修复代码
```

#### 案例2：排查CPU飙高

```bash
# 步骤1：找到CPU占用高的进程
top -c

# 步骤2：找到CPU占用高的线程
top -Hp 12345

# 步骤3：将线程ID转换为16进制
printf "%x\n" 1234  # 假设线程ID是1234
# 输出：4d2

# 步骤4：生成线程转储
jstack 12345 > cpu_high.txt

# 步骤5：查找对应的线程
grep -A 30 "nid=0x4d2" cpu_high.txt

# 步骤6：分析线程堆栈
# 查看线程在执行什么代码
# 定位CPU密集的方法
# 优化代码逻辑
```

#### 案例3：分析线程阻塞

```bash
# 生成线程转储
jstack 12345 > blocked.txt

# 查找BLOCKED状态的线程
grep -B 1 "BLOCKED" blocked.txt

# 示例输出
"http-nio-8080-exec-10" #32 daemon prio=5 os_prio=0 tid=0x00007f8c3c010000 nid=0x2345 waiting for monitor entry [0x00007f8c3a000000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.example.MyService.syncMethod(MyService.java:50)
        - waiting to lock <0x00000000d5f20000> (a java.lang.Object)
        - locked <0x00000000d5f20010> (a java.lang.Object)

# 分析要点
1. 找到BLOCKED的线程
2. 查看等待的锁对象
3. 找到持有锁的线程
4. 分析锁竞争情况
5. 优化同步代码
```

#### 案例4：分析线程池状态

```bash
# 生成线程转储
jstack 12345 > threadpool.txt

# 查找线程池线程
grep "pool-" threadpool.txt | wc -l

# 统计线程状态
grep "java.lang.Thread.State:" threadpool.txt | sort | uniq -c

# 示例输出
  50 java.lang.Thread.State: RUNNABLE
  30 java.lang.Thread.State: TIMED_WAITING (parking)
  20 java.lang.Thread.State: WAITING (parking)
   5 java.lang.Thread.State: BLOCKED (on object monitor)

# 分析要点
1. 线程池大小是否合理
2. 大量WAITING可能任务不足
3. 大量BLOCKED可能锁竞争
4. 大量RUNNABLE可能CPU密集
```

### 6.6 使用技巧

```bash
# 技巧1：多次采样对比
jstack 12345 > dump1.txt
sleep 3
jstack 12345 > dump2.txt
sleep 3
jstack 12345 > dump3.txt

# 对比三次堆栈，找出一直在执行的线程

# 技巧2：过滤特定线程
jstack 12345 | grep -A 10 "http-nio"

# 技巧3：统计线程状态
jstack 12345 | grep "java.lang.Thread.State" | awk '{print $2}' | sort | uniq -c

# 技巧4：查找特定方法
jstack 12345 | grep -B 5 "MyService.slowMethod"
```

---

## 七、jcmd - 多功能命令行工具

### 7.1 工具介绍

```
jcmd（JVM Command）：
多功能的JVM诊断命令工具

核心功能：
1. 发送诊断命令
2. 替代多个工具
3. 功能更强大
4. 推荐使用

为什么需要jcmd？
- 功能全面
- 一个工具多种用途
- Oracle推荐
- 持续更新
```

### 7.2 使用方法

```bash
# 列出所有Java进程
jcmd

# 查看进程支持的命令
jcmd 12345 help

# 执行特定命令
jcmd 12345 <command>

# 常用命令
jcmd 12345 VM.version          # 查看JVM版本
jcmd 12345 VM.flags            # 查看JVM参数
jcmd 12345 VM.system_properties # 查看系统属性
jcmd 12345 VM.uptime           # 查看运行时间
jcmd 12345 Thread.print        # 打印线程堆栈
jcmd 12345 GC.heap_dump filename=heap.hprof  # 生成堆转储
jcmd 12345 GC.class_histogram  # 查看类统计
jcmd 12345 GC.run              # 执行GC
```

### 7.3 常用命令详解

```bash
# 1. 查看JVM信息
jcmd 12345 VM.version
jcmd 12345 VM.flags
jcmd 12345 VM.command_line

# 2. 线程相关
jcmd 12345 Thread.print
jcmd 12345 Thread.print -l  # 包含锁信息

# 3. GC相关
jcmd 12345 GC.heap_info
jcmd 12345 GC.class_histogram
jcmd 12345 GC.heap_dump filename=/tmp/heap.hprof
jcmd 12345 GC.run
jcmd 12345 GC.run_finalization

# 4. 性能相关
jcmd 12345 VM.native_memory summary
jcmd 12345 VM.classloader_stats
jcmd 12345 Compiler.queue
jcmd 12345 Compiler.codecache

# 5. 诊断相关
jcmd 12345 VM.log what=gc
jcmd 12345 VM.log what=gc+heap=trace
jcmd 12345 VM.set_flag PrintGC true
```

### 7.4 实战案例

```bash
# 案例1：快速诊断
jcmd 12345 VM.uptime
jcmd 12345 VM.flags
jcmd 12345 GC.heap_info
jcmd 12345 Thread.print

# 案例2：动态开启GC日志
jcmd 12345 VM.log what=gc output=/tmp/gc.log

# 案例3：分析本地内存
jcmd 12345 VM.native_memory summary

# 案例4：查看编译队列
jcmd 12345 Compiler.queue
```

---

## 八、工具组合使用

### 8.1 问题排查流程

```
问题排查流程：

1. 发现问题
   ↓
2. 确定进程（jps）
   ↓
3. 查看概况（jinfo）
   ↓
4. 分析具体问题
   ↓
   ├─ CPU高 → jstack
   ├─ 内存高 → jmap
   ├─ GC频繁 → jstat
   └─ 综合诊断 → jcmd
   ↓
5. 生成报告
   ↓
6. 分析优化
```

### 8.2 CPU飙高排查

```bash
#!/bin/bash
# CPU飙高排查脚本

PID=$1

echo "=== CPU飙高排查 ==="
echo "进程ID: $PID"
echo

# 1. 找到CPU占用高的线程
echo "1. 查找CPU占用高的线程..."
top -Hp $PID -n 1 | head -20

# 2. 获取线程转储
echo "2. 生成线程转储..."
jstack $PID > /tmp/jstack_$PID.txt

# 3. 查看JVM参数
echo "3. 查看JVM参数..."
jinfo -flags $PID

# 4. 查看GC情况
echo "4. 查看GC情况..."
jstat -gcutil $PID

echo
echo "线程转储已保存到: /tmp/jstack_$PID.txt"
echo "请分析CPU占用高的线程堆栈"
```

### 8.3 内存问题排查

```bash
#!/bin/bash
# 内存问题排查脚本

PID=$1

echo "=== 内存问题排查 ==="
echo "进程ID: $PID"
echo

# 1. 查看堆内存使用
echo "1. 查看堆内存使用..."
jmap -heap $PID

# 2. 查看对象统计
echo "2. 查看对象统计（Top 20）..."
jmap -histo:live $PID | head -20

# 3. 查看GC情况
echo "3. 查看GC情况..."
jstat -gcutil $PID 1000 5

# 4. 生成堆转储
echo "4. 生成堆转储..."
DUMP_FILE="/tmp/heap_dump_$(date +%Y%m%d_%H%M%S).hprof"
jmap -dump:live,format=b,file=$DUMP_FILE $PID

echo
echo "堆转储已保存到: $DUMP_FILE"
echo "请使用MAT分析堆转储文件"
```

---

## 九、最佳实践

### 9.1 生产环境使用建议

```
生产环境使用原则：

1. 最小化影响
   - 业务低峰期执行
   - 避免频繁执行
   - 注意性能开销

2. 自动化监控
   - 定期采集数据
   - 自动告警
   - 保存历史数据

3. 权限控制
   - 限制使用权限
   - 审计操作记录
   - 保护敏感信息

4. 数据保护
   - 及时清理文件
   - 控制文件大小
   - 避免磁盘满
```

### 9.2 性能影响评估

| 工具 | 性能影响 | 使用场景 | 注意事项 |
|------|---------|---------|---------|
| jps | 极小 | 任何时候 | 无 |
| jstat | 小 | 持续监控 | 无 |
| jinfo | 小 | 查看配置 | 部分参数可修改 |
| jmap -heap | 小 | 查看内存 | 无 |
| jmap -histo | 中 | 分析对象 | 不加live |
| jmap -histo:live | 大 | 内存分析 | 触发Full GC |
| jmap -dump | 大 | 深度分析 | 触发Full GC，应用暂停 |
| jstack | 小 | 线程分析 | 无 |
| jcmd | 小-大 | 综合诊断 | 取决于具体命令 |

### 9.3 常见问题

```
Q1: 为什么jmap -dump会导致应用卡顿？
A: 
- 生成堆转储会触发Full GC
- 应用进入STW状态
- 需要遍历整个堆
- 建议业务低峰期执行

Q2: jstack看不到线程信息怎么办？
A:
- 使用-F强制输出
- 检查权限
- 确认进程存在
- 尝试使用jcmd

Q3: jstat输出的时间单位是什么？
A:
- 时间单位是秒
- 容量单位是KB
- 百分比是0-100

Q4: 如何自动化监控？
A:
- 编写Shell脚本
- 使用crontab定时执行
- 输出到日志文件
- 配置告警规则
```

---

## 十、总结

### 10.1 工具选择指南

```
问题类型 → 推荐工具

CPU问题：
1. top/ps 找到进程和线程
2. jstack 分析线程堆栈
3. jstat 查看GC情况

内存问题：
1. jstat 监控GC
2. jmap -heap 查看内存使用
3. jmap -histo 查看对象分布
4. jmap -dump 生成堆转储
5. MAT 分析堆转储

线程问题：
1. jstack 查看线程状态
2. jstack 分析死锁
3. jcmd Thread.print

GC问题：
1. jstat -gcutil 监控GC
2. jinfo 查看GC参数
3. jcmd GC.heap_info

综合诊断：
1. jcmd（推荐）
2. 组合使用多个工具
```

### 10.2 核心要点

```
1. 工具特点
   - jps: 查看进程
   - jstat: 监控统计
   - jinfo: 查看配置
   - jmap: 内存分析
   - jstack: 线程分析
   - jcmd: 综合诊断

2. 使用原则
   - 最小化影响
   - 业务低峰期
   - 自动化监控
   - 保存历史数据

3. 注意事项
   - 性能开销
   - 权限要求
   - 磁盘空间
   - 应用暂停
```

---

**下一篇**：[可视化工具使用](./02_可视化工具使用.md)
