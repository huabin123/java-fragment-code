# 对象内存布局与分配

## 1. 对象在内存中如何存储？

### 1.1 问题1：一个Java对象在内存中占用多少空间？

**示例对象**：

```java
public class User {
    private int id;           // 4字节
    private String name;      // 引用，4字节（开启压缩指针）或8字节
    private int age;          // 4字节
}

User user = new User();
```

**问题**：
- ❓ 这个对象在内存中占用多少字节？
- ❓ 对象的内存布局是什么样的？
- ❓ 为什么需要对齐填充？

---

## 2. 对象内存布局

### 2.1 对象的三部分组成

```
Java对象内存布局
    ↓
┌─────────────────────────────────┐
│        对象头 (Object Header)    │
│  ┌───────────────────────────┐  │
│  │  Mark Word (标记字)        │  │  ← 8字节（64位）
│  ├───────────────────────────┤  │
│  │  类型指针 (Class Pointer)  │  │  ← 4字节（开启压缩）/8字节
│  ├───────────────────────────┤  │
│  │  数组长度 (Array Length)   │  │  ← 4字节（仅数组对象）
│  └───────────────────────────┘  │
├─────────────────────────────────┤
│      实例数据 (Instance Data)    │  ← 对象的字段数据
│  - 基本类型字段                  │
│  - 引用类型字段                  │
├─────────────────────────────────┤
│      对齐填充 (Padding)          │  ← 填充到8字节的倍数
└─────────────────────────────────┘
```

---

### 2.2 对象头详解

#### 2.2.1 Mark Word（标记字）

**作用**：存储对象自身的运行时数据

**64位JVM的Mark Word结构**：

```
无锁状态（001）：
┌─────────────────────────────────────────────────────────────────┐
│ unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01 │
└─────────────────────────────────────────────────────────────────┘

偏向锁（101）：
┌─────────────────────────────────────────────────────────────────┐
│ thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1 | 01     │
└─────────────────────────────────────────────────────────────────┘

轻量级锁（00）：
┌─────────────────────────────────────────────────────────────────┐
│           ptr_to_lock_record:62                          | 00    │
└─────────────────────────────────────────────────────────────────┘

重量级锁（10）：
┌─────────────────────────────────────────────────────────────────┐
│           ptr_to_heavyweight_monitor:62                  | 10    │
└─────────────────────────────────────────────────────────────────┘

GC标记（11）：
┌─────────────────────────────────────────────────────────────────┐
│                                                          | 11    │
└─────────────────────────────────────────────────────────────────┘
```

**Mark Word存储的信息**：

| 锁状态 | 存储内容 | 标志位 |
|-------|---------|--------|
| 无锁 | hashcode、分代年龄 | 01 |
| 偏向锁 | 线程ID、epoch、分代年龄 | 01 |
| 轻量级锁 | 指向栈中锁记录的指针 | 00 |
| 重量级锁 | 指向Monitor的指针 | 10 |
| GC标记 | 空 | 11 |

**示例代码**：

```java
import org.openjdk.jol.info.ClassLayout;

public class MarkWordDemo {
    public static void main(String[] args) {
        Object obj = new Object();
        
        // 打印对象布局
        System.out.println("创建对象后：");
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        
        // 计算hashCode（会修改Mark Word）
        System.out.println("\n调用hashCode后：");
        obj.hashCode();
        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        
        // 加锁（会修改Mark Word）
        synchronized(obj) {
            System.out.println("\n加锁后：");
            System.out.println(ClassLayout.parseInstance(obj).toPrintable());
        }
    }
}
```

**输出示例**：

```
创建对象后：
java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION               VALUE
      0     4        (object header)           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes

调用hashCode后：
java.lang.Object object internals:
 OFFSET  SIZE   TYPE DESCRIPTION               VALUE
      0     4        (object header)           01 8f 6c 5e (00000001 10001111 01101100 01011110) (1584549633)
      4     4        (object header)           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
```

---

#### 2.2.2 类型指针（Class Pointer）

**作用**：指向对象的类元数据，JVM通过这个指针确定对象是哪个类的实例。

**大小**：
- 未开启指针压缩：8字节
- 开启指针压缩：4字节（默认开启）

**指针压缩**：

```
为什么需要指针压缩？
    ↓
64位JVM的问题：
- 引用占用8字节（比32位多4字节）
- 内存占用增加
- 缓存命中率降低
    ↓
指针压缩原理：
- 对象地址按8字节对齐
- 低3位始终为0
- 可以省略低3位
- 35位可以表示32GB内存（2^35 = 32GB）
    ↓
压缩后：
- 引用占用4字节
- 可以表示32GB堆内存
- 节省内存，提高性能
```

**JVM参数**：

```bash
# 开启指针压缩（默认开启）
-XX:+UseCompressedOops

# 关闭指针压缩
-XX:-UseCompressedOops
```

---

#### 2.2.3 数组长度（Array Length）

**作用**：如果对象是数组，还需要记录数组的长度。

**大小**：4字节

**示例**：

```java
import org.openjdk.jol.info.ClassLayout;

public class ArrayLayoutDemo {
    public static void main(String[] args) {
        int[] array = new int[5];
        
        System.out.println(ClassLayout.parseInstance(array).toPrintable());
    }
}
```

**输出**：

```
[I object internals:
 OFFSET  SIZE   TYPE DESCRIPTION               VALUE
      0     4        (object header)           01 00 00 00
      4     4        (object header)           00 00 00 00
      8     4        (object header)           6d 01 00 f8
     12     4        (object header)           05 00 00 00  ← 数组长度：5
     16    20    int [I.<elements>             N/A
     36     4        (loss due to the next object alignment)
Instance size: 40 bytes
```

---

### 2.3 实例数据（Instance Data）

**定义**：对象真正存储的有效信息，即在程序代码中定义的各种类型的字段内容。

**存储顺序**：

```
字段存储顺序规则：
    ↓
1. 相同宽度的字段总是分配在一起
2. 父类定义的变量会出现在子类之前
3. 如果CompactFields参数为true（默认），子类的窄变量可能插入父类变量的间隙

存储顺序（从大到小）：
long/double (8字节)
    ↓
int/float (4字节)
    ↓
short/char (2字节)
    ↓
byte/boolean (1字节)
    ↓
reference (4字节/8字节)
```

**示例**：

```java
public class User {
    private long id;          // 8字节
    private int age;          // 4字节
    private short level;      // 2字节
    private byte status;      // 1字节
    private boolean active;   // 1字节
    private String name;      // 4字节（压缩指针）
}
```

**内存布局**：

```
┌─────────────────────────────────┐
│  对象头：12字节                  │
│  - Mark Word: 8字节              │
│  - 类型指针: 4字节（压缩）       │
├─────────────────────────────────┤
│  实例数据：                      │
│  - id (long): 8字节              │
│  - age (int): 4字节              │
│  - name (ref): 4字节             │
│  - level (short): 2字节          │
│  - status (byte): 1字节          │
│  - active (boolean): 1字节       │
├─────────────────────────────────┤
│  对齐填充：0字节                 │
│  (12 + 20 = 32，已是8的倍数)    │
└─────────────────────────────────┘
总大小：32字节
```

---

### 2.4 对齐填充（Padding）

**为什么需要对齐填充？**

```
对齐填充的原因
    ↓
1. CPU访问效率
   - CPU按字（word）访问内存
   - 对齐的数据访问更快
    ↓
2. HotSpot要求
   - 对象大小必须是8字节的倍数
   - 简化内存管理
    ↓
3. 缓存行优化
   - 缓存行通常是64字节
   - 对齐可以减少缓存行跨越
```

**示例**：

```java
public class PaddingDemo {
    private byte a;  // 1字节
    // 需要填充7字节
}
```

**内存布局**：

```
┌─────────────────────────────────┐
│  对象头：12字节                  │
├─────────────────────────────────┤
│  实例数据：                      │
│  - a (byte): 1字节               │
├─────────────────────────────────┤
│  对齐填充：3字节                 │
│  (12 + 1 + 3 = 16，是8的倍数)   │
└─────────────────────────────────┘
总大小：16字节
```

---

## 3. 对象大小计算

### 3.1 问题2：如何计算对象大小？

**计算公式**：

```
对象大小 = 对象头 + 实例数据 + 对齐填充

对象头大小：
- 普通对象：12字节（Mark Word 8字节 + 类型指针 4字节）
- 数组对象：16字节（Mark Word 8字节 + 类型指针 4字节 + 数组长度 4字节）

实例数据大小：
- 根据字段类型累加

对齐填充：
- 补齐到8字节的倍数
```

**示例1：空对象**

```java
public class EmptyObject {
}
```

**计算**：

```
对象头：12字节
实例数据：0字节
对齐填充：4字节（12 + 0 + 4 = 16）
总大小：16字节
```

**示例2：包含字段的对象**

```java
public class Person {
    private int age;      // 4字节
    private String name;  // 4字节（压缩指针）
}
```

**计算**：

```
对象头：12字节
实例数据：8字节（4 + 4）
对齐填充：4字节（12 + 8 + 4 = 24）
总大小：24字节
```

**示例3：数组对象**

```java
int[] array = new int[10];
```

**计算**：

```
对象头：16字节（包含数组长度）
实例数据：40字节（10 * 4）
对齐填充：0字节（16 + 40 = 56，已是8的倍数）
总大小：56字节
```

---

### 3.2 使用JOL查看对象布局

**添加依赖**：

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.16</version>
</dependency>
```

**示例代码**：

```java
import org.openjdk.jol.info.ClassLayout;
import org.openjdk.jol.vm.VM;

public class ObjectSizeDemo {
    
    static class EmptyObject {
    }
    
    static class Person {
        private int age;
        private String name;
    }
    
    static class Student extends Person {
        private int score;
    }
    
    public static void main(String[] args) {
        // 打印JVM信息
        System.out.println(VM.current().details());
        System.out.println();
        
        // 空对象
        System.out.println("========== 空对象 ==========");
        System.out.println(ClassLayout.parseClass(EmptyObject.class).toPrintable());
        
        // 包含字段的对象
        System.out.println("========== Person对象 ==========");
        Person person = new Person();
        System.out.println(ClassLayout.parseInstance(person).toPrintable());
        
        // 继承关系的对象
        System.out.println("========== Student对象 ==========");
        Student student = new Student();
        System.out.println(ClassLayout.parseInstance(student).toPrintable());
        
        // 数组对象
        System.out.println("========== 数组对象 ==========");
        int[] array = new int[5];
        System.out.println(ClassLayout.parseInstance(array).toPrintable());
    }
}
```

---

## 4. 对象创建过程

### 4.1 问题3：new一个对象，JVM做了什么？

**对象创建流程**：

```
new关键字
    ↓
1. 类加载检查
   - 检查类是否已加载
   - 如果未加载，先执行类加载
    ↓
2. 分配内存
   - 计算对象大小
   - 在堆中分配内存
    ↓
    ┌──────────┴──────────┐
    ↓                     ↓
指针碰撞              空闲列表
(Serial、ParNew)    (CMS)
    ↓                     ↓
    └──────────┬──────────┘
               ↓
3. 并发安全处理
    ↓
    ┌──────────┴──────────┐
    ↓                     ↓
  CAS + 失败重试        TLAB
    ↓                     ↓
    └──────────┬──────────┘
               ↓
4. 初始化零值
   - 将分配的内存初始化为零值
   - 保证对象字段可以直接使用
    ↓
5. 设置对象头
   - 设置Mark Word
   - 设置类型指针
   - 设置数组长度（如果是数组）
    ↓
6. 执行<init>方法
   - 执行构造函数
   - 初始化字段
    ↓
对象创建完成
```

---

### 4.2 内存分配方式

#### 4.2.1 指针碰撞（Bump the Pointer）

**适用场景**：内存规整（使用Serial、ParNew等带压缩整理的GC）

**原理**：

```
堆内存（规整）
┌─────────────────────────────────────┐
│  已使用  │    空闲                   │
└──────────┴──────────────────────────┘
           ↑
         指针

分配对象：
1. 移动指针
2. 对象大小 = 指针移动的距离

┌─────────────────────────────────────┐
│  已使用  │新对象│    空闲            │
└──────────┴─────┴────────────────────┘
                  ↑
                指针
```

---

#### 4.2.2 空闲列表（Free List）

**适用场景**：内存不规整（使用CMS等基于标记-清除的GC）

**原理**：

```
堆内存（不规整）
┌─────────────────────────────────────┐
│已用│空闲│已用│  空闲  │已用│  空闲  │
└────┴────┴────┴────────┴────┴────────┘

空闲列表：
地址1: 4字节
地址2: 8字节
地址3: 16字节

分配对象：
1. 查找空闲列表
2. 找到合适大小的空闲块
3. 更新空闲列表
```

---

### 4.3 并发安全处理

#### 4.3.1 CAS + 失败重试

```java
// 伪代码
public Object allocate(int size) {
    while (true) {
        int current = pointer;
        int next = current + size;
        
        // CAS更新指针
        if (compareAndSwap(pointer, current, next)) {
            return current; // 分配成功
        }
        // CAS失败，重试
    }
}
```

---

#### 4.3.2 TLAB（Thread Local Allocation Buffer）

**定义**：为每个线程在Eden区预先分配一小块内存。

**优势**：

```
TLAB的优势
    ↓
1. 线程私有
   - 无需同步
   - 提高分配速度
    ↓
2. 减少竞争
   - 大部分对象在TLAB中分配
   - 只有TLAB用完才需要同步
    ↓
3. 提高性能
   - 分配速度快
   - 减少锁竞争
```

**工作流程**：

```
对象分配
    ↓
1. 尝试在TLAB中分配
    ↓
    ┌──────┴──────┐
    ↓             ↓
TLAB有空间    TLAB空间不足
    ↓             ↓
分配成功      2. 申请新的TLAB
              ↓
          3. 在新TLAB中分配
```

**JVM参数**：

```bash
# 开启TLAB（默认开启）
-XX:+UseTLAB

# TLAB大小（默认是Eden区的1%）
-XX:TLABSize=256k

# 打印TLAB信息
-XX:+PrintTLAB
```

---

## 5. 对象访问定位

### 5.1 问题4：通过引用如何访问对象？

**两种方式**：

#### 5.1.1 句柄访问

```
Java栈                     堆
┌─────────┐           ┌─────────────────┐
│ 引用    │──────────→│  句柄池          │
└─────────┘           │ ┌─────────────┐ │
                      │ │ 对象实例指针 │─┼──→ 对象实例数据
                      │ │ 类型数据指针 │─┼──→ 类型数据
                      │ └─────────────┘ │
                      └─────────────────┘

优点：
✅ 引用稳定（对象移动时只需修改句柄）
✅ 适合频繁GC的场景

缺点：
❌ 多一次指针定位
❌ 性能略低
```

---

#### 5.1.2 直接指针访问（HotSpot使用）

```
Java栈                     堆
┌─────────┐           ┌─────────────────┐
│ 引用    │──────────→│  对象实例        │
└─────────┘           │ ┌─────────────┐ │
                      │ │  对象头      │ │
                      │ │  - Mark Word │ │
                      │ │  - 类型指针  │─┼──→ 类型数据
                      │ ├─────────────┤ │
                      │ │  实例数据    │ │
                      │ └─────────────┘ │
                      └─────────────────┘

优点：
✅ 访问速度快（少一次指针定位）
✅ HotSpot使用

缺点：
❌ 对象移动时需要修改引用
```

---

## 6. 实战案例

### 6.1 案例1：对象大小优化

**问题**：如何减少对象内存占用？

**优化前**：

```java
public class User {
    private Long id;          // 8字节（对象） + 对象头
    private Integer age;      // 4字节（对象） + 对象头
    private Boolean active;   // 1字节（对象） + 对象头
    private String name;      // 引用 + String对象
}
```

**优化后**：

```java
public class User {
    private long id;          // 8字节（基本类型）
    private int age;          // 4字节（基本类型）
    private boolean active;   // 1字节（基本类型）
    private String name;      // 引用
}
```

**效果**：
- 减少包装类对象的创建
- 减少对象头的开销
- 提高内存利用率

---

### 6.2 案例2：字段重排序优化

**问题**：如何减少对齐填充？

**优化前**：

```java
public class Data {
    private byte a;     // 1字节
    private long b;     // 8字节
    private byte c;     // 1字节
    private long d;     // 8字节
}
// 对象大小：12(对象头) + 1 + 7(填充) + 8 + 1 + 7(填充) + 8 = 44字节
```

**优化后**：

```java
public class Data {
    private long b;     // 8字节
    private long d;     // 8字节
    private byte a;     // 1字节
    private byte c;     // 1字节
}
// 对象大小：12(对象头) + 8 + 8 + 1 + 1 + 2(填充) = 32字节
```

**效果**：
- 减少对齐填充
- 节省12字节（27%）

---

## 7. 总结

### 7.1 关键知识点

1. **对象内存布局**：对象头 + 实例数据 + 对齐填充
2. **对象头**：Mark Word + 类型指针 + 数组长度（可选）
3. **对象创建**：类加载检查 → 分配内存 → 初始化零值 → 设置对象头 → 执行构造函数
4. **内存分配**：指针碰撞（内存规整）、空闲列表（内存不规整）
5. **并发安全**：CAS + 失败重试、TLAB
6. **对象访问**：句柄访问、直接指针访问（HotSpot）

### 7.2 优化建议

1. ✅ 使用基本类型代替包装类
2. ✅ 合理安排字段顺序，减少对齐填充
3. ✅ 避免创建不必要的对象
4. ✅ 使用对象池复用对象
5. ✅ 关注TLAB的使用情况

---

**下一章**：我们将学习如何分析和排查内存溢出问题。
