# 内存溢出分析与排查

## 1. 什么是内存溢出？

### 1.1 问题1：内存溢出和内存泄漏有什么区别？

**内存溢出（OutOfMemoryError，OOM）**：

```
定义：程序申请内存时，没有足够的内存空间供其使用

原因：
1. 内存泄漏导致可用内存越来越少
2. 对象过大，超过了可用内存
3. 内存配置不合理
```

**内存泄漏（Memory Leak）**：

```
定义：程序中已动态分配的内存由于某种原因未释放或无法释放

特点：
- 对象不再使用，但仍被引用
- GC无法回收
- 可用内存逐渐减少
- 最终导致OOM
```

**关系**：

```
内存泄漏
    ↓
可用内存逐渐减少
    ↓
内存不足
    ↓
内存溢出（OOM）
```

---

## 2. 常见的OOM类型

### 2.1 Java heap space

#### 问题2：为什么会发生堆内存溢出？

**原因**：

```
堆内存溢出的原因
    ↓
1. 内存泄漏
   - 对象无法被GC回收
   - 可用内存逐渐减少
    ↓
2. 堆内存设置过小
   - -Xmx设置不合理
   - 无法满足应用需求
    ↓
3. 创建大量对象
   - 短时间内创建大量对象
   - 超过堆内存容量
    ↓
4. 大对象
   - 单个对象过大
   - 无法分配
```

**示例代码**：

```java
/**
 * 堆内存溢出演示
 * JVM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOMDemo {
    
    static class OOMObject {
        private byte[] data = new byte[1024 * 1024]; // 1MB
    }
    
    public static void main(String[] args) {
        List<OOMObject> list = new ArrayList<>();
        
        try {
            while (true) {
                list.add(new OOMObject());
                System.out.println("创建对象: " + list.size());
            }
        } catch (OutOfMemoryError e) {
            System.out.println("发生OOM，已创建对象数量: " + list.size());
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
创建对象: 1
创建对象: 2
...
创建对象: 18
发生OOM，已创建对象数量: 18
java.lang.OutOfMemoryError: Java heap space
	at HeapOOMDemo$OOMObject.<init>(HeapOOMDemo.java:8)
	at HeapOOMDemo.main(HeapOOMDemo.java:15)
```

**排查步骤**：

```
1. 查看堆内存配置
   jmap -heap <pid>
    ↓
2. 生成堆转储文件
   jmap -dump:format=b,file=heap.hprof <pid>
   或使用 -XX:+HeapDumpOnOutOfMemoryError
    ↓
3. 使用MAT分析堆转储
   - 查找内存占用最大的对象
   - 分析对象引用链
   - 找出内存泄漏点
    ↓
4. 定位代码问题
   - 查看哪些对象占用内存最多
   - 分析为什么无法回收
   - 修复内存泄漏
```

---

### 2.2 Metaspace

#### 问题3：为什么会发生元空间溢出？

**原因**：

```
元空间溢出的原因
    ↓
1. 加载的类过多
   - 动态生成大量类
   - 类无法卸载
    ↓
2. 元空间设置过小
   - -XX:MaxMetaspaceSize设置不合理
    ↓
3. 类加载器泄漏
   - 自定义类加载器未被回收
   - 加载的类也无法回收
```

**示例代码**：

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;

/**
 * 元空间溢出演示
 * JVM参数：-XX:MaxMetaspaceSize=10m
 */
public class MetaspaceOOMDemo {
    
    static class OOMObject {
    }
    
    public static void main(String[] args) {
        int count = 0;
        try {
            while (true) {
                Enhancer enhancer = new Enhancer();
                enhancer.setSuperclass(OOMObject.class);
                enhancer.setUseCache(false);
                enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -> 
                    proxy.invokeSuper(obj, args1));
                
                enhancer.create();
                count++;
                
                if (count % 100 == 0) {
                    System.out.println("创建类数量: " + count);
                }
            }
        } catch (Throwable e) {
            System.out.println("发生OOM，已创建类数量: " + count);
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
创建类数量: 100
创建类数量: 200
...
创建类数量: 1500
发生OOM，已创建类数量: 1532
java.lang.OutOfMemoryError: Metaspace
```

**排查步骤**：

```
1. 查看元空间使用情况
   jstat -gc <pid> 1000
    ↓
2. 查看加载的类数量
   jstat -class <pid>
    ↓
3. 分析类加载情况
   - 哪些类被加载
   - 是否有类加载器泄漏
   - 是否有大量动态生成的类
    ↓
4. 解决方案
   - 增大元空间大小
   - 减少动态生成的类
   - 修复类加载器泄漏
```

---

### 2.3 GC overhead limit exceeded

#### 问题4：什么是GC overhead limit exceeded？

**定义**：GC花费的时间超过98%，但回收的内存不足2%。

**原因**：

```
GC overhead limit exceeded
    ↓
1. 堆内存过小
   - 可用内存不足
   - 频繁Full GC
    ↓
2. 内存泄漏
   - 大量对象无法回收
   - GC效果差
    ↓
3. 对象过多
   - 创建速度 > 回收速度
```

**示例代码**：

```java
/**
 * GC overhead limit exceeded演示
 * JVM参数：-Xms10m -Xmx10m -XX:+PrintGCDetails
 */
public class GCOverheadDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        
        try {
            int i = 0;
            while (true) {
                list.add(String.valueOf(i++).intern());
            }
        } catch (Throwable e) {
            System.out.println("发生异常: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
[GC (Allocation Failure) ... ]
[Full GC (Ergonomics) ... ]
[Full GC (Ergonomics) ... ]
...
java.lang.OutOfMemoryError: GC overhead limit exceeded
```

**解决方案**：

```
1. 增大堆内存
   -Xms512m -Xmx512m
    ↓
2. 排查内存泄漏
   使用MAT分析
    ↓
3. 优化代码
   - 减少对象创建
   - 及时释放资源
    ↓
4. 调整GC参数
   - 选择合适的GC
   - 调整GC阈值
```

---

### 2.4 Direct buffer memory

#### 问题5：为什么会发生直接内存溢出？

**原因**：

```
直接内存溢出的原因
    ↓
1. 直接内存使用过多
   - NIO大量使用DirectByteBuffer
   - 超过MaxDirectMemorySize
    ↓
2. 直接内存未释放
   - DirectByteBuffer未被回收
   - 直接内存泄漏
    ↓
3. 配置不合理
   - MaxDirectMemorySize设置过小
```

**示例代码**：

```java
import java.nio.ByteBuffer;

/**
 * 直接内存溢出演示
 * JVM参数：-XX:MaxDirectMemorySize=10m
 */
public class DirectMemoryOOMDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        List<ByteBuffer> list = new ArrayList<>();
        int count = 0;
        
        try {
            while (true) {
                ByteBuffer buffer = ByteBuffer.allocateDirect(_1MB);
                list.add(buffer);
                count++;
                System.out.println("分配直接内存: " + count + "MB");
            }
        } catch (Throwable e) {
            System.out.println("发生OOM，已分配: " + count + "MB");
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
分配直接内存: 1MB
分配直接内存: 2MB
...
分配直接内存: 10MB
发生OOM，已分配: 10MB
java.lang.OutOfMemoryError: Direct buffer memory
```

**排查步骤**：

```
1. 查看直接内存使用情况
   jcmd <pid> VM.native_memory summary
    ↓
2. 检查NIO使用
   - 是否大量使用DirectByteBuffer
   - 是否及时释放
    ↓
3. 解决方案
   - 增大MaxDirectMemorySize
   - 及时释放DirectByteBuffer
   - 使用堆内存代替直接内存
```

---

### 2.5 unable to create new native thread

#### 问题6：为什么无法创建新线程？

**原因**：

```
无法创建新线程的原因
    ↓
1. 线程数超过系统限制
   - 操作系统限制
   - JVM限制
    ↓
2. 内存不足
   - 每个线程需要栈空间
   - 总内存 = 堆 + 元空间 + 线程栈 * 线程数
    ↓
3. 资源耗尽
   - 文件描述符不足
   - 进程数限制
```

**示例代码**：

```java
/**
 * 无法创建新线程演示
 * JVM参数：-Xss256k（减小栈大小，可以创建更多线程）
 */
public class ThreadOOMDemo {
    
    public static void main(String[] args) {
        int count = 0;
        
        try {
            while (true) {
                new Thread(() -> {
                    try {
                        Thread.sleep(Long.MAX_VALUE);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }).start();
                
                count++;
                if (count % 100 == 0) {
                    System.out.println("创建线程数: " + count);
                }
            }
        } catch (Throwable e) {
            System.out.println("发生OOM，已创建线程数: " + count);
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
创建线程数: 100
创建线程数: 200
...
创建线程数: 2000
发生OOM，已创建线程数: 2048
java.lang.OutOfMemoryError: unable to create new native thread
```

**排查步骤**：

```
1. 查看线程数
   jstack <pid> | grep 'java.lang.Thread.State' | wc -l
    ↓
2. 查看系统限制
   ulimit -u  # 查看用户最大进程数
   ulimit -n  # 查看最大文件描述符数
    ↓
3. 解决方案
   - 减少线程数（使用线程池）
   - 增大系统限制
   - 减小栈大小（-Xss）
   - 减小堆大小（留更多内存给线程）
```

---

### 2.6 StackOverflowError

#### 问题7：为什么会发生栈溢出？

**原因**：

```
栈溢出的原因
    ↓
1. 递归调用过深
   - 无限递归
   - 递归层次过多
    ↓
2. 方法调用链过长
   - 方法嵌套调用过多
    ↓
3. 局部变量过多
   - 单个方法局部变量过大
```

**示例代码**：

```java
/**
 * 栈溢出演示
 * JVM参数：-Xss256k
 */
public class StackOverflowDemo {
    
    private int stackDepth = 0;
    
    // 无限递归
    public void recursion() {
        stackDepth++;
        recursion();
    }
    
    // 大量局部变量
    public void manyLocalVariables() {
        long a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;
        long a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
        // ... 更多局部变量
        manyLocalVariables();
    }
    
    public static void main(String[] args) {
        StackOverflowDemo demo = new StackOverflowDemo();
        
        try {
            demo.recursion();
        } catch (StackOverflowError e) {
            System.out.println("栈深度: " + demo.stackDepth);
            e.printStackTrace();
        }
    }
}
```

**输出**：

```
栈深度: 1024
java.lang.StackOverflowError
	at StackOverflowDemo.recursion(StackOverflowDemo.java:11)
	at StackOverflowDemo.recursion(StackOverflowDemo.java:11)
	at StackOverflowDemo.recursion(StackOverflowDemo.java:11)
	...
```

**解决方案**：

```
1. 优化递归
   - 使用循环代替递归
   - 限制递归深度
   - 使用尾递归优化
    ↓
2. 增大栈大小
   -Xss1m
    ↓
3. 优化代码
   - 减少方法调用层次
   - 减少局部变量
```

---

## 3. 内存泄漏常见场景

### 3.1 场景1：静态集合类

**问题代码**：

```java
public class StaticCollectionLeak {
    // 静态集合，生命周期与应用相同
    private static List<Object> list = new ArrayList<>();
    
    public void addObject(Object obj) {
        list.add(obj);
        // 对象加入后永远不会被移除
        // 导致内存泄漏
    }
}
```

**原因**：

```
静态集合
    ↓
生命周期 = 应用生命周期
    ↓
对象加入后无法被GC
    ↓
内存泄漏
```

**解决方案**：

```java
public class StaticCollectionFixed {
    private static List<Object> list = new ArrayList<>();
    
    public void addObject(Object obj) {
        list.add(obj);
    }
    
    // 提供清理方法
    public void removeObject(Object obj) {
        list.remove(obj);
    }
    
    // 定期清理
    public void cleanup() {
        list.clear();
    }
}
```

---

### 3.2 场景2：监听器未注销

**问题代码**：

```java
public class ListenerLeak {
    private List<EventListener> listeners = new ArrayList<>();
    
    public void addEventListener(EventListener listener) {
        listeners.add(listener);
        // 监听器加入后从未移除
    }
    
    public void fireEvent() {
        for (EventListener listener : listeners) {
            listener.onEvent();
        }
    }
}
```

**原因**：

```
监听器注册
    ↓
未注销
    ↓
监听器对象无法被GC
    ↓
内存泄漏
```

**解决方案**：

```java
public class ListenerFixed {
    private List<EventListener> listeners = new ArrayList<>();
    
    public void addEventListener(EventListener listener) {
        listeners.add(listener);
    }
    
    // 提供注销方法
    public void removeEventListener(EventListener listener) {
        listeners.remove(listener);
    }
    
    // 使用弱引用
    private List<WeakReference<EventListener>> weakListeners = new ArrayList<>();
    
    public void addWeakListener(EventListener listener) {
        weakListeners.add(new WeakReference<>(listener));
    }
}
```

---

### 3.3 场景3：资源未关闭

**问题代码**：

```java
public class ResourceLeak {
    public void readFile(String path) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            // 读取文件
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 未关闭资源，导致内存泄漏
    }
}
```

**解决方案**：

```java
public class ResourceFixed {
    // 使用try-with-resources
    public void readFile(String path) {
        try (FileInputStream fis = new FileInputStream(path)) {
            // 读取文件
        } catch (IOException e) {
            e.printStackTrace();
        }
        // 自动关闭资源
    }
    
    // 或使用finally
    public void readFileWithFinally(String path) {
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(path);
            // 读取文件
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

---

### 3.4 场景4：ThreadLocal未清理

**问题代码**：

```java
public class ThreadLocalLeak {
    private static ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
    
    public void process() {
        // 设置大对象
        threadLocal.set(new byte[1024 * 1024]); // 1MB
        
        // 业务处理
        
        // 未清理ThreadLocal
        // 如果线程被线程池复用，会导致内存泄漏
    }
}
```

**原因**：

```
ThreadLocal设置值
    ↓
线程被线程池复用
    ↓
ThreadLocal值未清理
    ↓
内存泄漏
```

**解决方案**：

```java
public class ThreadLocalFixed {
    private static ThreadLocal<byte[]> threadLocal = new ThreadLocal<>();
    
    public void process() {
        try {
            threadLocal.set(new byte[1024 * 1024]);
            // 业务处理
        } finally {
            // 清理ThreadLocal
            threadLocal.remove();
        }
    }
}
```

---

## 4. 内存分析工具

### 4.1 jmap - 生成堆转储

**命令**：

```bash
# 生成堆转储文件
jmap -dump:format=b,file=heap.hprof <pid>

# 查看堆内存使用情况
jmap -heap <pid>

# 查看对象统计信息
jmap -histo <pid>

# 查看存活对象统计
jmap -histo:live <pid>
```

**示例输出**：

```bash
$ jmap -histo:live 12345

 num     #instances         #bytes  class name
----------------------------------------------
   1:         50000       12000000  [B
   2:         30000        9600000  java.lang.String
   3:         20000        6400000  com.example.User
```

---

### 4.2 MAT - 内存分析工具

**功能**：
1. 分析堆转储文件
2. 查找内存泄漏
3. 分析对象引用链
4. 生成分析报告

**使用步骤**：

```
1. 打开堆转储文件
    ↓
2. 查看Leak Suspects（泄漏嫌疑）
    ↓
3. 查看Dominator Tree（支配树）
    ↓
4. 分析对象引用链
    ↓
5. 定位泄漏代码
```

---

### 4.3 jstat - 监控GC

**命令**：

```bash
# 查看GC统计
jstat -gc <pid> 1000

# 查看GC原因
jstat -gccause <pid> 1000

# 查看类加载统计
jstat -class <pid> 1000
```

**示例输出**：

```bash
$ jstat -gc 12345 1000

 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    YGC     YGCT    FGC    FGCT     GCT   
10240.0 10240.0  0.0   8192.0 81920.0  40960.0  204800.0   102400.0  51200.0 48000.0  100    1.234    5    0.567   1.801
```

---

## 5. 排查流程总结

### 5.1 内存溢出排查流程

```
发现OOM
    ↓
1. 确定OOM类型
   - Java heap space
   - Metaspace
   - Direct buffer memory
   - unable to create new native thread
    ↓
2. 收集信息
   - 查看GC日志
   - 生成堆转储
   - 查看线程堆栈
    ↓
3. 分析问题
   - 使用MAT分析堆转储
   - 查找内存泄漏点
   - 分析对象引用链
    ↓
4. 定位代码
   - 找到问题代码
   - 分析原因
    ↓
5. 修复问题
   - 修复内存泄漏
   - 优化内存使用
   - 调整JVM参数
    ↓
6. 验证修复
   - 压力测试
   - 监控内存使用
```

---

## 6. 最佳实践

### 6.1 预防内存泄漏

1. ✅ 及时释放资源（使用try-with-resources）
2. ✅ 注销监听器
3. ✅ 清理ThreadLocal
4. ✅ 避免静态集合持有大量对象
5. ✅ 使用弱引用/软引用
6. ✅ 定期清理缓存

### 6.2 配置建议

```bash
# 堆内存配置
-Xms4g -Xmx4g  # 初始和最大堆大小相同，避免动态扩展

# OOM时生成堆转储
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/path/to/dump

# GC日志
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:/path/to/gc.log

# 元空间配置
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m
```

---

**下一章**：我们将学习直接内存和堆外内存的使用。
