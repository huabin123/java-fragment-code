# JVM内存结构详解

## 1. 为什么需要了解JVM内存结构？

### 1.1 问题1：不了解内存结构会遇到什么问题？

**实际场景**：

```java
// 场景1：StackOverflowError
public void recursion() {
    recursion(); // 无限递归
}

// 场景2：OutOfMemoryError: Java heap space
List<byte[]> list = new ArrayList<>();
while (true) {
    list.add(new byte[1024 * 1024]); // 不断创建对象
}

// 场景3：OutOfMemoryError: Metaspace
while (true) {
    // 动态生成类
}
```

**不了解内存结构的后果**：
- ❌ 无法理解为什么会发生这些错误
- ❌ 无法有效排查内存问题
- ❌ 无法进行合理的内存配置
- ❌ 无法优化程序性能

**了解内存结构的好处**：
- ✅ 理解内存分配机制
- ✅ 快速定位内存问题
- ✅ 合理配置JVM参数
- ✅ 优化程序性能

---

## 2. JVM内存结构总览

### 2.1 问题2：JVM内存是如何划分的？

**JVM内存结构图**：

```
┌─────────────────────────────────────────────────────────────┐
│                        JVM内存结构                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────┐        ┌──────────────────┐          │
│  │   线程私有区域    │        │   线程共享区域    │          │
│  ├──────────────────┤        ├──────────────────┤          │
│  │  程序计数器       │        │      堆          │          │
│  │  (PC Register)   │        │    (Heap)        │          │
│  ├──────────────────┤        │                  │          │
│  │  虚拟机栈         │        │  ┌────────────┐ │          │
│  │  (VM Stack)      │        │  │  新生代     │ │          │
│  ├──────────────────┤        │  │  (Young)    │ │          │
│  │  本地方法栈       │        │  │  - Eden     │ │          │
│  │  (Native Stack)  │        │  │  - S0       │ │          │
│  └──────────────────┘        │  │  - S1       │ │          │
│                              │  ├────────────┤ │          │
│                              │  │  老年代     │ │          │
│                              │  │  (Old)      │ │          │
│                              │  └────────────┘ │          │
│                              ├──────────────────┤          │
│                              │    方法区        │          │
│                              │  (Method Area)   │          │
│                              │  - 元空间        │          │
│                              │  (Metaspace)     │          │
│                              └──────────────────┘          │
│                                                              │
│  ┌──────────────────────────────────────────────┐          │
│  │           直接内存 (Direct Memory)             │          │
│  └──────────────────────────────────────────────┘          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**内存区域分类**：

| 区域 | 线程私有/共享 | 是否会OOM | 作用 |
|-----|-------------|----------|------|
| 程序计数器 | 私有 | ❌ 不会 | 记录当前线程执行的字节码行号 |
| 虚拟机栈 | 私有 | ✅ 会 | 存储局部变量、操作数栈等 |
| 本地方法栈 | 私有 | ✅ 会 | 为Native方法服务 |
| 堆 | 共享 | ✅ 会 | 存储对象实例 |
| 方法区 | 共享 | ✅ 会 | 存储类信息、常量、静态变量 |
| 直接内存 | - | ✅ 会 | NIO使用的堆外内存 |

---

## 3. 线程私有区域

### 3.1 程序计数器（Program Counter Register）

#### 问题3：程序计数器是什么？为什么需要它？

**定义**：程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。

**作用**：

```
线程执行流程
    ↓
字节码解释器工作
    ↓
通过改变程序计数器的值
    ↓
选取下一条需要执行的字节码指令
    ↓
分支、循环、跳转、异常处理、线程恢复等
```

**为什么需要程序计数器？**

```java
// 示例：多线程场景
public class PCDemo {
    private static int count = 0;
    
    public static void main(String[] args) {
        // 线程1执行
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count++; // 执行到这里，PC记录字节码行号
            }
        });
        
        // 线程2执行
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 1000; i++) {
                count++; // 执行到这里，PC记录字节码行号
            }
        });
        
        t1.start();
        t2.start();
    }
}
```

**多线程切换场景**：

```
时间轴：
T1: 线程1执行到字节码行号10
T2: CPU切换到线程2
T3: 线程2执行到字节码行号20
T4: CPU切换回线程1
T5: 线程1从行号10继续执行 ← 程序计数器记录了位置
```

**特点**：
1. ✅ 线程私有：每个线程都有独立的程序计数器
2. ✅ 不会OOM：唯一不会发生OutOfMemoryError的区域
3. ✅ 执行Java方法：记录正在执行的虚拟机字节码指令地址
4. ✅ 执行Native方法：计数器值为空（Undefined）

---

### 3.2 虚拟机栈（Java Virtual Machine Stack）

#### 问题4：虚拟机栈是什么？它存储什么？

**定义**：虚拟机栈描述的是Java方法执行的内存模型。

**栈帧结构**：

```
虚拟机栈
    ↓
┌─────────────────────┐
│   栈帧3 (方法3)      │ ← 栈顶（当前执行的方法）
├─────────────────────┤
│   栈帧2 (方法2)      │
├─────────────────────┤
│   栈帧1 (方法1)      │
└─────────────────────┘

每个栈帧包含：
┌─────────────────────┐
│   局部变量表         │ ← 存储方法参数和局部变量
├─────────────────────┤
│   操作数栈          │ ← 进行算术运算和方法调用
├─────────────────────┤
│   动态链接          │ ← 指向运行时常量池的方法引用
├─────────────────────┤
│   方法返回地址       │ ← 方法退出后返回的位置
└─────────────────────┘
```

**示例代码**：

```java
public class StackDemo {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int c = add(a, b);
        System.out.println(c);
    }
    
    public static int add(int x, int y) {
        int result = x + y;
        return result;
    }
}
```

**执行流程**：

```
1. main方法入栈
   栈帧：
   - 局部变量表：[args, a=1, b=2, c=未初始化]
   - 操作数栈：[]

2. 调用add方法，add方法入栈
   栈帧：
   - 局部变量表：[x=1, y=2, result=未初始化]
   - 操作数栈：[]

3. add方法执行完毕，返回结果3
   - add方法出栈
   - 返回值3压入main方法的操作数栈

4. main方法继续执行
   - c = 3
   - 打印c

5. main方法执行完毕，出栈
```

**局部变量表详解**：

```
局部变量表
    ↓
存储内容：
- 基本数据类型（boolean、byte、char、short、int、float、long、double）
- 对象引用（reference类型）
- returnAddress类型（指向字节码指令地址）

存储单位：
- Slot（变量槽）
- long和double占用2个Slot
- 其他类型占用1个Slot

示例：
public void method(int a, long b, Object c) {
    // 局部变量表：
    // Slot 0: this（实例方法）
    // Slot 1: a (int, 1个Slot)
    // Slot 2-3: b (long, 2个Slot)
    // Slot 4: c (引用, 1个Slot)
}
```

**可能出现的异常**：

1. **StackOverflowError**：线程请求的栈深度大于虚拟机允许的深度

```java
public void recursion() {
    recursion(); // 无限递归，导致StackOverflowError
}
```

2. **OutOfMemoryError**：虚拟机栈动态扩展时无法申请到足够内存

```java
// 创建大量线程，每个线程都有自己的栈
while (true) {
    new Thread(() -> {
        try {
            Thread.sleep(Long.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }).start();
}
```

**JVM参数**：

```bash
# 设置栈大小（默认1MB）
-Xss256k  # 设置为256KB
-Xss1m    # 设置为1MB
```

---

### 3.3 本地方法栈（Native Method Stack）

#### 问题5：本地方法栈与虚拟机栈有什么区别？

**区别**：

| 特性 | 虚拟机栈 | 本地方法栈 |
|-----|---------|-----------|
| 服务对象 | Java方法 | Native方法 |
| 实现语言 | Java | C/C++ |
| 是否规范 | 有明确规范 | 规范宽松 |

**Native方法示例**：

```java
public class NativeDemo {
    // Native方法声明
    public native void nativeMethod();
    
    // Object类的Native方法
    public final native Class<?> getClass();
    public native int hashCode();
    protected native Object clone() throws CloneNotSupportedException;
    
    // Thread类的Native方法
    public static native void sleep(long millis) throws InterruptedException;
    public static native void yield();
}
```

**HotSpot虚拟机的实现**：

HotSpot虚拟机直接将虚拟机栈和本地方法栈合二为一。

```
HotSpot虚拟机
    ↓
虚拟机栈 = Java方法栈 + Native方法栈
```

---

## 4. 线程共享区域

### 4.1 堆（Heap）

#### 问题6：堆是什么？为什么要分代？

**定义**：堆是JVM管理的最大一块内存区域，所有线程共享，用于存储对象实例。

**堆的结构**：

```
堆 (Heap)
    ↓
┌─────────────────────────────────────────┐
│           新生代 (Young Generation)      │
│  ┌────────────────────────────────────┐ │
│  │         Eden区 (80%)                │ │
│  ├────────────────────────────────────┤ │
│  │  Survivor 0 (From) (10%)           │ │
│  ├────────────────────────────────────┤ │
│  │  Survivor 1 (To) (10%)             │ │
│  └────────────────────────────────────┘ │
├─────────────────────────────────────────┤
│           老年代 (Old Generation)        │
│                                          │
│                                          │
└─────────────────────────────────────────┘

默认比例：
新生代 : 老年代 = 1 : 2
Eden : Survivor0 : Survivor1 = 8 : 1 : 1
```

**为什么要分代？**

```
对象生命周期观察
    ↓
发现规律：
- 98%的对象朝生夕死（短命对象）
- 2%的对象长期存活（长寿对象）
    ↓
分代设计思想
    ↓
┌────────────────────────────────┐
│  新生代：存放短命对象            │
│  - 频繁GC（Minor GC）           │
│  - 回收速度快                   │
│  - 使用复制算法                 │
├────────────────────────────────┤
│  老年代：存放长寿对象            │
│  - 不频繁GC（Major GC）         │
│  - 回收速度慢                   │
│  - 使用标记-清除或标记-整理     │
└────────────────────────────────┘
    ↓
优势：
✅ 提高GC效率
✅ 减少GC停顿时间
✅ 提高内存利用率
```

**对象分配流程**：

```
创建对象
    ↓
1. 尝试在Eden区分配
    ↓
    ┌──────┴──────┐
    ↓             ↓
Eden有空间    Eden空间不足
    ↓             ↓
分配成功      触发Minor GC
              ↓
          清理Eden区
              ↓
          存活对象移到Survivor
              ↓
          年龄+1
              ↓
          ┌──────┴──────┐
          ↓             ↓
      年龄<15        年龄>=15
          ↓             ↓
      留在Survivor   晋升到老年代
```

**特殊情况**：

1. **大对象直接进入老年代**

```java
// -XX:PretenureSizeThreshold=3145728 (3MB)
byte[] bigObject = new byte[4 * 1024 * 1024]; // 4MB，直接进入老年代
```

2. **动态年龄判定**

```
如果Survivor中相同年龄所有对象大小的总和 > Survivor空间的一半
    ↓
年龄 >= 该年龄的对象直接进入老年代
```

3. **空间分配担保**

```
Minor GC前检查：
老年代最大可用连续空间 > 新生代所有对象总空间
    ↓
    ┌──────┴──────┐
    ↓             ↓
   是            否
    ↓             ↓
安全执行      检查HandlePromotionFailure
Minor GC      ↓
          ┌──────┴──────┐
          ↓             ↓
        允许          不允许
          ↓             ↓
      执行Minor GC  执行Full GC
```

**JVM参数**：

```bash
# 堆大小配置
-Xms2g          # 初始堆大小2GB
-Xmx4g          # 最大堆大小4GB
-Xmn1g          # 新生代大小1GB

# 新生代与老年代比例
-XX:NewRatio=2  # 新生代:老年代=1:2

# Eden与Survivor比例
-XX:SurvivorRatio=8  # Eden:Survivor0:Survivor1=8:1:1

# 晋升老年代的年龄阈值
-XX:MaxTenuringThreshold=15  # 默认15

# 大对象阈值
-XX:PretenureSizeThreshold=3145728  # 3MB
```

---

### 4.2 方法区（Method Area）

#### 问题7：方法区存储什么？为什么JDK 8要用元空间替代永久代？

**定义**：方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

**方法区存储内容**：

```
方法区 (Method Area)
    ↓
┌─────────────────────────────────┐
│  类信息                          │
│  - 类的全限定名                  │
│  - 父类的全限定名                │
│  - 接口列表                      │
│  - 字段信息                      │
│  - 方法信息                      │
│  - 访问修饰符                    │
├─────────────────────────────────┤
│  运行时常量池                    │
│  - 字面量（Literal）             │
│  - 符号引用（Symbolic Reference）│
├─────────────────────────────────┤
│  静态变量                        │
│  - static修饰的变量              │
├─────────────────────────────────┤
│  即时编译器编译后的代码          │
│  - JIT编译的本地代码             │
└─────────────────────────────────┘
```

**永久代 vs 元空间**：

| 特性 | 永久代（JDK 7及之前） | 元空间（JDK 8+） |
|-----|---------------------|-----------------|
| 位置 | JVM堆内存 | 本地内存（Native Memory） |
| 大小限制 | 固定大小 | 默认无限制（受系统内存限制） |
| GC | Full GC回收 | 类卸载时回收 |
| OOM | 容易发生 | 不容易发生 |

**为什么要用元空间替代永久代？**

```
永久代的问题
    ↓
1. 固定大小限制
   - 难以确定合适的大小
   - 容易发生OOM
    ↓
2. GC效率低
   - Full GC才回收
   - 影响性能
    ↓
3. 与堆内存竞争
   - 占用堆空间
    ↓
元空间的优势
    ↓
1. 使用本地内存
   - 不占用堆空间
   - 大小可动态调整
    ↓
2. 减少OOM
   - 受系统内存限制
   - 更灵活
    ↓
3. 简化GC
   - 类卸载时回收
   - 提高效率
```

**运行时常量池**：

```java
public class ConstantPoolDemo {
    public static void main(String[] args) {
        // 字面量
        String s1 = "hello";  // 存储在运行时常量池
        String s2 = "hello";  // 从常量池获取
        System.out.println(s1 == s2);  // true
        
        // 运行时生成
        String s3 = new String("hello");  // 堆中创建新对象
        System.out.println(s1 == s3);  // false
        
        // intern方法
        String s4 = s3.intern();  // 返回常量池中的引用
        System.out.println(s1 == s4);  // true
    }
}
```

**JVM参数**：

```bash
# JDK 7及之前（永久代）
-XX:PermSize=128m       # 初始永久代大小
-XX:MaxPermSize=256m    # 最大永久代大小

# JDK 8+（元空间）
-XX:MetaspaceSize=128m      # 初始元空间大小
-XX:MaxMetaspaceSize=256m   # 最大元空间大小（默认无限制）
```

---

## 5. 直接内存（Direct Memory）

### 5.1 问题8：什么是直接内存？为什么需要它？

**定义**：直接内存不是JVM运行时数据区的一部分，而是通过Native函数库直接分配的堆外内存。

**为什么需要直接内存？**

```
传统IO流程（使用堆内存）
    ↓
1. 应用程序发起读请求
    ↓
2. 操作系统将数据读到内核缓冲区
    ↓
3. 数据从内核缓冲区复制到JVM堆内存
    ↓
4. 应用程序处理数据
    ↓
问题：多了一次复制，性能损耗

NIO流程（使用直接内存）
    ↓
1. 应用程序发起读请求
    ↓
2. 操作系统将数据直接读到直接内存
    ↓
3. 应用程序直接访问直接内存
    ↓
优势：减少一次复制，提高性能
```

**使用示例**：

```java
import java.nio.ByteBuffer;

public class DirectMemoryDemo {
    public static void main(String[] args) {
        // 分配堆内存
        ByteBuffer heapBuffer = ByteBuffer.allocate(1024);
        
        // 分配直接内存
        ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);
        
        // 直接内存的优势：
        // 1. 减少数据复制
        // 2. 提高IO性能
        // 3. 适合大数据量、频繁IO的场景
    }
}
```

**直接内存的特点**：

```
优点：
✅ 减少数据复制
✅ 提高IO性能
✅ 不受JVM堆大小限制

缺点：
❌ 分配和回收成本高
❌ 不受JVM GC管理
❌ 可能导致OOM
```

**JVM参数**：

```bash
# 设置直接内存大小（默认与-Xmx相同）
-XX:MaxDirectMemorySize=512m
```

---

## 6. 内存结构总结

### 6.1 各区域对比

| 区域 | 线程私有/共享 | 是否会OOM | GC | 存储内容 |
|-----|-------------|----------|----|---------| 
| 程序计数器 | 私有 | ❌ | ❌ | 字节码行号 |
| 虚拟机栈 | 私有 | ✅ | ❌ | 局部变量、操作数栈 |
| 本地方法栈 | 私有 | ✅ | ❌ | Native方法 |
| 堆 | 共享 | ✅ | ✅ | 对象实例 |
| 方法区 | 共享 | ✅ | ✅ | 类信息、常量、静态变量 |
| 直接内存 | - | ✅ | ❌ | 堆外内存 |

### 6.2 内存分配流程

```
对象创建
    ↓
1. 检查类是否已加载
    ↓
2. 分配内存
    ↓
    ┌──────────┴──────────┐
    ↓                     ↓
指针碰撞              空闲列表
(内存规整)          (内存不规整)
    ↓                     ↓
    └──────────┬──────────┘
               ↓
3. 初始化零值
    ↓
4. 设置对象头
    ↓
5. 执行<init>方法
    ↓
对象创建完成
```

### 6.3 关键问题回顾

1. **为什么需要程序计数器？**
   - 多线程切换时恢复执行位置

2. **为什么要分代？**
   - 根据对象生命周期特点优化GC效率

3. **为什么用元空间替代永久代？**
   - 避免OOM，提高灵活性

4. **为什么需要直接内存？**
   - 减少数据复制，提高IO性能

---

**下一章**：我们将深入学习对象在内存中的布局和分配策略。
