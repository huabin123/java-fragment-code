# 垃圾收集器详解

## 📚 概述

垃圾收集器是垃圾回收算法的具体实现。不同的垃圾收集器适用于不同的应用场景，理解各种收集器的特点对于JVM调优至关重要。

## 🎯 核心问题

- ❓ 有哪些垃圾收集器？
- ❓ 各个收集器的特点是什么？
- ❓ 如何选择合适的垃圾收集器？
- ❓ Serial、Parallel、CMS、G1、ZGC有什么区别？
- ❓ 如何配置和调优垃圾收集器？

---

## 一、垃圾收集器概览

### 1.1 收集器分类

```
按代分类：
- 新生代收集器：Serial、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 全堆收集器：G1、ZGC、Shenandoah

按线程数分类：
- 串行收集器：Serial、Serial Old
- 并行收集器：ParNew、Parallel Scavenge、Parallel Old
- 并发收集器：CMS、G1、ZGC

按暂停时间分类：
- 高吞吐量：Parallel Scavenge、Parallel Old
- 低延迟：CMS、G1、ZGC
```

### 1.2 收集器组合

```
JDK 8常用组合：

新生代          老年代
Serial    +    Serial Old
Serial    +    CMS
ParNew    +    Serial Old
ParNew    +    CMS
Parallel  +    Serial Old
Parallel  +    Parallel Old
G1（新生代+老年代）

JDK 11+：
G1（默认）
ZGC
Shenandoah
```

### 1.3 收集器演进

```
时间线：
1999: Serial、Serial Old
2002: Parallel Scavenge、Parallel Old
2004: CMS
2012: G1
2018: ZGC（实验性）
2020: ZGC（生产可用）
2021: Shenandoah

趋势：
串行 → 并行 → 并发 → 低延迟
```

---

## 二、Serial收集器

### 2.1 概述

Serial是最基本、历史最悠久的收集器，使用单线程进行垃圾回收。

```
工作流程：

应用线程：运行 → 暂停 ────────────→ 恢复运行
                    ↓
GC线程：           启动 → 回收 → 完成
                    (单线程)
```

### 2.2 特点

| 特点 | 说明 |
|------|------|
| **线程** | 单线程 |
| **算法** | 新生代：标记-复制<br>老年代：标记-整理 |
| **STW** | 是 |
| **适用场景** | 单核CPU、客户端应用 |
| **优点** | 简单高效、内存占用小 |
| **缺点** | STW时间长 |

### 2.3 使用方式

```bash
# 启用Serial收集器
java -XX:+UseSerialGC -jar app.jar

# 参数说明：
# -XX:+UseSerialGC  新生代和老年代都使用Serial
```

### 2.4 示例

```java
/**
 * Serial GC演示
 * VM参数：-XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails
 */
public class SerialGCDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3, allocation4;
        
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        
        // 触发Minor GC
        allocation4 = new byte[4 * _1MB];
    }
}

// 输出示例：
// [GC (Allocation Failure) [DefNew: 6487K->671K(9216K), 0.0034567 secs] 6487K->4767K(19456K), 0.0035123 secs]
// DefNew: Serial收集器的新生代名称
```

---

## 三、ParNew收集器

### 3.1 概述

ParNew是Serial的多线程版本，是CMS的默认新生代收集器。

```
工作流程：

应用线程：运行 → 暂停 ────────────→ 恢复运行
                    ↓
GC线程1：          启动 → 回收 → 完成
GC线程2：          启动 → 回收 → 完成
GC线程3：          启动 → 回收 → 完成
                    (多线程并行)
```

### 3.2 特点

| 特点 | 说明 |
|------|------|
| **线程** | 多线程并行 |
| **算法** | 标记-复制 |
| **STW** | 是 |
| **适用场景** | 多核CPU、配合CMS使用 |
| **优点** | 多核下效率高 |
| **缺点** | 单核下不如Serial |

### 3.3 使用方式

```bash
# 启用ParNew收集器
java -XX:+UseParNewGC -jar app.jar

# 设置GC线程数
java -XX:+UseParNewGC -XX:ParallelGCThreads=4 -jar app.jar

# 参数说明：
# -XX:+UseParNewGC  新生代使用ParNew
# -XX:ParallelGCThreads  GC线程数（默认等于CPU核数）
```

### 3.4 示例

```java
/**
 * ParNew GC演示
 * VM参数：-XX:+UseParNewGC -XX:+UseConcMarkSweepGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails
 */
public class ParNewGCDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3, allocation4;
        
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        
        // 触发Minor GC（多线程并行）
        allocation4 = new byte[4 * _1MB];
    }
}

// 输出示例：
// [GC (Allocation Failure) [ParNew: 6487K->671K(9216K), 0.0023456 secs] 6487K->4767K(19456K), 0.0024012 secs]
// ParNew: ParNew收集器的名称
```

---

## 四、Parallel Scavenge收集器

### 4.1 概述

Parallel Scavenge是吞吐量优先的收集器，目标是达到可控的吞吐量。

```
吞吐量 = 运行用户代码时间 / (运行用户代码时间 + GC时间)

例如：
- 程序运行100分钟
- GC耗时1分钟
- 吞吐量 = 99 / 100 = 99%
```

### 4.2 特点

| 特点 | 说明 |
|------|------|
| **线程** | 多线程并行 |
| **算法** | 标记-复制 |
| **目标** | 高吞吐量 |
| **适用场景** | 后台计算、批处理 |
| **优点** | 吞吐量高 |
| **缺点** | 停顿时间可能较长 |

### 4.3 使用方式

```bash
# 启用Parallel Scavenge收集器
java -XX:+UseParallelGC -jar app.jar

# 设置最大GC停顿时间
java -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -jar app.jar

# 设置吞吐量目标
java -XX:+UseParallelGC -XX:GCTimeRatio=99 -jar app.jar

# 自适应调节策略
java -XX:+UseParallelGC -XX:+UseAdaptiveSizePolicy -jar app.jar

# 参数说明：
# -XX:+UseParallelGC  新生代使用Parallel Scavenge
# -XX:MaxGCPauseMillis  最大GC停顿时间（毫秒）
# -XX:GCTimeRatio  吞吐量目标（默认99，即1%的GC时间）
# -XX:+UseAdaptiveSizePolicy  自动调节新生代大小、Eden/Survivor比例等
```

### 4.4 示例

```java
/**
 * Parallel Scavenge GC演示
 * VM参数：-XX:+UseParallelGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails
 */
public class ParallelScavengeDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        byte[] allocation1, allocation2, allocation3, allocation4;
        
        allocation1 = new byte[2 * _1MB];
        allocation2 = new byte[2 * _1MB];
        allocation3 = new byte[2 * _1MB];
        
        // 触发Minor GC
        allocation4 = new byte[4 * _1MB];
    }
}

// 输出示例：
// [GC (Allocation Failure) [PSYoungGen: 6487K->671K(9216K)] 6487K->4767K(19456K), 0.0023456 secs]
// PSYoungGen: Parallel Scavenge的新生代名称
```

### 4.5 自适应调节

```java
/**
 * 自适应调节演示
 * VM参数：-XX:+UseParallelGC -XX:+UseAdaptiveSizePolicy -XX:+PrintAdaptiveSizePolicy
 */
public class AdaptiveSizePolicyDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) {
        List<byte[]> list = new ArrayList<>();
        
        // 持续分配对象
        for (int i = 0; i < 100; i++) {
            list.add(new byte[_1MB]);
            
            if (i % 10 == 0) {
                System.out.println("已分配: " + (i + 1) + "MB");
            }
        }
        
        // JVM会自动调节：
        // - 新生代大小
        // - Eden/Survivor比例
        // - 晋升年龄阈值
        // 以达到最佳吞吐量
    }
}
```

---

## 五、Serial Old收集器

### 5.1 概述

Serial Old是Serial的老年代版本，使用标记-整理算法。

### 5.2 特点

| 特点 | 说明 |
|------|------|
| **线程** | 单线程 |
| **算法** | 标记-整理 |
| **STW** | 是 |
| **适用场景** | 客户端应用、CMS的后备方案 |

### 5.3 使用场景

```
1. 客户端模式下的老年代收集器

2. CMS的后备方案：
   - CMS并发失败时
   - 使用Serial Old进行Full GC
```

---

## 六、Parallel Old收集器

### 6.1 概述

Parallel Old是Parallel Scavenge的老年代版本，使用标记-整理算法。

### 6.2 特点

| 特点 | 说明 |
|------|------|
| **线程** | 多线程并行 |
| **算法** | 标记-整理 |
| **目标** | 高吞吐量 |
| **适用场景** | 配合Parallel Scavenge使用 |

### 6.3 使用方式

```bash
# 启用Parallel Old收集器
java -XX:+UseParallelOldGC -jar app.jar

# 完整配置（新生代+老年代）
java -XX:+UseParallelGC -XX:+UseParallelOldGC -jar app.jar
```

---

## 七、CMS收集器

### 7.1 概述

CMS（Concurrent Mark Sweep）是一款以获取最短停顿时间为目标的收集器，适合重视响应速度的应用。

```
设计目标：
- 降低停顿时间
- 与应用线程并发执行
- 适合互联网应用
```

### 7.2 工作流程

```
CMS GC的4个阶段：

1. 初始标记（STW）
   - 标记GC Roots直接关联的对象
   - 速度很快

2. 并发标记
   - 从GC Roots遍历对象图
   - 与应用线程并发执行
   - 耗时最长

3. 重新标记（STW）
   - 修正并发标记期间的变动
   - 比初始标记稍长，但远比并发标记短

4. 并发清除
   - 清除未标记的对象
   - 与应用线程并发执行
```

```
时间线：

应用线程：运行 → 暂停 → 运行 ────────→ 暂停 → 运行 ────────→ 运行
                  ↓           ↓                    ↓
GC线程：         初始  →  并发标记  →  重新  →  并发清除
                标记                  标记
                (STW)                (STW)
```

### 7.3 特点

| 特点 | 说明 |
|------|------|
| **线程** | 多线程并发 |
| **算法** | 标记-清除 |
| **STW** | 初始标记和重新标记 |
| **优点** | 停顿时间短、并发执行 |
| **缺点** | 产生碎片、占用CPU资源、并发失败 |

### 7.4 使用方式

```bash
# 启用CMS收集器
java -XX:+UseConcMarkSweepGC -jar app.jar

# 设置CMS参数
java -XX:+UseConcMarkSweepGC \
     -XX:CMSInitiatingOccupancyFraction=75 \
     -XX:+UseCMSInitiatingOccupancyOnly \
     -XX:+CMSScavengeBeforeRemark \
     -XX:+CMSParallelRemarkEnabled \
     -jar app.jar

# 参数说明：
# -XX:+UseConcMarkSweepGC  启用CMS
# -XX:CMSInitiatingOccupancyFraction  老年代使用率达到多少时触发CMS（默认92%）
# -XX:+UseCMSInitiatingOccupancyOnly  只使用设定的阈值
# -XX:+CMSScavengeBeforeRemark  重新标记前进行一次Minor GC
# -XX:+CMSParallelRemarkEnabled  重新标记阶段并行执行
```

### 7.5 示例

```java
/**
 * CMS GC演示
 * VM参数：-XX:+UseConcMarkSweepGC -Xms20M -Xmx20M -XX:+PrintGCDetails
 */
public class CMSGCDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) throws InterruptedException {
        List<byte[]> list = new ArrayList<>();
        
        // 持续分配对象
        for (int i = 0; i < 100; i++) {
            list.add(new byte[_1MB]);
            Thread.sleep(10);
            
            if (i % 10 == 0) {
                System.out.println("已分配: " + (i + 1) + "MB");
            }
        }
    }
}

// 输出示例：
// [GC (CMS Initial Mark) [1 CMS-initial-mark: 10812K(20480K)] 14012K(29696K), 0.0001234 secs]
// [CMS-concurrent-mark-start]
// [CMS-concurrent-mark: 0.0123456 secs]
// [CMS-concurrent-preclean-start]
// [CMS-concurrent-preclean: 0.0012345 secs]
// [GC (CMS Final Remark) [YG occupancy: 3200 K (9216 K)]
// [Rescan (parallel) , 0.0012345 secs]
// [weak refs processing, 0.0001234 secs]
// [class unloading, 0.0001234 secs]
// [scrub symbol table, 0.0001234 secs]
// [scrub string table, 0.0001234 secs]
// [1 CMS-remark: 10812K(20480K)] 14012K(29696K), 0.0023456 secs]
// [CMS-concurrent-sweep-start]
// [CMS-concurrent-sweep: 0.0123456 secs]
// [CMS-concurrent-reset-start]
// [CMS-concurrent-reset: 0.0012345 secs]
```

### 7.6 CMS的问题

#### 1. 内存碎片

```
问题：
- CMS使用标记-清除算法
- 产生大量内存碎片
- 无法分配大对象时触发Full GC

解决：
- 定期进行内存整理
- -XX:+UseCMSCompactAtFullCollection  Full GC时整理内存
- -XX:CMSFullGCsBeforeCompaction=5  5次Full GC后整理一次
```

#### 2. 并发失败（Concurrent Mode Failure）

```
问题：
- CMS并发清除时，应用线程继续运行
- 可能产生新的垃圾（浮动垃圾）
- 如果老年代空间不足，触发并发失败
- 降级使用Serial Old进行Full GC

解决：
- 降低触发阈值，提前进行CMS GC
- -XX:CMSInitiatingOccupancyFraction=70
```

#### 3. CPU资源占用

```
问题：
- CMS并发阶段占用CPU资源
- 影响应用性能

默认GC线程数：
(CPU核数 + 3) / 4

例如：
- 4核CPU：(4 + 3) / 4 = 1个GC线程
- 8核CPU：(8 + 3) / 4 = 2个GC线程
```

---

## 八、G1收集器

### 8.1 概述

G1（Garbage First）是面向服务端的收集器，JDK 9后的默认收集器。

```
设计目标：
- 可预测的停顿时间
- 不产生内存碎片
- 兼顾吞吐量和延迟
```

### 8.2 内存布局

```
传统分代：
[新生代：Eden | S0 | S1] [老年代]

G1分区：
+---+---+---+---+---+---+---+---+
| E | E | S | O | O | E | S | O |
+---+---+---+---+---+---+---+---+
| E | O | O | E | S | O | E | O |
+---+---+---+---+---+---+---+---+

E: Eden区
S: Survivor区
O: Old区
H: Humongous区（大对象）

特点：
- 将堆划分为多个大小相等的Region（1-32MB）
- 每个Region可以是Eden、Survivor或Old
- 不需要连续的内存空间
```

### 8.3 工作流程

```
G1 GC的阶段：

1. Young GC
   - 回收Eden区和Survivor区
   - 存活对象复制到Survivor或Old区
   - STW，但时间可控

2. Mixed GC
   - 回收整个Young区 + 部分Old区
   - 选择回收价值最大的Region
   - STW，但时间可控

3. Full GC
   - 回收整个堆
   - 使用Serial Old算法
   - STW时间长（应该避免）
```

### 8.4 特点

| 特点 | 说明 |
|------|------|
| **内存布局** | Region分区 |
| **算法** | 标记-复制 + 标记-整理 |
| **停顿时间** | 可预测 |
| **适用场景** | 大堆内存、低延迟要求 |
| **优点** | 停顿时间可控、无碎片 |
| **缺点** | 内存占用高、CPU占用高 |

### 8.5 使用方式

```bash
# 启用G1收集器
java -XX:+UseG1GC -jar app.jar

# 设置停顿时间目标
java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar app.jar

# 设置Region大小
java -XX:+UseG1GC -XX:G1HeapRegionSize=16m -jar app.jar

# 设置并发GC线程数
java -XX:+UseG1GC -XX:ConcGCThreads=4 -jar app.jar

# 参数说明：
# -XX:+UseG1GC  启用G1
# -XX:MaxGCPauseMillis  最大停顿时间目标（默认200ms）
# -XX:G1HeapRegionSize  Region大小（1-32MB，必须是2的幂）
# -XX:ConcGCThreads  并发GC线程数
# -XX:InitiatingHeapOccupancyPercent  触发并发GC的堆占用率（默认45%）
```

### 8.6 示例

```java
/**
 * G1 GC演示
 * VM参数：-XX:+UseG1GC -Xms1g -Xmx1g -XX:MaxGCPauseMillis=200 -XX:+PrintGCDetails
 */
public class G1GCDemo {
    
    private static final int _1MB = 1024 * 1024;
    
    public static void main(String[] args) throws InterruptedException {
        List<byte[]> list = new ArrayList<>();
        
        // 持续分配对象
        for (int i = 0; i < 1000; i++) {
            list.add(new byte[_1MB]);
            Thread.sleep(5);
            
            if (i % 100 == 0) {
                System.out.println("已分配: " + (i + 1) + "MB");
            }
            
            // 定期清理，避免内存溢出
            if (i % 200 == 0 && i > 0) {
                list.clear();
            }
        }
    }
}

// 输出示例：
// [GC pause (G1 Evacuation Pause) (young), 0.0012345 secs]
// [GC pause (G1 Evacuation Pause) (mixed), 0.0023456 secs]
```

### 8.7 G1的优势

```
1. 可预测的停顿时间
   - 设置停顿时间目标
   - G1会尽力达到目标

2. 不产生内存碎片
   - 使用复制算法
   - 整理内存

3. 适合大堆内存
   - 支持几十GB的堆
   - 停顿时间仍然可控

4. 并发执行
   - 大部分工作与应用并发
   - 减少停顿时间
```

---

## 九、ZGC收集器

### 9.1 概述

ZGC是JDK 11引入的超低延迟垃圾收集器，目标是停顿时间不超过10ms。

```
设计目标：
- 停顿时间 < 10ms
- 支持TB级堆内存
- 吞吐量下降 < 15%
```

### 9.2 特点

| 特点 | 说明 |
|------|------|
| **停顿时间** | < 10ms |
| **堆大小** | 支持TB级 |
| **算法** | 标记-复制 |
| **并发** | 几乎全程并发 |
| **适用场景** | 超大堆、超低延迟 |

### 9.3 使用方式

```bash
# 启用ZGC（JDK 11+）
java -XX:+UseZGC -jar app.jar

# 设置堆大小
java -XX:+UseZGC -Xms16g -Xmx16g -jar app.jar

# 参数说明：
# -XX:+UseZGC  启用ZGC
# -XX:ConcGCThreads  并发GC线程数
# -XX:ZCollectionInterval  GC间隔（秒）
```

### 9.4 关键技术

```
1. 染色指针（Colored Pointers）
   - 在指针中存储元数据
   - 标记、重定位信息

2. 读屏障（Load Barrier）
   - 对象访问时检查指针
   - 自动完成重定位

3. 并发重定位
   - 移动对象与应用并发
   - 不需要STW
```

---

## 十、收集器选择指南

### 10.1 选择依据

```
1. 应用类型
   - 客户端应用：Serial
   - 服务端应用：G1、ZGC
   - 批处理：Parallel

2. 堆大小
   - < 4GB：Parallel、CMS
   - 4-32GB：G1
   - > 32GB：ZGC

3. 延迟要求
   - 高吞吐量：Parallel
   - 低延迟：CMS、G1、ZGC
   - 平衡：G1

4. CPU核数
   - 单核：Serial
   - 多核：Parallel、G1、ZGC
```

### 10.2 推荐配置

```
小型应用（< 2GB堆）：
java -XX:+UseSerialGC -Xms512m -Xmx512m

中型应用（2-8GB堆）：
java -XX:+UseG1GC -Xms4g -Xmx4g -XX:MaxGCPauseMillis=200

大型应用（> 8GB堆）：
java -XX:+UseG1GC -Xms16g -Xmx16g -XX:MaxGCPauseMillis=100

超大型应用（> 32GB堆）：
java -XX:+UseZGC -Xms64g -Xmx64g
```

### 10.3 对比表

| 收集器 | 停顿时间 | 吞吐量 | 内存占用 | 适用堆大小 | JDK版本 |
|-------|---------|--------|---------|-----------|---------|
| **Serial** | 长 | 高 | 低 | < 100MB | 所有 |
| **Parallel** | 长 | 最高 | 中 | < 8GB | 所有 |
| **CMS** | 短 | 中 | 高 | < 8GB | 8-14 |
| **G1** | 可控 | 高 | 高 | 4-64GB | 7+ |
| **ZGC** | 极短 | 中 | 高 | > 32GB | 11+ |

---

## 十一、总结

### 11.1 核心要点

```
1. 没有最好的收集器，只有最合适的
2. 根据应用特点选择收集器
3. 合理设置GC参数
4. 持续监控和调优
```

### 11.2 发展趋势

```
过去：Serial → Parallel
现在：G1
未来：ZGC、Shenandoah

趋势：
- 更低的延迟
- 更大的堆支持
- 更少的配置
- 更智能的调优
```

---

## 📚 参考资料

1. **《深入理解Java虚拟机（第3版）》** - 周志明
2. **Oracle GC调优指南** - https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/
3. **ZGC官方文档** - https://wiki.openjdk.java.net/display/zgc

---

**下一篇**：[GC调优实战](./04_GC调优实战.md)
