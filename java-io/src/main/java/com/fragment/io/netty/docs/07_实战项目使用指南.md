# 07_实战项目使用指南

> **核心问题**：如何使用Netty构建实际项目？有哪些最佳实践？如何避免常见陷阱？

---

## 一、项目概览

本章提供了4个完整的实战项目，涵盖Netty的主要应用场景：

| 项目 | 难度 | 核心技术 | 应用场景 |
|------|------|---------|---------|
| **简单RPC框架** | ⭐⭐⭐ | 自定义协议、序列化、动态代理 | 分布式服务调用 |
| **WebSocket聊天室** | ⭐⭐⭐ | WebSocket、广播、群组管理 | 实时通信 |
| **HTTP文件服务器** | ⭐⭐ | HTTP协议、文件传输、零拷贝 | 文件下载服务 |
| **TCP长连接推送** | ⭐⭐⭐⭐ | 心跳检测、消息推送、连接管理 | 消息推送系统 |

---

## 二、项目1：简单RPC框架

### 2.1 项目介绍

**功能**：
- 支持远程方法调用
- 自定义RPC协议
- 支持多种序列化方式
- 支持同步和异步调用

**架构设计**：
```
RPC框架架构：
┌─────────────────────────────────────────────────────────┐
│                      客户端                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 动态代理      │→ │ 请求编码      │→ │ Netty客户端  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↓ 网络传输 ↑
┌─────────────────────────────────────────────────────────┐
│                      服务端                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ Netty服务端   │→ │ 请求解码      │→ │ 方法调用      │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 2.2 协议设计

**RPC协议格式**：
```
┌──────┬─────┬──────┬────────┬──────┬─────────┐
│ 魔数 │版本 │ 类型 │ 请求ID │ 长度 │  数据    │
│ 2字节│1字节│1字节 │ 8字节  │4字节 │ N字节   │
└──────┴─────┴──────┴────────┴──────┴─────────┘

魔数：0xCAFE（标识RPC协议）
版本：0x01（协议版本）
类型：0x01=请求，0x02=响应
请求ID：唯一标识一次调用
长度：数据部分的长度
数据：序列化后的请求/响应对象
```

### 2.3 核心代码

**RPC请求对象**：
```java
public class RpcRequest implements Serializable {
    private String requestId;        // 请求ID
    private String interfaceName;    // 接口名
    private String methodName;       // 方法名
    private Class<?>[] parameterTypes;  // 参数类型
    private Object[] parameters;     // 参数值
    
    // getter/setter...
}
```

**RPC响应对象**：
```java
public class RpcResponse implements Serializable {
    private String requestId;        // 请求ID
    private Object result;           // 返回值
    private Throwable error;         // 异常信息
    
    // getter/setter...
}
```

**RPC编码器**：
```java
public class RpcEncoder extends MessageToByteEncoder<Object> {
    private Class<?> genericClass;
    
    public RpcEncoder(Class<?> genericClass) {
        this.genericClass = genericClass;
    }
    
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) {
        if (genericClass.isInstance(msg)) {
            // 1. 魔数
            out.writeShort(0xCAFE);
            
            // 2. 版本
            out.writeByte(0x01);
            
            // 3. 类型
            byte type = msg instanceof RpcRequest ? (byte) 0x01 : (byte) 0x02;
            out.writeByte(type);
            
            // 4. 请求ID
            String requestId = msg instanceof RpcRequest 
                ? ((RpcRequest) msg).getRequestId()
                : ((RpcResponse) msg).getRequestId();
            out.writeLong(Long.parseLong(requestId));
            
            // 5. 序列化数据
            byte[] data = SerializationUtil.serialize(msg);
            
            // 6. 长度
            out.writeInt(data.length);
            
            // 7. 数据
            out.writeBytes(data);
        }
    }
}
```

**RPC解码器**：
```java
public class RpcDecoder extends ByteToMessageDecoder {
    private Class<?> genericClass;
    
    public RpcDecoder(Class<?> genericClass) {
        this.genericClass = genericClass;
    }
    
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        if (in.readableBytes() < 16) {  // 最小长度
            return;
        }
        
        in.markReaderIndex();
        
        // 1. 魔数
        short magic = in.readShort();
        if (magic != (short) 0xCAFE) {
            in.resetReaderIndex();
            throw new RuntimeException("Invalid magic number: " + magic);
        }
        
        // 2. 版本
        byte version = in.readByte();
        
        // 3. 类型
        byte type = in.readByte();
        
        // 4. 请求ID
        long requestId = in.readLong();
        
        // 5. 长度
        int dataLength = in.readInt();
        
        if (in.readableBytes() < dataLength) {
            in.resetReaderIndex();
            return;
        }
        
        // 6. 数据
        byte[] data = new byte[dataLength];
        in.readBytes(data);
        
        // 7. 反序列化
        Object obj = SerializationUtil.deserialize(data, genericClass);
        out.add(obj);
    }
}
```

**客户端代理**：
```java
public class RpcProxy {
    private String host;
    private int port;
    
    public RpcProxy(String host, int port) {
        this.host = host;
        this.port = port;
    }
    
    @SuppressWarnings("unchecked")
    public <T> T create(Class<T> interfaceClass) {
        return (T) Proxy.newProxyInstance(
            interfaceClass.getClassLoader(),
            new Class<?>[]{interfaceClass},
            (proxy, method, args) -> {
                // 创建RPC请求
                RpcRequest request = new RpcRequest();
                request.setRequestId(UUID.randomUUID().toString());
                request.setInterfaceName(method.getDeclaringClass().getName());
                request.setMethodName(method.getName());
                request.setParameterTypes(method.getParameterTypes());
                request.setParameters(args);
                
                // 发送请求并等待响应
                RpcClient client = new RpcClient(host, port);
                RpcResponse response = client.send(request);
                
                if (response.getError() != null) {
                    throw response.getError();
                }
                
                return response.getResult();
            }
        );
    }
}
```

### 2.4 使用示例

**定义服务接口**：
```java
public interface HelloService {
    String sayHello(String name);
}
```

**实现服务**：
```java
public class HelloServiceImpl implements HelloService {
    @Override
    public String sayHello(String name) {
        return "Hello, " + name + "!";
    }
}
```

**启动服务端**：
```java
public class RpcServer {
    public static void main(String[] args) throws Exception {
        // 注册服务
        Map<String, Object> serviceMap = new HashMap<>();
        serviceMap.put(HelloService.class.getName(), new HelloServiceImpl());
        
        // 启动服务器
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            .addLast(new RpcDecoder(RpcRequest.class))
                            .addLast(new RpcEncoder(RpcResponse.class))
                            .addLast(new RpcServerHandler(serviceMap));
                    }
                });
            
            ChannelFuture future = bootstrap.bind(8080).sync();
            System.out.println("RPC服务端启动，端口：8080");
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

**客户端调用**：
```java
public class RpcClient {
    public static void main(String[] args) {
        // 创建代理
        RpcProxy proxy = new RpcProxy("localhost", 8080);
        HelloService helloService = proxy.create(HelloService.class);
        
        // 调用远程方法
        String result = helloService.sayHello("World");
        System.out.println(result);  // 输出：Hello, World!
    }
}
```

---

## 三、项目2：WebSocket聊天室

### 3.1 项目介绍

**功能**：
- 支持多人在线聊天
- 支持群组聊天
- 支持私聊
- 显示在线用户列表
- 消息广播

### 3.2 服务端实现

**WebSocket服务端**：
```java
public class WebSocketChatServer {
    public static void main(String[] args) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            // HTTP编解码
                            .addLast(new HttpServerCodec())
                            .addLast(new HttpObjectAggregator(65536))
                            // WebSocket支持
                            .addLast(new WebSocketServerProtocolHandler("/chat"))
                            // 业务处理
                            .addLast(new ChatServerHandler());
                    }
                });
            
            ChannelFuture future = bootstrap.bind(8080).sync();
            System.out.println("WebSocket聊天室启动，端口：8080");
            System.out.println("访问：http://localhost:8080/chat");
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

**聊天处理器**：
```java
public class ChatServerHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
    // 存储所有连接的Channel
    private static final ChannelGroup channels = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);
    
    // 存储用户名和Channel的映射
    private static final Map<String, Channel> userChannelMap = new ConcurrentHashMap<>();
    
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        
        // 通知所有用户有新用户加入
        channels.writeAndFlush(new TextWebSocketFrame(
            "[系统] 新用户加入：" + channel.id().asShortText()
        ));
        
        // 添加到Channel组
        channels.add(channel);
    }
    
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        
        // 通知所有用户有用户离开
        channels.writeAndFlush(new TextWebSocketFrame(
            "[系统] 用户离开：" + channel.id().asShortText()
        ));
        
        // 从映射中移除
        userChannelMap.values().remove(channel);
    }
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) {
        String text = msg.text();
        Channel channel = ctx.channel();
        
        // 解析消息
        if (text.startsWith("/name ")) {
            // 设置用户名
            String username = text.substring(6).trim();
            userChannelMap.put(username, channel);
            ctx.writeAndFlush(new TextWebSocketFrame("[系统] 用户名设置为：" + username));
        } else if (text.startsWith("/list")) {
            // 列出在线用户
            String users = String.join(", ", userChannelMap.keySet());
            ctx.writeAndFlush(new TextWebSocketFrame("[系统] 在线用户：" + users));
        } else if (text.startsWith("/to ")) {
            // 私聊
            String[] parts = text.substring(4).split(" ", 2);
            if (parts.length == 2) {
                String targetUser = parts[0];
                String message = parts[1];
                Channel targetChannel = userChannelMap.get(targetUser);
                
                if (targetChannel != null) {
                    String username = getUserName(channel);
                    targetChannel.writeAndFlush(new TextWebSocketFrame(
                        "[私聊] " + username + ": " + message
                    ));
                    ctx.writeAndFlush(new TextWebSocketFrame(
                        "[私聊] 发送给 " + targetUser + ": " + message
                    ));
                } else {
                    ctx.writeAndFlush(new TextWebSocketFrame("[系统] 用户不存在：" + targetUser));
                }
            }
        } else {
            // 群聊
            String username = getUserName(channel);
            channels.writeAndFlush(new TextWebSocketFrame(username + ": " + text));
        }
    }
    
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
    
    private String getUserName(Channel channel) {
        for (Map.Entry<String, Channel> entry : userChannelMap.entrySet()) {
            if (entry.getValue() == channel) {
                return entry.getKey();
            }
        }
        return channel.id().asShortText();
    }
}
```

### 3.3 客户端HTML

```html
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket聊天室</title>
    <meta charset="UTF-8">
    <style>
        #chat-box {
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
            overflow-y: scroll;
            padding: 10px;
        }
        #message-input {
            width: 500px;
            padding: 5px;
        }
        #send-btn {
            padding: 5px 20px;
        }
    </style>
</head>
<body>
    <h1>WebSocket聊天室</h1>
    <div id="chat-box"></div>
    <input type="text" id="message-input" placeholder="输入消息...">
    <button id="send-btn">发送</button>
    
    <script>
        const ws = new WebSocket('ws://localhost:8080/chat');
        const chatBox = document.getElementById('chat-box');
        const messageInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        
        ws.onopen = function() {
            addMessage('[系统] 连接成功');
            // 设置用户名
            const username = prompt('请输入用户名：');
            if (username) {
                ws.send('/name ' + username);
            }
        };
        
        ws.onmessage = function(event) {
            addMessage(event.data);
        };
        
        ws.onclose = function() {
            addMessage('[系统] 连接关闭');
        };
        
        ws.onerror = function(error) {
            addMessage('[系统] 错误：' + error);
        };
        
        sendBtn.onclick = function() {
            const message = messageInput.value.trim();
            if (message) {
                ws.send(message);
                messageInput.value = '';
            }
        };
        
        messageInput.onkeypress = function(event) {
            if (event.key === 'Enter') {
                sendBtn.click();
            }
        };
        
        function addMessage(message) {
            const div = document.createElement('div');
            div.textContent = message;
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }
    </script>
</body>
</html>
```

---

## 四、项目3：HTTP文件服务器

### 4.1 项目介绍

**功能**：
- 支持文件浏览
- 支持文件下载
- 支持断点续传
- 使用零拷贝优化

### 4.2 核心实现

**HTTP文件服务器**：
```java
public class HttpFileServer {
    private static final String FILE_ROOT = "/path/to/files";
    
    public static void main(String[] args) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            .addLast(new HttpServerCodec())
                            .addLast(new HttpObjectAggregator(65536))
                            .addLast(new ChunkedWriteHandler())
                            .addLast(new HttpFileServerHandler(FILE_ROOT));
                    }
                });
            
            ChannelFuture future = bootstrap.bind(8080).sync();
            System.out.println("HTTP文件服务器启动，端口：8080");
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

**文件处理器**：
```java
public class HttpFileServerHandler extends SimpleChannelInboundHandler<FullHttpRequest> {
    private final String fileRoot;
    
    public HttpFileServerHandler(String fileRoot) {
        this.fileRoot = fileRoot;
    }
    
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, FullHttpRequest request) {
        // 检查请求方法
        if (request.method() != HttpMethod.GET) {
            sendError(ctx, HttpResponseStatus.METHOD_NOT_ALLOWED);
            return;
        }
        
        // 获取请求路径
        String uri = request.uri();
        String path = sanitizeUri(uri);
        
        if (path == null) {
            sendError(ctx, HttpResponseStatus.FORBIDDEN);
            return;
        }
        
        File file = new File(path);
        
        // 检查文件是否存在
        if (!file.exists()) {
            sendError(ctx, HttpResponseStatus.NOT_FOUND);
            return;
        }
        
        // 如果是目录，列出文件
        if (file.isDirectory()) {
            sendListing(ctx, file);
            return;
        }
        
        // 如果不是普通文件
        if (!file.isFile()) {
            sendError(ctx, HttpResponseStatus.FORBIDDEN);
            return;
        }
        
        // 发送文件
        sendFile(ctx, file, request);
    }
    
    private void sendFile(ChannelHandlerContext ctx, File file, FullHttpRequest request) 
            throws IOException {
        RandomAccessFile raf = new RandomAccessFile(file, "r");
        long fileLength = raf.length();
        
        // 创建响应
        HttpResponse response = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK);
        HttpUtil.setContentLength(response, fileLength);
        setContentTypeHeader(response, file);
        
        // 支持断点续传
        String rangeHeader = request.headers().get(HttpHeaderNames.RANGE);
        if (rangeHeader != null) {
            // 解析Range头
            // Range: bytes=0-1023
            // 实现略...
        }
        
        ctx.write(response);
        
        // 使用零拷贝发送文件
        ctx.write(new DefaultFileRegion(raf.getChannel(), 0, fileLength));
        
        // 发送结束标记
        ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);
        future.addListener(ChannelFutureListener.CLOSE);
    }
    
    private void sendListing(ChannelHandlerContext ctx, File dir) {
        FullHttpResponse response = new DefaultFullHttpResponse(
            HttpVersion.HTTP_1_1, HttpResponseStatus.OK
        );
        response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8");
        
        StringBuilder buf = new StringBuilder();
        buf.append("<!DOCTYPE html>\r\n");
        buf.append("<html><head><title>文件列表</title></head><body>\r\n");
        buf.append("<h1>文件列表</h1>\r\n");
        buf.append("<ul>\r\n");
        
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                String name = file.getName();
                buf.append("<li><a href=\"")
                    .append(name)
                    .append("\">")
                    .append(name)
                    .append("</a></li>\r\n");
            }
        }
        
        buf.append("</ul></body></html>\r\n");
        
        ByteBuf buffer = Unpooled.copiedBuffer(buf, CharsetUtil.UTF_8);
        response.content().writeBytes(buffer);
        buffer.release();
        
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }
    
    private String sanitizeUri(String uri) {
        try {
            uri = URLDecoder.decode(uri, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
        
        // 安全检查：防止目录遍历攻击
        if (uri.contains("..") || uri.contains("./") || uri.contains("/.")) {
            return null;
        }
        
        return fileRoot + File.separator + uri;
    }
    
    private void sendError(ChannelHandlerContext ctx, HttpResponseStatus status) {
        FullHttpResponse response = new DefaultFullHttpResponse(
            HttpVersion.HTTP_1_1, status,
            Unpooled.copiedBuffer("Failure: " + status + "\r\n", CharsetUtil.UTF_8)
        );
        response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain; charset=UTF-8");
        
        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);
    }
    
    private void setContentTypeHeader(HttpResponse response, File file) {
        String fileName = file.getName();
        if (fileName.endsWith(".html") || fileName.endsWith(".htm")) {
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/html; charset=UTF-8");
        } else if (fileName.endsWith(".txt")) {
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain; charset=UTF-8");
        } else if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg")) {
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "image/jpeg");
        } else if (fileName.endsWith(".png")) {
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "image/png");
        } else {
            response.headers().set(HttpHeaderNames.CONTENT_TYPE, "application/octet-stream");
        }
    }
}
```

---

## 五、最佳实践总结

### 5.1 性能优化

**1. 使用池化ByteBuf**
```java
bootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
```

**2. 使用DirectByteBuf进行I/O**
```java
ByteBuf buffer = ctx.alloc().directBuffer(1024);
```

**3. 合理配置线程数**
```java
// I/O密集型
int threads = Runtime.getRuntime().availableProcessors() * 2;
EventLoopGroup workerGroup = new NioEventLoopGroup(threads);
```

**4. 使用零拷贝**
```java
// CompositeByteBuf
CompositeByteBuf composite = Unpooled.compositeBuffer();
composite.addComponents(true, header, body);

// FileRegion
FileRegion region = new DefaultFileRegion(fileChannel, 0, fileChannel.size());
ctx.writeAndFlush(region);
```

### 5.2 资源管理

**1. 正确释放ByteBuf**
```java
ByteBuf buf = ctx.alloc().buffer();
try {
    // 使用buf
} finally {
    buf.release();
}
```

**2. 优雅关闭**
```java
workerGroup.shutdownGracefully(0, 15, TimeUnit.SECONDS);
```

**3. 启用内存泄漏检测**
```java
-Dio.netty.leakDetection.level=ADVANCED
```

### 5.3 异常处理

**1. 统一异常处理**
```java
pipeline.addLast(new ExceptionHandler());

public class ExceptionHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        if (cause instanceof IOException) {
            // 网络异常
        } else {
            // 其他异常
            cause.printStackTrace();
        }
        ctx.close();
    }
}
```

### 5.4 安全性

**1. 限制连接数**
```java
pipeline.addLast(new ConnectionLimitHandler(1000));
```

**2. IP过滤**
```java
pipeline.addLast(new IpFilterHandler());
```

**3. SSL/TLS加密**
```java
SslContext sslContext = SslContextBuilder.forServer(cert, key).build();
pipeline.addLast(sslContext.newHandler(ch.alloc()));
```

---

## 六、常见问题

### Q1：如何处理粘包拆包？

**答**：使用合适的解码器
```java
// 固定长度
pipeline.addLast(new FixedLengthFrameDecoder(100));

// 分隔符
pipeline.addLast(new LineBasedFrameDecoder(1024));

// 长度字段
pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
```

### Q2：如何实现心跳检测？

**答**：使用IdleStateHandler
```java
// 客户端：30秒写空闲发送心跳
pipeline.addLast(new IdleStateHandler(0, 30, 0));
pipeline.addLast(new HeartbeatHandler());

// 服务端：60秒读空闲关闭连接
pipeline.addLast(new IdleStateHandler(60, 0, 0));
pipeline.addLast(new TimeoutHandler());
```

### Q3：如何避免内存泄漏？

**答**：
1. 使用try-finally释放ByteBuf
2. 使用SimpleChannelInboundHandler自动释放
3. 启用内存泄漏检测
4. 遵循"谁最后使用，谁释放"原则

### Q4：如何提高性能？

**答**：
1. 使用池化ByteBuf
2. 使用DirectByteBuf
3. 合理配置线程数
4. 使用零拷贝
5. 批量flush

---

## 七、项目运行指南

### 7.1 环境要求

- JDK 1.8+
- Maven 3.x
- Netty 4.1.x

### 7.2 添加依赖

```xml
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.68.Final</version>
</dependency>
```

### 7.3 运行项目

**1. 编译项目**
```bash
mvn clean compile
```

**2. 运行RPC示例**
```bash
# 启动服务端
java -cp target/classes com.fragment.io.netty.project.rpc.RpcServer

# 启动客户端
java -cp target/classes com.fragment.io.netty.project.rpc.RpcClient
```

**3. 运行WebSocket聊天室**
```bash
# 启动服务端
java -cp target/classes com.fragment.io.netty.project.websocket.WebSocketChatServer

# 浏览器访问
http://localhost:8080/chat.html
```

**4. 运行HTTP文件服务器**
```bash
# 启动服务器
java -cp target/classes com.fragment.io.netty.project.http.HttpFileServer

# 浏览器访问
http://localhost:8080/
```

---

## 八、总结

通过这些实战项目，你应该掌握了：

1. **RPC框架**：自定义协议、序列化、动态代理
2. **WebSocket**：实时通信、广播、群组管理
3. **HTTP服务器**：文件传输、零拷贝
4. **最佳实践**：性能优化、资源管理、异常处理、安全性

**下一步**：
- 阅读Netty源码，深入理解原理
- 优化项目代码，提高性能
- 扩展项目功能，增加新特性

---

**项目代码**：所有项目的完整代码都在`project`目录下，可以直接运行学习。
