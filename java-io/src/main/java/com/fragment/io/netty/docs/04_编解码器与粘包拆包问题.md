# 04_编解码器与粘包拆包问题

> **核心问题**：什么是粘包拆包？为什么会出现？Netty如何解决？如何自定义编解码器？

---

## 一、粘包拆包问题深度剖析

### 1.1 什么是粘包拆包？

**粘包（Packet Sticking）**：多个消息粘在一起，作为一个包接收

**拆包（Packet Splitting）**：一个消息被拆分成多个包接收

**示例场景**：
```
客户端发送：
  消息1: "Hello"  (5字节)
  消息2: "World"  (5字节)
  消息3: "Netty"  (5字节)

服务端可能接收到：
  情况1（正常）: "Hello" | "World" | "Netty"
  情况2（粘包）: "HelloWorld" | "Netty"
  情况3（粘包）: "HelloWorldNetty"
  情况4（拆包）: "Hel" | "lo" | "World" | "Netty"
  情况5（混合）: "HelloWor" | "ldNet" | "ty"
```

### 1.2 为什么会出现粘包拆包？

#### 1.2.1 TCP是流式协议

**根本原因**：TCP是面向流的协议，没有消息边界

```
TCP传输模型：
┌─────────────────────────────────────────────────────┐
│              TCP发送缓冲区                           │
│  [Hello][World][Netty]                              │
│   ↓                                                 │
│  TCP流：HelloWorldNetty（没有边界）                  │
│   ↓                                                 │
│              TCP接收缓冲区                           │
│  可能是：[HelloWor][ldNetty]                         │
└─────────────────────────────────────────────────────┘
```

**对比UDP**：
```java
// UDP是面向消息的，有消息边界
DatagramPacket packet1 = new DatagramPacket("Hello".getBytes(), 5);
DatagramPacket packet2 = new DatagramPacket("World".getBytes(), 5);
// 接收端一定能区分这是两个独立的消息

// TCP是面向流的，没有消息边界
socket.getOutputStream().write("Hello".getBytes());
socket.getOutputStream().write("World".getBytes());
// 接收端可能收到"HelloWorld"，无法区分边界
```

#### 1.2.2 Nagle算法（导致粘包）

**Nagle算法的目的**：减少小包的网络传输，提高网络利用率

**工作原理**：
```
不使用Nagle算法：
  发送: "H" "e" "l" "l" "o"
  网络: [H][e][l][l][o]  (5个TCP包，每个1字节数据+40字节头)
  效率: 5 / (5 + 200) = 2.4%

使用Nagle算法：
  发送: "H" "e" "l" "l" "o"
  缓冲: 等待200ms或缓冲区满
  网络: [Hello]  (1个TCP包，5字节数据+40字节头)
  效率: 5 / (5 + 40) = 11.1%
```

**导致粘包**：
```java
// 连续发送多条消息
channel.write("Hello");
channel.write("World");
channel.flush();

// Nagle算法可能将它们合并成一个TCP包
// 接收端收到："HelloWorld"（粘包）
```

**如何禁用Nagle算法**：
```java
// 方式1：通过ChannelOption
bootstrap.childOption(ChannelOption.TCP_NODELAY, true);

// 方式2：通过Socket
socket.setTcpNoDelay(true);
```

#### 1.2.3 MSS/MTU限制（导致拆包）

**MSS（Maximum Segment Size）**：TCP最大报文段大小，通常是1460字节

**MTU（Maximum Transmission Unit）**：最大传输单元，通常是1500字节

```
数据包结构：
┌────────────────────────────────────────────┐
│  以太网头  │  IP头  │  TCP头  │   数据    │
│  (14字节)  │(20字节)│(20字节) │ (1460字节)│
└────────────────────────────────────────────┘
    MTU = 1500字节
         MSS = 1460字节
```

**导致拆包**：
```java
// 发送2000字节的数据
byte[] data = new byte[2000];
channel.writeAndFlush(Unpooled.wrappedBuffer(data));

// TCP会拆分成两个包：
// 包1: 1460字节
// 包2: 540字节

// 接收端可能分两次接收（拆包）
```

#### 1.2.4 接收缓冲区大小（导致拆包）

**接收缓冲区满**：
```java
// 发送端发送10KB数据
byte[] data = new byte[10 * 1024];
channel.writeAndFlush(Unpooled.wrappedBuffer(data));

// 接收端缓冲区只有4KB
ByteBuffer buffer = ByteBuffer.allocate(4 * 1024);

// 第一次read：读取4KB
int read1 = channel.read(buffer);  // 4096字节

// 第二次read：读取4KB
int read2 = channel.read(buffer);  // 4096字节

// 第三次read：读取剩余2KB
int read3 = channel.read(buffer);  // 2048字节

// 数据被拆分成3次接收（拆包）
```

### 1.3 粘包拆包的危害

#### 1.3.1 数据错乱

```java
// 发送端发送两条消息
channel.write("LOGIN:user1,pass1");
channel.write("QUERY:SELECT * FROM users");

// 接收端可能收到（粘包）
String received = "LOGIN:user1,pass1QUERY:SELECT * FROM users";
// 无法正确解析，导致数据错乱
```

#### 1.3.2 业务逻辑错误

```java
// 发送端发送订单数据
Order order1 = new Order(1, "商品A", 100);
Order order2 = new Order(2, "商品B", 200);
channel.write(serialize(order1));
channel.write(serialize(order2));

// 接收端可能收到（粘包）
byte[] received = readBytes();  // order1和order2的数据混在一起
Order order = deserialize(received);  // 反序列化失败
```

#### 1.3.3 安全问题

```java
// 攻击者发送恶意数据
channel.write("NORMAL_DATA");
channel.write("MALICIOUS_CODE");

// 如果粘包，可能绕过安全检查
String received = "NORMAL_DATAMALICIOUS_CODE";
// 安全检查只检查了"NORMAL_DATA"部分
```

---

## 二、解决粘包拆包的方案

### 2.1 解决方案概览

| 方案 | 原理 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|---------|
| **固定长度** | 每条消息固定N字节 | 简单 | 浪费空间 | 消息长度固定 |
| **分隔符** | 用特殊字符分隔消息 | 简单、节省空间 | 需要转义 | 文本协议 |
| **长度字段** | 消息头包含长度信息 | 灵活、高效 | 稍复杂 | 二进制协议 |
| **自定义协议** | 完整的协议设计 | 功能强大 | 复杂 | 复杂业务 |

### 2.2 方案1：固定长度

**原理**：每条消息固定N字节，不足补空格或0

```
消息格式：
┌──────────────────────────────────┐
│        固定长度（如100字节）       │
│  "Hello" + 95个空格               │
└──────────────────────────────────┘
```

**实现**：
```java
// 发送端：固定长度编码
public class FixedLengthEncoder extends MessageToByteEncoder<String> {
    private int length;
    
    public FixedLengthEncoder(int length) {
        this.length = length;
    }
    
    @Override
    protected void encode(ChannelHandlerContext ctx, String msg, ByteBuf out) {
        // 截断或补齐到固定长度
        if (msg.length() > length) {
            msg = msg.substring(0, length);
        } else if (msg.length() < length) {
            msg = String.format("%-" + length + "s", msg);  // 右补空格
        }
        out.writeBytes(msg.getBytes(CharsetUtil.UTF_8));
    }
}

// 接收端：固定长度解码
pipeline.addLast(new FixedLengthFrameDecoder(100));  // 每100字节一条消息
pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
pipeline.addLast(new BusinessHandler());
```

**优缺点**：
- ✅ 实现简单
- ✅ 解析高效
- ❌ 浪费空间（短消息也占用固定空间）
- ❌ 不灵活（无法处理超长消息）

**适用场景**：
- 消息长度固定或变化不大
- 对空间要求不高
- 如：固定格式的报文

### 2.3 方案2：分隔符

**原理**：用特殊字符（如\n、\r\n、$）分隔消息

```
消息格式：
┌──────────────────────────────────┐
│  "Hello\n"                       │
│  "World\n"                       │
│  "Netty\n"                       │
└──────────────────────────────────┘
```

**实现**：
```java
// 接收端：行分隔符解码
pipeline.addLast(new LineBasedFrameDecoder(1024));  // 最大1024字节
pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
pipeline.addLast(new BusinessHandler());

// 发送端：添加换行符
channel.writeAndFlush("Hello\n");
channel.writeAndFlush("World\n");

// 自定义分隔符
ByteBuf delimiter = Unpooled.copiedBuffer("$_$".getBytes());
pipeline.addLast(new DelimiterBasedFrameDecoder(1024, delimiter));
```

**Netty内置的分隔符解码器**：
```java
// 1. LineBasedFrameDecoder：以\n或\r\n分隔
pipeline.addLast(new LineBasedFrameDecoder(1024));

// 2. DelimiterBasedFrameDecoder：自定义分隔符
ByteBuf[] delimiters = new ByteBuf[] {
    Unpooled.copiedBuffer("\n".getBytes()),
    Unpooled.copiedBuffer("$_$".getBytes())
};
pipeline.addLast(new DelimiterBasedFrameDecoder(1024, delimiters));
```

**优缺点**：
- ✅ 实现简单
- ✅ 节省空间
- ✅ 适合文本协议
- ❌ 需要转义（消息中不能包含分隔符）
- ❌ 需要扫描整个消息查找分隔符

**适用场景**：
- 文本协议（HTTP、Redis、Memcached）
- 消息中不包含分隔符
- 如：聊天消息、日志传输

### 2.4 方案3：长度字段（推荐）

**原理**：消息头包含消息体的长度

```
消息格式：
┌────────────┬──────────────────────┐
│  长度(4字节)│      消息体          │
│    5       │     "Hello"          │
└────────────┴──────────────────────┘
```

**实现**：
```java
// 接收端：长度字段解码
pipeline.addLast(new LengthFieldBasedFrameDecoder(
    1024,        // maxFrameLength: 最大帧长度
    0,           // lengthFieldOffset: 长度字段偏移量
    4,           // lengthFieldLength: 长度字段长度
    0,           // lengthAdjustment: 长度调整值
    4            // initialBytesToStrip: 跳过的字节数
));
pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));
pipeline.addLast(new BusinessHandler());

// 发送端：添加长度字段
pipeline.addLast(new LengthFieldPrepender(4));  // 添加4字节长度字段
pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));
```

**LengthFieldBasedFrameDecoder参数详解**：

```java
/**
 * @param maxFrameLength      最大帧长度，超过则抛出TooLongFrameException
 * @param lengthFieldOffset   长度字段的偏移量（从第几个字节开始是长度字段）
 * @param lengthFieldLength   长度字段的长度（1、2、4、8字节）
 * @param lengthAdjustment    长度调整值（长度字段的值+调整值=实际长度）
 * @param initialBytesToStrip 跳过的字节数（解码后跳过前N个字节）
 */
```

**参数示例**：

**示例1：标准格式**
```
消息格式：
┌────────┬──────────┐
│ Length │   Body   │
│ 0x000C │ "Hello"  │
└────────┴──────────┘

配置：
new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4)
                                       ↑  ↑  ↑  ↑  ↑
                                       │  │  │  │  └─ 跳过4字节（长度字段）
                                       │  │  │  └──── 不调整
                                       │  │  └─────── 长度字段4字节
                                       │  └────────── 从第0字节开始
                                       └───────────── 最大1024字节

解码结果：
ByteBuf("Hello")  // 长度字段被跳过
```

**示例2：带消息头**
```
消息格式：
┌────────┬────────┬──────────┐
│ Header │ Length │   Body   │
│ 0x02   │ 0x000C │ "Hello"  │
└────────┴────────┴──────────┘

配置：
new LengthFieldBasedFrameDecoder(1024, 2, 4, 0, 0)
                                       ↑  ↑  ↑  ↑
                                       │  │  │  └─ 不跳过
                                       │  │  └──── 不调整
                                       │  └─────── 长度字段4字节
                                       └────────── 从第2字节开始

解码结果：
ByteBuf(0x02, 0x000C, "Hello")  // 包含完整消息
```

**示例3：长度包含消息头**
```
消息格式：
┌────────┬──────────┐
│ Length │   Body   │
│ 0x000E │ "Hello"  │  (长度=2+12=14)
└────────┴──────────┘

配置：
new LengthFieldBasedFrameDecoder(1024, 0, 2, -2, 0)
                                       ↑  ↑  ↑   ↑
                                       │  │  │   └─ 不跳过
                                       │  │  └───── 调整-2（长度包含了自己）
                                       │  └──────── 长度字段2字节
                                       └─────────── 从第0字节开始

解码结果：
ByteBuf(0x000E, "Hello")
```

**优缺点**：
- ✅ 灵活高效
- ✅ 不需要扫描消息
- ✅ 支持任意长度消息
- ✅ 不需要转义
- ❌ 稍微复杂

**适用场景**：
- 二进制协议
- 高性能要求
- 如：RPC框架、消息队列

### 2.5 方案4：自定义协议

**完整的协议设计**：
```
自定义协议格式：
┌──────┬─────┬──────┬────────┬──────┬─────────┬─────────┐
│ 魔数 │版本 │ 类型 │ 序列号 │ 长度 │  消息体  │  校验和  │
│ 2字节│1字节│1字节 │ 4字节  │4字节 │ N字节   │ 4字节   │
└──────┴─────┴──────┴────────┴──────┴─────────┴─────────┘

示例：
0xCAFE | 0x01 | 0x01 | 0x00000001 | 0x0000000C | "Hello" | 0x12345678
```

**实现**：
```java
// 协议消息
public class ProtocolMessage {
    private static final short MAGIC_NUMBER = (short) 0xCAFE;
    
    private byte version;        // 版本号
    private byte type;           // 消息类型
    private int sequenceId;      // 序列号
    private int length;          // 消息体长度
    private byte[] body;         // 消息体
    private int checksum;        // 校验和
    
    // getter/setter...
}

// 编码器
public class ProtocolEncoder extends MessageToByteEncoder<ProtocolMessage> {
    @Override
    protected void encode(ChannelHandlerContext ctx, ProtocolMessage msg, ByteBuf out) {
        // 1. 魔数
        out.writeShort(ProtocolMessage.MAGIC_NUMBER);
        
        // 2. 版本
        out.writeByte(msg.getVersion());
        
        // 3. 类型
        out.writeByte(msg.getType());
        
        // 4. 序列号
        out.writeInt(msg.getSequenceId());
        
        // 5. 长度
        out.writeInt(msg.getBody().length);
        
        // 6. 消息体
        out.writeBytes(msg.getBody());
        
        // 7. 校验和
        int checksum = calculateChecksum(msg.getBody());
        out.writeInt(checksum);
    }
    
    private int calculateChecksum(byte[] data) {
        // CRC32校验
        CRC32 crc32 = new CRC32();
        crc32.update(data);
        return (int) crc32.getValue();
    }
}

// 解码器
public class ProtocolDecoder extends ByteToMessageDecoder {
    private static final int HEADER_LENGTH = 16;  // 魔数+版本+类型+序列号+长度
    
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        // 1. 检查是否有足够的数据读取消息头
        if (in.readableBytes() < HEADER_LENGTH) {
            return;  // 等待更多数据
        }
        
        // 标记读指针位置
        in.markReaderIndex();
        
        // 2. 读取魔数
        short magicNumber = in.readShort();
        if (magicNumber != ProtocolMessage.MAGIC_NUMBER) {
            throw new IllegalStateException("Invalid magic number: " + magicNumber);
        }
        
        // 3. 读取版本
        byte version = in.readByte();
        
        // 4. 读取类型
        byte type = in.readByte();
        
        // 5. 读取序列号
        int sequenceId = in.readInt();
        
        // 6. 读取长度
        int length = in.readInt();
        
        // 7. 检查是否有足够的数据读取消息体和校验和
        if (in.readableBytes() < length + 4) {
            in.resetReaderIndex();  // 重置读指针
            return;  // 等待更多数据
        }
        
        // 8. 读取消息体
        byte[] body = new byte[length];
        in.readBytes(body);
        
        // 9. 读取校验和
        int checksum = in.readInt();
        
        // 10. 校验
        int calculatedChecksum = calculateChecksum(body);
        if (checksum != calculatedChecksum) {
            throw new IllegalStateException("Checksum mismatch");
        }
        
        // 11. 构造消息对象
        ProtocolMessage message = new ProtocolMessage();
        message.setVersion(version);
        message.setType(type);
        message.setSequenceId(sequenceId);
        message.setLength(length);
        message.setBody(body);
        message.setChecksum(checksum);
        
        out.add(message);
    }
    
    private int calculateChecksum(byte[] data) {
        CRC32 crc32 = new CRC32();
        crc32.update(data);
        return (int) crc32.getValue();
    }
}
```

**协议设计要点**：

1. **魔数（Magic Number）**：
   - 快速识别协议
   - 防止错误连接
   - 通常2-4字节

2. **版本号**：
   - 支持协议升级
   - 向后兼容

3. **消息类型**：
   - 区分不同的消息
   - 如：请求、响应、心跳

4. **序列号**：
   - 请求响应匹配
   - 消息去重

5. **长度字段**：
   - 解决粘包拆包
   - 预分配缓冲区

6. **校验和**：
   - 检测数据损坏
   - 常用算法：CRC32、MD5

---

## 三、Netty内置编解码器

### 3.1 基础编解码器

#### 3.1.1 字符串编解码器

```java
// StringDecoder：将ByteBuf解码为String
pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8));

// StringEncoder：将String编码为ByteBuf
pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8));

// 使用示例
public class StringHandler extends SimpleChannelInboundHandler<String> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, String msg) {
        System.out.println("接收到: " + msg);
        ctx.writeAndFlush("Echo: " + msg);  // 自动编码为ByteBuf
    }
}
```

#### 3.1.2 对象编解码器

```java
// ObjectDecoder：将ByteBuf解码为Java对象
pipeline.addLast(new ObjectDecoder(ClassResolvers.cacheDisabled(null)));

// ObjectEncoder：将Java对象编码为ByteBuf
pipeline.addLast(new ObjectEncoder());

// 注意：对象必须实现Serializable接口
public class User implements Serializable {
    private String name;
    private int age;
    // ...
}
```

**不推荐使用ObjectEncoder/ObjectDecoder**：
- ❌ 性能差（Java序列化慢）
- ❌ 体积大（序列化后数据大）
- ❌ 安全问题（反序列化漏洞）
- ✅ 推荐使用：Protobuf、Hessian、Kryo

#### 3.1.3 Base64编解码器

```java
// Base64Decoder：将Base64字符串解码为字节
pipeline.addLast(new Base64Decoder());

// Base64Encoder：将字节编码为Base64字符串
pipeline.addLast(new Base64Encoder());
```

### 3.2 常用编解码器

#### 3.2.1 HTTP编解码器

```java
// HTTP服务端
pipeline.addLast(new HttpServerCodec());  // 等价于下面两行
// pipeline.addLast(new HttpRequestDecoder());
// pipeline.addLast(new HttpResponseEncoder());

pipeline.addLast(new HttpObjectAggregator(65536));  // 聚合HTTP消息
pipeline.addLast(new HttpServerHandler());

// HTTP客户端
pipeline.addLast(new HttpClientCodec());  // 等价于下面两行
// pipeline.addLast(new HttpResponseDecoder());
// pipeline.addLast(new HttpRequestEncoder());

pipeline.addLast(new HttpObjectAggregator(65536));
pipeline.addLast(new HttpClientHandler());
```

#### 3.2.2 WebSocket编解码器

```java
// WebSocket服务端
pipeline.addLast(new HttpServerCodec());
pipeline.addLast(new HttpObjectAggregator(65536));
pipeline.addLast(new WebSocketServerProtocolHandler("/ws"));  // WebSocket路径
pipeline.addLast(new WebSocketHandler());

public class WebSocketHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) {
        String text = msg.text();
        System.out.println("接收到: " + text);
        ctx.writeAndFlush(new TextWebSocketFrame("Echo: " + text));
    }
}
```

#### 3.2.3 Protobuf编解码器

```java
// 定义Protobuf消息（user.proto）
// message User {
//     required string name = 1;
//     required int32 age = 2;
// }

// 服务端
pipeline.addLast(new ProtobufVarint32FrameDecoder());  // 处理长度字段
pipeline.addLast(new ProtobufDecoder(UserProto.User.getDefaultInstance()));
pipeline.addLast(new ProtobufVarint32LengthFieldPrepender());  // 添加长度字段
pipeline.addLast(new ProtobufEncoder());
pipeline.addLast(new ProtobufHandler());

public class ProtobufHandler extends SimpleChannelInboundHandler<UserProto.User> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, UserProto.User msg) {
        System.out.println("Name: " + msg.getName());
        System.out.println("Age: " + msg.getAge());
    }
}
```

### 3.3 编解码器的组合

**标准Pipeline配置**：
```java
// 完整的Pipeline配置
pipeline.addLast("frameDecoder", new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
pipeline.addLast("decoder", new StringDecoder(CharsetUtil.UTF_8));
pipeline.addLast("frameEncoder", new LengthFieldPrepender(4));
pipeline.addLast("encoder", new StringEncoder(CharsetUtil.UTF_8));
pipeline.addLast("handler", new BusinessHandler());

// 执行流程：
// 入站：frameDecoder → decoder → handler
// 出站：handler → encoder → frameEncoder
```

---

## 四、自定义编解码器

### 4.1 ByteToMessageDecoder

**作用**：将ByteBuf解码为消息对象

**核心方法**：
```java
public abstract class ByteToMessageDecoder extends ChannelInboundHandlerAdapter {
    /**
     * 解码方法
     * @param ctx 上下文
     * @param in  输入的ByteBuf
     * @param out 输出的消息列表
     */
    protected abstract void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) 
        throws Exception;
}
```

**实现示例**：
```java
// 自定义协议：长度(4字节) + 类型(1字节) + 数据
public class MyDecoder extends ByteToMessageDecoder {
    private static final int HEADER_LENGTH = 5;
    
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        // 1. 检查是否有足够的数据
        if (in.readableBytes() < HEADER_LENGTH) {
            return;  // 等待更多数据
        }
        
        // 2. 标记读指针
        in.markReaderIndex();
        
        // 3. 读取长度
        int length = in.readInt();
        
        // 4. 读取类型
        byte type = in.readByte();
        
        // 5. 检查数据是否完整
        if (in.readableBytes() < length) {
            in.resetReaderIndex();  // 重置读指针
            return;  // 等待更多数据
        }
        
        // 6. 读取数据
        byte[] data = new byte[length];
        in.readBytes(data);
        
        // 7. 构造消息对象
        MyMessage message = new MyMessage(type, data);
        out.add(message);
    }
}
```

**关键点**：
- **markReaderIndex/resetReaderIndex**：处理半包时重置读指针
- **readableBytes**：检查可读字节数
- **out.add()**：将解码后的消息添加到列表

### 4.2 MessageToByteEncoder

**作用**：将消息对象编码为ByteBuf

**核心方法**：
```java
public abstract class MessageToByteEncoder<I> extends ChannelOutboundHandlerAdapter {
    /**
     * 编码方法
     * @param ctx 上下文
     * @param msg 输入的消息
     * @param out 输出的ByteBuf
     */
    protected abstract void encode(ChannelHandlerContext ctx, I msg, ByteBuf out) 
        throws Exception;
}
```

**实现示例**：
```java
// 自定义协议编码器
public class MyEncoder extends MessageToByteEncoder<MyMessage> {
    @Override
    protected void encode(ChannelHandlerContext ctx, MyMessage msg, ByteBuf out) {
        // 1. 写入长度
        out.writeInt(msg.getData().length);
        
        // 2. 写入类型
        out.writeByte(msg.getType());
        
        // 3. 写入数据
        out.writeBytes(msg.getData());
    }
}
```

### 4.3 MessageToMessageDecoder

**作用**：将一种消息类型转换为另一种消息类型

**示例**：
```java
// 将ByteBuf转换为String，再转换为JSON对象
public class JsonDecoder extends MessageToMessageDecoder<String> {
    @Override
    protected void decode(ChannelHandlerContext ctx, String msg, List<Object> out) {
        // 将JSON字符串解析为对象
        JsonObject json = new Gson().fromJson(msg, JsonObject.class);
        out.add(json);
    }
}

// Pipeline配置
pipeline.addLast(new StringDecoder());  // ByteBuf → String
pipeline.addLast(new JsonDecoder());    // String → JsonObject
```

### 4.4 MessageToMessageEncoder

**作用**：将一种消息类型转换为另一种消息类型

**示例**：
```java
// 将对象转换为JSON字符串
public class JsonEncoder extends MessageToMessageEncoder<Object> {
    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, List<Object> out) {
        // 将对象序列化为JSON字符串
        String json = new Gson().toJson(msg);
        out.add(json);
    }
}

// Pipeline配置
pipeline.addLast(new JsonEncoder());    // Object → String
pipeline.addLast(new StringEncoder());  // String → ByteBuf
```

---

## 五、编解码器最佳实践

### 5.1 性能优化

#### 5.1.1 使用DirectByteBuf

```java
// 使用直接内存，减少拷贝
ByteBuf buffer = ctx.alloc().directBuffer(1024);
```

#### 5.1.2 复用ByteBuf

```java
// 使用池化的ByteBuf
ByteBuf buffer = PooledByteBufAllocator.DEFAULT.buffer(1024);
try {
    // 使用buffer
} finally {
    buffer.release();  // 释放回池
}
```

#### 5.1.3 避免不必要的拷贝

```java
// ❌ 错误：多次拷贝
byte[] data = new byte[1024];
in.readBytes(data);
String str = new String(data);  // 拷贝1
MyObject obj = parse(str);      // 拷贝2

// ✅ 正确：直接解析
MyObject obj = parseFromByteBuf(in);  // 零拷贝
```

### 5.2 安全性

#### 5.2.1 限制消息大小

```java
// 防止OOM攻击
pipeline.addLast(new LengthFieldBasedFrameDecoder(
    1024 * 1024,  // 最大1MB
    0, 4, 0, 4
));
```

#### 5.2.2 校验数据完整性

```java
// 添加校验和
public class ChecksumEncoder extends MessageToByteEncoder<ByteBuf> {
    @Override
    protected void encode(ChannelHandlerContext ctx, ByteBuf msg, ByteBuf out) {
        // 计算校验和
        int checksum = calculateChecksum(msg);
        
        // 写入数据
        out.writeBytes(msg);
        
        // 写入校验和
        out.writeInt(checksum);
    }
}
```

### 5.3 可维护性

#### 5.3.1 分离编解码逻辑

```java
// 不要在业务Handler中编解码
// ❌ 错误
public class BadHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;
        // 手动解码
        int length = buf.readInt();
        byte[] data = new byte[length];
        buf.readBytes(data);
        // 业务处理
        process(data);
    }
}

// ✅ 正确：使用专门的编解码器
pipeline.addLast(new MyDecoder());
pipeline.addLast(new BusinessHandler());
```

#### 5.3.2 使用泛型

```java
// 使用泛型，类型安全
public class MyHandler extends SimpleChannelInboundHandler<MyMessage> {
    @Override
    protected void channelRead0(ChannelHandlerContext ctx, MyMessage msg) {
        // msg已经是MyMessage类型，不需要强制转换
        process(msg);
    }
}
```

---

## 六、核心问题总结

### Q1：什么是粘包拆包？为什么会出现？

**答**：
- **粘包**：多个消息粘在一起接收
- **拆包**：一个消息被拆分成多个包接收
- **原因**：
  1. TCP是流式协议，没有消息边界
  2. Nagle算法合并小包（粘包）
  3. MSS/MTU限制拆分大包（拆包）
  4. 接收缓冲区大小限制（拆包）

### Q2：如何解决粘包拆包？

**答**：
1. **固定长度**：简单但浪费空间
2. **分隔符**：适合文本协议
3. **长度字段**：推荐，灵活高效
4. **自定义协议**：功能强大，适合复杂场景

### Q3：LengthFieldBasedFrameDecoder的参数如何配置？

**答**：
- **maxFrameLength**：最大帧长度
- **lengthFieldOffset**：长度字段偏移量
- **lengthFieldLength**：长度字段长度（1/2/4/8字节）
- **lengthAdjustment**：长度调整值
- **initialBytesToStrip**：跳过的字节数

### Q4：如何自定义编解码器？

**答**：
1. **ByteToMessageDecoder**：ByteBuf → 消息对象
2. **MessageToByteEncoder**：消息对象 → ByteBuf
3. **MessageToMessageDecoder**：消息类型转换
4. **MessageToMessageEncoder**：消息类型转换

### Q5：编解码器有哪些最佳实践？

**答**：
1. **性能**：使用DirectByteBuf、复用ByteBuf、避免拷贝
2. **安全**：限制消息大小、校验数据完整性
3. **可维护性**：分离编解码逻辑、使用泛型

---

## 七、下一步学习

在掌握了编解码器和粘包拆包问题后，下一章我们将学习：

**第5章：ByteBuf与内存管理**
- ByteBuf的优势
- 引用计数机制
- 内存池化
- 零拷贝实现

**实践任务**：
1. 实现一个自定义协议的编解码器
2. 测试粘包拆包场景
3. 对比不同解决方案的性能

---

**继续学习**：[05_ByteBuf与内存管理](./05_ByteBuf与内存管理.md)
