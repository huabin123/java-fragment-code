# 06_高级特性

> **核心问题**：如何实现心跳检测？如何检测空闲连接？如何进行流量控制？

---

## 一、心跳检测

### 1.1 为什么需要心跳检测？

**问题场景**：
```
客户端                           服务端
   │                               │
   │────── 建立连接 ──────────────→│
   │                               │
   │←───── 正常通信 ──────────────→│
   │                               │
   X  客户端异常断电                │
   │                               │
   │                               │  服务端无法感知
   │                               │  连接已断开
   │                               │  资源无法释放
```

**心跳检测的作用**：
1. **检测死连接**：及时发现断开的连接
2. **保持连接活跃**：防止被防火墙或NAT断开
3. **及时释放资源**：清理无效连接

### 1.2 心跳检测的实现方式

#### 1.2.1 应用层心跳

**原理**：应用层定期发送心跳包

```java
// 服务端：接收心跳
public class HeartbeatServerHandler extends ChannelInboundHandlerAdapter {
    private static final ByteBuf HEARTBEAT_SEQUENCE = 
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("HEARTBEAT", CharsetUtil.UTF_8));
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;
        
        if (buf.equals(HEARTBEAT_SEQUENCE)) {
            // 收到心跳，回复心跳
            System.out.println("收到心跳: " + ctx.channel().remoteAddress());
            ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate());
        } else {
            // 业务消息
            ctx.fireChannelRead(msg);
        }
    }
}

// 客户端：发送心跳
public class HeartbeatClientHandler extends ChannelInboundHandlerAdapter {
    private static final ByteBuf HEARTBEAT_SEQUENCE = 
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("HEARTBEAT", CharsetUtil.UTF_8));
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        // 连接建立后，启动心跳定时任务
        ctx.executor().scheduleAtFixedRate(() -> {
            if (ctx.channel().isActive()) {
                System.out.println("发送心跳");
                ctx.writeAndFlush(HEARTBEAT_SEQUENCE.duplicate());
            }
        }, 0, 5, TimeUnit.SECONDS);  // 每5秒发送一次
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;
        
        if (buf.equals(HEARTBEAT_SEQUENCE)) {
            // 收到心跳响应
            System.out.println("收到心跳响应");
            ReferenceCountUtil.release(msg);
        } else {
            // 业务消息
            ctx.fireChannelRead(msg);
        }
    }
}
```

#### 1.2.2 TCP层心跳（SO_KEEPALIVE）

**原理**：使用TCP的保活机制

```java
// 启用TCP保活
bootstrap.childOption(ChannelOption.SO_KEEPALIVE, true);

// TCP保活参数（Linux）：
// - tcp_keepalive_time: 7200秒（2小时）无数据传输后开始探测
// - tcp_keepalive_intvl: 75秒，探测间隔
// - tcp_keepalive_probes: 9次，探测次数
```

**缺点**：
- ❌ 时间太长（默认2小时）
- ❌ 不够灵活
- ❌ 依赖操作系统

**推荐**：使用应用层心跳

---

## 二、空闲检测

### 2.1 IdleStateHandler

**作用**：检测Channel的空闲状态

**核心参数**：
```java
public IdleStateHandler(
    long readerIdleTime,    // 读空闲时间
    long writerIdleTime,    // 写空闲时间
    long allIdleTime,       // 读写空闲时间
    TimeUnit unit           // 时间单位
)
```

**工作原理**：
```
IdleStateHandler的工作流程：
┌─────────────────────────────────────────────────────────┐
│ 1. 读空闲检测                                            │
│    - 如果readerIdleTime秒内没有读取数据                  │
│    - 触发IdleStateEvent.READER_IDLE事件                 │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 写空闲检测                                            │
│    - 如果writerIdleTime秒内没有写入数据                  │
│    - 触发IdleStateEvent.WRITER_IDLE事件                 │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 读写空闲检测                                          │
│    - 如果allIdleTime秒内既没有读也没有写                 │
│    - 触发IdleStateEvent.ALL_IDLE事件                    │
└─────────────────────────────────────────────────────────┘
```

### 2.2 服务端空闲检测

**场景**：服务端检测客户端是否存活

```java
// Pipeline配置
pipeline.addLast(new IdleStateHandler(60, 0, 0, TimeUnit.SECONDS));
pipeline.addLast(new ServerIdleHandler());

// 空闲处理器
public class ServerIdleHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            
            if (event.state() == IdleState.READER_IDLE) {
                // 60秒没有收到客户端消息，关闭连接
                System.out.println("60秒未收到客户端消息，关闭连接: " + ctx.channel().remoteAddress());
                ctx.close();
            }
        } else {
            ctx.fireUserEventTriggered(evt);
        }
    }
}
```

### 2.3 客户端空闲检测

**场景**：客户端定期发送心跳

```java
// Pipeline配置
pipeline.addLast(new IdleStateHandler(0, 30, 0, TimeUnit.SECONDS));
pipeline.addLast(new ClientIdleHandler());

// 空闲处理器
public class ClientIdleHandler extends ChannelInboundHandlerAdapter {
    private static final ByteBuf HEARTBEAT = 
        Unpooled.unreleasableBuffer(Unpooled.copiedBuffer("PING", CharsetUtil.UTF_8));
    
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {
        if (evt instanceof IdleStateEvent) {
            IdleStateEvent event = (IdleStateEvent) evt;
            
            if (event.state() == IdleState.WRITER_IDLE) {
                // 30秒没有发送消息，发送心跳
                System.out.println("发送心跳");
                ctx.writeAndFlush(HEARTBEAT.duplicate());
            }
        } else {
            ctx.fireUserEventTriggered(evt);
        }
    }
}
```

### 2.4 完整的心跳机制

**设计思路**：
- 客户端：每30秒发送心跳
- 服务端：60秒未收到消息则关闭连接

```java
// 服务端
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
    .channel(NioServerSocketChannel.class)
    .childHandler(new ChannelInitializer<SocketChannel>() {
        @Override
        protected void initChannel(SocketChannel ch) {
            ch.pipeline()
                // 60秒读空闲检测
                .addLast(new IdleStateHandler(60, 0, 0, TimeUnit.SECONDS))
                .addLast(new ServerIdleHandler())
                .addLast(new StringDecoder(CharsetUtil.UTF_8))
                .addLast(new StringEncoder(CharsetUtil.UTF_8))
                .addLast(new ServerBusinessHandler());
        }
    });

// 客户端
Bootstrap bootstrap = new Bootstrap();
bootstrap.group(workerGroup)
    .channel(NioSocketChannel.class)
    .handler(new ChannelInitializer<SocketChannel>() {
        @Override
        protected void initChannel(SocketChannel ch) {
            ch.pipeline()
                // 30秒写空闲检测
                .addLast(new IdleStateHandler(0, 30, 0, TimeUnit.SECONDS))
                .addLast(new ClientIdleHandler())
                .addLast(new StringDecoder(CharsetUtil.UTF_8))
                .addLast(new StringEncoder(CharsetUtil.UTF_8))
                .addLast(new ClientBusinessHandler());
        }
    });
```

**时间配置建议**：
```
客户端心跳间隔 < 服务端超时时间 / 2

示例：
- 客户端心跳：30秒
- 服务端超时：60秒
- 容错：即使丢失一次心跳，也不会超时
```

---

## 三、流量整形

### 3.1 为什么需要流量整形？

**问题场景**：
```
场景1：客户端发送速度过快
客户端 ──────→ 服务端
        100MB/s
        
问题：
- 服务端处理不过来
- 内存溢出
- 服务崩溃

场景2：服务端发送速度过快
服务端 ──────→ 客户端
        100MB/s
        
问题：
- 客户端接收不过来
- 网络拥塞
- 丢包重传
```

**流量整形的作用**：
1. **限制发送速度**：防止发送过快
2. **限制接收速度**：防止接收过快
3. **保护系统**：防止过载

### 3.2 流量整形的类型

#### 3.2.1 全局流量整形

**GlobalTrafficShapingHandler**：限制所有Channel的总流量

```java
// 创建全局流量整形器
// 参数：EventExecutorGroup, 写限制(字节/秒), 读限制(字节/秒)
GlobalTrafficShapingHandler trafficHandler = 
    new GlobalTrafficShapingHandler(
        workerGroup,
        10 * 1024 * 1024,  // 写限制：10MB/s
        10 * 1024 * 1024,  // 读限制：10MB/s
        1000               // 检查间隔：1秒
    );

// 添加到Pipeline
pipeline.addLast(trafficHandler);
```

**工作原理**：
```
全局流量整形：
┌─────────────────────────────────────────┐
│     GlobalTrafficShapingHandler         │
│                                         │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐│
│  │Channel1 │  │Channel2 │  │Channel3 ││
│  │ 3MB/s   │  │ 4MB/s   │  │ 3MB/s   ││
│  └─────────┘  └─────────┘  └─────────┘│
│                                         │
│  总流量：10MB/s（限制）                  │
└─────────────────────────────────────────┘
```

#### 3.2.2 Channel流量整形

**ChannelTrafficShapingHandler**：限制单个Channel的流量

```java
// 创建Channel流量整形器
ChannelTrafficShapingHandler trafficHandler = 
    new ChannelTrafficShapingHandler(
        1 * 1024 * 1024,  // 写限制：1MB/s
        1 * 1024 * 1024,  // 读限制：1MB/s
        1000              // 检查间隔：1秒
    );

// 添加到Pipeline
pipeline.addLast(trafficHandler);
```

**工作原理**：
```
Channel流量整形：
┌─────────────────────────────────────────┐
│  ┌─────────────────────────────────┐   │
│  │ ChannelTrafficShapingHandler    │   │
│  │ Channel1: 1MB/s（限制）          │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │ ChannelTrafficShapingHandler    │   │
│  │ Channel2: 1MB/s（限制）          │   │
│  └─────────────────────────────────┘   │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │ ChannelTrafficShapingHandler    │   │
│  │ Channel3: 1MB/s（限制）          │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 3.3 流量整形的实现

**完整示例**：
```java
public class TrafficShapingServer {
    public static void main(String[] args) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            // 创建全局流量整形器
            GlobalTrafficShapingHandler globalTrafficHandler = 
                new GlobalTrafficShapingHandler(
                    workerGroup,
                    10 * 1024 * 1024,  // 全局写限制：10MB/s
                    10 * 1024 * 1024   // 全局读限制：10MB/s
                );
            
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            // 全局流量整形
                            .addLast(globalTrafficHandler)
                            // Channel流量整形
                            .addLast(new ChannelTrafficShapingHandler(
                                1 * 1024 * 1024,  // 单个Channel写限制：1MB/s
                                1 * 1024 * 1024   // 单个Channel读限制：1MB/s
                            ))
                            .addLast(new ServerHandler());
                    }
                });
            
            ChannelFuture future = bootstrap.bind(8080).sync();
            System.out.println("服务端启动，端口：8080");
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

### 3.4 流量整形的高级配置

**动态调整流量限制**：
```java
GlobalTrafficShapingHandler trafficHandler = new GlobalTrafficShapingHandler(workerGroup);

// 初始限制：10MB/s
trafficHandler.setWriteLimit(10 * 1024 * 1024);
trafficHandler.setReadLimit(10 * 1024 * 1024);

// 根据系统负载动态调整
if (systemLoad > 0.8) {
    // 高负载，降低限制
    trafficHandler.setWriteLimit(5 * 1024 * 1024);
    trafficHandler.setReadLimit(5 * 1024 * 1024);
} else {
    // 低负载，提高限制
    trafficHandler.setWriteLimit(20 * 1024 * 1024);
    trafficHandler.setReadLimit(20 * 1024 * 1024);
}
```

**获取流量统计**：
```java
// 获取统计信息
TrafficCounter counter = trafficHandler.trafficCounter();

// 当前写入速度
long currentWriteSpeed = counter.lastWriteThroughput();  // 字节/秒

// 当前读取速度
long currentReadSpeed = counter.lastReadThroughput();  // 字节/秒

// 累计写入字节数
long totalWritten = counter.cumulativeWrittenBytes();

// 累计读取字节数
long totalRead = counter.cumulativeReadBytes();

System.out.println("写入速度: " + (currentWriteSpeed / 1024) + " KB/s");
System.out.println("读取速度: " + (currentReadSpeed / 1024) + " KB/s");
```

---

## 四、写缓冲区水位控制

### 4.1 为什么需要水位控制？

**问题场景**：
```
场景：服务端向客户端发送大量数据
服务端 ──────→ 客户端
        写入速度快
        
问题：
- 写缓冲区积压
- 内存占用过高
- OOM风险
```

**水位控制的作用**：
1. **防止内存溢出**：限制写缓冲区大小
2. **流量控制**：当缓冲区满时暂停写入
3. **背压机制**：通知上游减速

### 4.2 水位控制的原理

```
写缓冲区水位：
┌─────────────────────────────────────────┐
│         写缓冲区                         │
│                                         │
│  ┌─────────────────────────────────┐   │
│  │                                 │   │
│  │                                 │   │ ← 高水位（64KB）
│  │         已缓冲数据               │   │   超过：Channel不可写
│  │                                 │   │
│  │                                 │   │ ← 低水位（32KB）
│  │                                 │   │   低于：Channel可写
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
```

### 4.3 配置水位

```java
// 配置写缓冲区水位
bootstrap.childOption(ChannelOption.WRITE_BUFFER_WATER_MARK,
    new WriteBufferWaterMark(
        32 * 1024,  // 低水位：32KB
        64 * 1024   // 高水位：64KB
    ));
```

### 4.4 检测Channel可写性

```java
public class WriteHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // 检查Channel是否可写
        if (ctx.channel().isWritable()) {
            // 可写，继续写入
            ctx.writeAndFlush(msg);
        } else {
            // 不可写，暂停写入
            System.out.println("写缓冲区已满，暂停写入");
            // 可以选择：
            // 1. 丢弃消息
            // 2. 缓存到队列
            // 3. 等待可写
        }
    }
    
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) {
        // 可写性变化
        if (ctx.channel().isWritable()) {
            System.out.println("Channel变为可写");
            // 恢复写入
        } else {
            System.out.println("Channel变为不可写");
            // 暂停写入
        }
    }
}
```

### 4.5 背压处理

**场景**：生产者-消费者模式

```java
public class ProducerHandler extends ChannelInboundHandlerAdapter {
    private final Queue<Object> pendingMessages = new ConcurrentLinkedQueue<>();
    private volatile boolean writable = true;
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        // 启动生产者线程
        new Thread(() -> {
            while (ctx.channel().isActive()) {
                if (writable) {
                    // Channel可写，发送消息
                    Object msg = produceMessage();
                    ctx.writeAndFlush(msg);
                } else {
                    // Channel不可写，缓存消息
                    Object msg = produceMessage();
                    pendingMessages.offer(msg);
                    
                    // 限制队列大小
                    if (pendingMessages.size() > 1000) {
                        System.out.println("队列已满，暂停生产");
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            break;
                        }
                    }
                }
            }
        }).start();
    }
    
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) {
        writable = ctx.channel().isWritable();
        
        if (writable) {
            // 可写，发送缓存的消息
            System.out.println("Channel可写，发送缓存消息");
            Object msg;
            while ((msg = pendingMessages.poll()) != null) {
                ctx.writeAndFlush(msg);
                
                if (!ctx.channel().isWritable()) {
                    // 再次不可写，停止发送
                    break;
                }
            }
        }
    }
    
    private Object produceMessage() {
        // 生产消息
        return "Message-" + System.currentTimeMillis();
    }
}
```

---

## 五、连接管理

### 5.1 连接数限制

**场景**：限制服务端的最大连接数

```java
public class ConnectionLimitHandler extends ChannelInboundHandlerAdapter {
    private static final AtomicInteger CONNECTION_COUNT = new AtomicInteger(0);
    private static final int MAX_CONNECTIONS = 1000;
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        int count = CONNECTION_COUNT.incrementAndGet();
        
        if (count > MAX_CONNECTIONS) {
            // 超过最大连接数，拒绝连接
            System.out.println("连接数已达上限，拒绝连接: " + ctx.channel().remoteAddress());
            ctx.writeAndFlush("服务器繁忙，请稍后再试")
                .addListener(ChannelFutureListener.CLOSE);
            CONNECTION_COUNT.decrementAndGet();
        } else {
            System.out.println("接受连接，当前连接数: " + count);
            ctx.fireChannelActive();
        }
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        int count = CONNECTION_COUNT.decrementAndGet();
        System.out.println("连接断开，当前连接数: " + count);
        ctx.fireChannelInactive();
    }
}
```

### 5.2 IP黑名单

**场景**：拒绝特定IP的连接

```java
public class IpFilterHandler extends ChannelInboundHandlerAdapter {
    private static final Set<String> BLACKLIST = new HashSet<>();
    
    static {
        BLACKLIST.add("192.168.1.100");
        BLACKLIST.add("192.168.1.101");
    }
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();
        String ip = remoteAddress.getAddress().getHostAddress();
        
        if (BLACKLIST.contains(ip)) {
            System.out.println("拒绝黑名单IP: " + ip);
            ctx.close();
        } else {
            ctx.fireChannelActive();
        }
    }
}
```

**使用Netty内置的IP过滤器**：
```java
// 创建IP过滤规则
IpFilterRule rule1 = new IpSubnetFilterRule("192.168.1.0", 24, IpFilterRuleType.REJECT);
IpFilterRule rule2 = new IpSubnetFilterRule("10.0.0.0", 8, IpFilterRuleType.ACCEPT);

// 添加到Pipeline
pipeline.addLast(new RuleBasedIpFilter(rule1, rule2));
```

### 5.3 连接超时

**场景**：限制连接建立的时间

```java
// 客户端配置连接超时
bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);  // 5秒超时
```

### 5.4 优雅关闭

**场景**：服务端关闭时，等待所有连接处理完毕

```java
public class GracefulShutdownServer {
    private final EventLoopGroup bossGroup = new NioEventLoopGroup(1);
    private final EventLoopGroup workerGroup = new NioEventLoopGroup();
    private Channel serverChannel;
    
    public void start() throws Exception {
        ServerBootstrap bootstrap = new ServerBootstrap();
        bootstrap.group(bossGroup, workerGroup)
            .channel(NioServerSocketChannel.class)
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                protected void initChannel(SocketChannel ch) {
                    ch.pipeline().addLast(new ServerHandler());
                }
            });
        
        serverChannel = bootstrap.bind(8080).sync().channel();
        System.out.println("服务端启动");
    }
    
    public void shutdown() {
        System.out.println("开始优雅关闭...");
        
        // 1. 停止接收新连接
        if (serverChannel != null) {
            serverChannel.close().awaitUninterruptibly();
        }
        
        // 2. 等待现有连接处理完毕
        workerGroup.shutdownGracefully(0, 15, TimeUnit.SECONDS);
        bossGroup.shutdownGracefully(0, 15, TimeUnit.SECONDS);
        
        System.out.println("优雅关闭完成");
    }
    
    public static void main(String[] args) throws Exception {
        GracefulShutdownServer server = new GracefulShutdownServer();
        server.start();
        
        // 注册关闭钩子
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            server.shutdown();
        }));
        
        // 等待服务端关闭
        server.serverChannel.closeFuture().sync();
    }
}
```

---

## 六、SSL/TLS支持

### 6.1 为什么需要SSL/TLS？

**安全问题**：
- **数据明文传输**：容易被窃听
- **身份伪造**：无法验证对方身份
- **数据篡改**：无法检测数据是否被修改

**SSL/TLS的作用**：
1. **加密传输**：防止窃听
2. **身份认证**：验证对方身份
3. **完整性校验**：防止篡改

### 6.2 生成自签名证书

```bash
# 生成私钥和证书
keytool -genkey -alias netty -keyalg RSA -keystore server.jks -keysize 2048 -validity 365

# 导出证书
keytool -export -alias netty -keystore server.jks -file server.cer

# 导入到客户端信任库
keytool -import -alias netty -file server.cer -keystore client.jks
```

### 6.3 服务端SSL配置

```java
public class SslServer {
    public static void main(String[] args) throws Exception {
        // 加载证书
        SelfSignedCertificate ssc = new SelfSignedCertificate();
        SslContext sslContext = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
            .build();
        
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            // 添加SSL Handler（必须是第一个）
                            .addLast(sslContext.newHandler(ch.alloc()))
                            .addLast(new StringDecoder(CharsetUtil.UTF_8))
                            .addLast(new StringEncoder(CharsetUtil.UTF_8))
                            .addLast(new ServerHandler());
                    }
                });
            
            ChannelFuture future = bootstrap.bind(8443).sync();
            System.out.println("SSL服务端启动，端口：8443");
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

### 6.4 客户端SSL配置

```java
public class SslClient {
    public static void main(String[] args) throws Exception {
        // 信任所有证书（仅用于测试）
        SslContext sslContext = SslContextBuilder.forClient()
            .trustManager(InsecureTrustManagerFactory.INSTANCE)
            .build();
        
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(workerGroup)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) {
                        ch.pipeline()
                            // 添加SSL Handler（必须是第一个）
                            .addLast(sslContext.newHandler(ch.alloc(), "localhost", 8443))
                            .addLast(new StringDecoder(CharsetUtil.UTF_8))
                            .addLast(new StringEncoder(CharsetUtil.UTF_8))
                            .addLast(new ClientHandler());
                    }
                });
            
            ChannelFuture future = bootstrap.connect("localhost", 8443).sync();
            System.out.println("SSL客户端连接成功");
            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
        }
    }
}
```

---

## 七、核心问题总结

### Q1：如何实现心跳检测？

**答**：
1. **应用层心跳**：定期发送心跳包
2. **IdleStateHandler**：检测空闲状态
3. **配置建议**：客户端心跳间隔 < 服务端超时时间 / 2

### Q2：如何检测空闲连接？

**答**：
- **IdleStateHandler**：
  - readerIdleTime：读空闲时间
  - writerIdleTime：写空闲时间
  - allIdleTime：读写空闲时间
- **触发事件**：IdleStateEvent

### Q3：如何进行流量控制？

**答**：
1. **GlobalTrafficShapingHandler**：全局流量整形
2. **ChannelTrafficShapingHandler**：单Channel流量整形
3. **WriteBufferWaterMark**：写缓冲区水位控制

### Q4：如何限制连接数？

**答**：
- 在channelActive中检查连接数
- 超过限制则关闭连接
- 使用AtomicInteger统计连接数

### Q5：如何实现SSL/TLS？

**答**：
1. 生成证书
2. 创建SslContext
3. 添加SslHandler到Pipeline（必须是第一个）

---

## 八、下一步学习

在掌握了高级特性后，下一章我们将学习：

**第7章：实战项目使用指南**
- RPC框架实现
- WebSocket聊天室
- HTTP代理服务器
- 自定义协议通信

**实践任务**：
1. 实现一个带心跳的客户端-服务端
2. 实现流量整形，限制传输速度
3. 实现SSL/TLS加密通信

---

**继续学习**：[07_实战项目使用指南](./07_实战项目使用指南.md)
