# 简单RPC框架实现

> 基于Netty实现的轻量级RPC框架，支持远程方法调用

---

## 📚 项目结构

```
rpc/
├── RpcRequest.java          # RPC请求对象
├── RpcResponse.java         # RPC响应对象
├── RpcEncoder.java          # RPC编码器
├── RpcDecoder.java          # RPC解码器
├── RpcServer.java           # RPC服务端
├── RpcClient.java           # RPC客户端
└── README.md                # 本文件
```

---

## 🎯 核心功能

### 1. 自定义RPC协议

```
协议格式：
┌──────┬─────┬──────┬────────┬──────┬─────────┐
│ 魔数 │版本 │ 类型 │ 请求ID │ 长度 │  数据    │
│ 2字节│1字节│1字节 │ 8字节  │4字节 │ N字节   │
└──────┴─────┴──────┴────────┴──────┴─────────┘

- 魔数：0xCAFE（标识RPC协议）
- 版本：0x01（协议版本）
- 类型：0x01=请求，0x02=响应
- 请求ID：唯一标识一次调用
- 长度：数据部分的长度
- 数据：序列化后的请求/响应对象
```

### 2. 动态代理

- 使用JDK动态代理
- 自动将方法调用转换为RPC请求
- 透明的远程调用体验

### 3. 异步通信

- 基于Netty的异步I/O
- 使用CountDownLatch等待响应
- 支持超时控制

---

## 🚀 快速开始

### 步骤1：定义服务接口

```java
public interface HelloService {
    String sayHello(String name);
    int add(int a, int b);
}
```

### 步骤2：实现服务

```java
public class HelloServiceImpl implements HelloService {
    @Override
    public String sayHello(String name) {
        return "Hello, " + name + "!";
    }
    
    @Override
    public int add(int a, int b) {
        return a + b;
    }
}
```

### 步骤3：启动服务端

```java
// 创建服务端
RpcServer server = new RpcServer();

// 注册服务
server.registerService(HelloService.class, new HelloServiceImpl());

// 启动服务（端口8888）
server.start(8888);
```

### 步骤4：启动客户端

```java
// 创建客户端
RpcClient client = new RpcClient();

// 连接服务器
client.connect("localhost", 8888);

// 创建代理
HelloService helloService = client.create(HelloService.class);

// 调用方法（像调用本地方法一样）
String result = helloService.sayHello("World");
System.out.println(result);  // 输出：Hello, World!

int sum = helloService.add(10, 20);
System.out.println(sum);  // 输出：30

// 关闭客户端
client.close();
```

---

## 💻 运行示例

### 方式1：分别运行服务端和客户端

**终端1 - 启动服务端：**
```bash
mvn exec:java -Dexec.mainClass="com.fragment.io.netty.project.rpc.RpcServer"
```

**终端2 - 启动客户端：**
```bash
mvn exec:java -Dexec.mainClass="com.fragment.io.netty.project.rpc.RpcClient"
```

### 方式2：在IDE中运行

1. 先运行 `RpcServer.main()`
2. 再运行 `RpcClient.main()`
3. 观察控制台输出

---

## 📊 执行流程

```
客户端调用流程：
┌─────────────────────────────────────────────────────────┐
│ 1. 客户端调用代理方法                                     │
│    helloService.sayHello("World")                       │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 2. 动态代理拦截调用                                       │
│    - 创建RpcRequest对象                                 │
│    - 设置接口名、方法名、参数                            │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 3. 编码器编码请求                                        │
│    - 按照协议格式编码                                    │
│    - 序列化请求对象                                      │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 4. 通过Netty发送到服务端                                 │
│    - 异步发送                                           │
│    - 等待响应                                           │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 5. 服务端接收请求                                        │
│    - 解码器解码请求                                      │
│    - 反序列化请求对象                                    │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 6. 服务端执行方法                                        │
│    - 根据接口名查找服务实例                              │
│    - 反射调用方法                                        │
│    - 获取返回值                                          │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 7. 服务端返回响应                                        │
│    - 创建RpcResponse对象                                │
│    - 编码并发送                                          │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│ 8. 客户端接收响应                                        │
│    - 解码响应                                           │
│    - 唤醒等待的线程                                      │
│    - 返回结果给调用方                                    │
└─────────────────────────────────────────────────────────┘
```

---

## 🔍 核心技术点

### 1. 自定义协议

- **魔数**：快速识别协议，防止错误连接
- **版本号**：支持协议升级
- **请求ID**：匹配请求和响应
- **长度字段**：解决粘包拆包问题

### 2. 编解码器

- **RpcEncoder**：将对象编码为字节流
- **RpcDecoder**：将字节流解码为对象
- 使用Java序列化（可替换为更高效的序列化方式）

### 3. 动态代理

- 使用JDK的Proxy和InvocationHandler
- 拦截方法调用，转换为RPC请求
- 透明的远程调用

### 4. 异步通信

- 使用CountDownLatch等待响应
- 支持超时控制
- 基于Netty的异步I/O

---

## ⚠️ 注意事项

### 1. 序列化

当前使用Java原生序列化，生产环境建议使用：
- **Protobuf**：性能好，跨语言
- **Hessian**：兼容性好
- **Kryo**：性能优秀

### 2. 异常处理

- 服务端异常会被封装到RpcResponse中
- 客户端会抛出原始异常
- 建议添加更完善的异常处理机制

### 3. 超时控制

- 当前超时时间为5秒
- 可根据实际情况调整
- 建议添加重试机制

### 4. 连接管理

- 当前每次调用都建立新连接
- 生产环境建议使用连接池
- 支持连接复用

---

## 🎓 扩展功能

可以继续扩展以下功能：

1. **服务注册与发现**
   - 集成Zookeeper或Nacos
   - 支持服务自动注册
   - 支持服务发现和负载均衡

2. **负载均衡**
   - 随机
   - 轮询
   - 一致性哈希

3. **容错机制**
   - 失败重试
   - 超时控制
   - 降级处理

4. **监控统计**
   - 调用次数统计
   - 响应时间统计
   - 异常统计

5. **更高效的序列化**
   - Protobuf
   - Hessian
   - Kryo

---

## 📝 总结

这是一个简单但完整的RPC框架实现，包含了RPC框架的核心功能：

✅ 自定义协议  
✅ 编解码器  
✅ 动态代理  
✅ 异步通信  
✅ 服务注册  
✅ 反射调用  

通过这个项目，你可以深入理解：
- RPC的工作原理
- Netty的实际应用
- 自定义协议设计
- 动态代理的使用

---

**Happy Coding! 🚀**
