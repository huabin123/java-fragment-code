# 03_HTTP协议演进

> **核心问题**：HTTP协议是如何一步步演进的？HTTP/1.1、HTTP/2、HTTP/3各解决了什么问题？如何选择和优化？

---

## 一、HTTP协议的演进历程

### 1.1 为什么需要HTTP协议？

**问题场景**：浏览器如何从服务器获取网页？

```
没有HTTP之前：
- 每个应用都要自己定义通信格式
- 没有统一标准
- 互操作性差

有了HTTP之后：
- 统一的请求/响应格式
- 标准的状态码
- 通用的头部字段
- 所有浏览器和服务器都遵循同一标准
```

### 1.2 HTTP协议的演进时间线

```
HTTP协议演进历程：

1991年 HTTP/0.9
├─ 只支持GET方法
├─ 只能传输HTML
└─ 每次请求都要建立新连接

1996年 HTTP/1.0
├─ 支持POST、HEAD等方法
├─ 支持多种内容类型
├─ 引入状态码和头部
└─ 仍然是短连接

1997年 HTTP/1.1 ⭐⭐⭐⭐⭐
├─ 持久连接（Keep-Alive）
├─ 管道化（Pipeline）
├─ 分块传输编码
├─ 缓存控制
└─ 使用最广泛

2015年 HTTP/2 ⭐⭐⭐⭐
├─ 二进制分帧
├─ 多路复用
├─ 头部压缩
├─ 服务器推送
└─ 性能大幅提升

2020年 HTTP/3 ⭐⭐⭐
├─ 基于QUIC（UDP）
├─ 0-RTT连接建立
├─ 更好的拥塞控制
└─ 解决队头阻塞
```

---

## 二、HTTP/1.0：基础版本

### 2.1 HTTP/1.0的特点

**请求格式**：
```
GET /index.html HTTP/1.0
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html

（空行）
```

**响应格式**：
```
HTTP/1.0 200 OK
Content-Type: text/html
Content-Length: 1234

<!DOCTYPE html>
<html>
...
</html>
```

### 2.2 HTTP/1.0的问题

**问题1：每次请求都要建立新连接**

```
HTTP/1.0的请求过程：

请求1：
┌─────────────────────────────────────────┐
│ 1. TCP三次握手（3个包）                  │
│ 2. 发送HTTP请求                         │
│ 3. 接收HTTP响应                         │
│ 4. TCP四次挥手（4个包）                  │
└─────────────────────────────────────────┘

请求2：
┌─────────────────────────────────────────┐
│ 1. TCP三次握手（3个包）                  │
│ 2. 发送HTTP请求                         │
│ 3. 接收HTTP响应                         │
│ 4. TCP四次挥手（4个包）                  │
└─────────────────────────────────────────┘

问题：
- 每次请求都要握手和挥手
- 大量的网络开销
- 延迟高
```

**性能分析**：
```
假设：
- RTT（往返时间）= 50ms
- 一个网页有10个资源（HTML + 9个图片）

HTTP/1.0的加载时间：
- 每个资源：TCP握手(50ms) + 请求(50ms) + 响应(50ms) + 挥手(50ms) = 200ms
- 10个资源：200ms × 10 = 2000ms = 2秒

太慢了！
```

---

## 三、HTTP/1.1：持久连接时代

### 3.1 HTTP/1.1的核心改进

**改进1：持久连接（Keep-Alive）**

```
HTTP/1.1的请求过程：

┌─────────────────────────────────────────┐
│ 1. TCP三次握手（一次）                   │
├─────────────────────────────────────────┤
│ 2. 发送请求1 → 接收响应1                 │
│ 3. 发送请求2 → 接收响应2                 │
│ 4. 发送请求3 → 接收响应3                 │
│ ...                                     │
├─────────────────────────────────────────┤
│ N. TCP四次挥手（一次）                   │
└─────────────────────────────────────────┘

优势：
- 只需要一次握手和挥手
- 复用TCP连接
- 减少网络开销
```

**性能对比**：
```
同样的场景（10个资源）：

HTTP/1.0：
- 10次握手 + 10次请求 + 10次挥手
- 耗时：2000ms

HTTP/1.1（Keep-Alive）：
- 1次握手 + 10次请求 + 1次挥手
- 耗时：650ms

性能提升：3倍！
```

**代码示例**：
```java
// HTTP/1.0（短连接）
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestProperty("Connection", "close");  // 明确关闭连接

// HTTP/1.1（持久连接）
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestProperty("Connection", "keep-alive");  // 保持连接
// 或者不设置，默认就是keep-alive
```

**改进2：管道化（Pipeline）**

```
没有管道化：
客户端                                    服务器
  │                                         │
  │  请求1                                  │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应1                                  │
  │←───────────────────────────────────── │
  │                                         │
  │  请求2                                  │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应2                                  │
  │←───────────────────────────────────── │

问题：必须等待响应1才能发送请求2

有管道化：
客户端                                    服务器
  │                                         │
  │  请求1                                  │
  │─────────────────────────────────────→ │
  │  请求2                                  │
  │─────────────────────────────────────→ │
  │  请求3                                  │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应1                                  │
  │←───────────────────────────────────── │
  │  响应2                                  │
  │←───────────────────────────────────── │
  │  响应3                                  │
  │←───────────────────────────────────── │

优势：不用等待响应，连续发送请求
```

**但是**：管道化有严重的问题！

**改进3：分块传输编码（Chunked Transfer Encoding）**

```
问题：服务器不知道响应的总长度

场景：动态生成的内容
- 服务器边生成边发送
- 无法预先知道Content-Length

解决：分块传输
HTTP/1.1 200 OK
Transfer-Encoding: chunked

5\r\n
Hello\r\n
6\r\n
 World\r\n
0\r\n
\r\n

格式：
- 每块前面是长度（16进制）
- 最后一块长度为0
```

### 3.2 HTTP/1.1的问题

**问题1：队头阻塞（Head-of-Line Blocking）**

```
管道化的问题：

客户端                                    服务器
  │                                         │
  │  请求1（小文件）                         │
  │─────────────────────────────────────→ │
  │  请求2（大文件）                         │
  │─────────────────────────────────────→ │
  │  请求3（小文件）                         │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应1（快）                            │
  │←───────────────────────────────────── │
  │                                         │
  │  响应2（慢，阻塞了响应3）                │
  │←───────────────────────────────────── │
  │                                         │
  │  响应3（被阻塞，必须等响应2完成）         │
  │←───────────────────────────────────── │

问题：
- 响应必须按顺序返回
- 慢的响应会阻塞后面的响应
- 即使后面的响应已经准备好了
```

**实际影响**：
```
场景：加载网页
- HTML（1KB，10ms）
- CSS（100KB，100ms）
- JS（10KB，20ms）

没有队头阻塞：
- 总时间：max(10ms, 100ms, 20ms) = 100ms

有队头阻塞：
- 总时间：10ms + 100ms + 20ms = 130ms

性能损失：30%
```

**问题2：头部冗余**

```
HTTP/1.1的请求头：

请求1：
GET /page1.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session=abc123; user=john; ...
（总共约500字节）

请求2：
GET /page2.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session=abc123; user=john; ...
（又是500字节，几乎完全重复！）

问题：
- 大量重复的头部
- 浪费带宽
- 增加延迟
```

**问题3：并发限制**

```
浏览器的并发限制：
- Chrome：每个域名最多6个并发连接
- Firefox：每个域名最多6个并发连接

为什么限制？
- 避免占用过多服务器资源
- 避免网络拥塞

但这也限制了性能：
- 如果有100个资源
- 只能6个6个地加载
- 总时间 = 100 / 6 × 每批次时间
```

---

## 四、HTTP/2：多路复用时代

### 4.1 HTTP/2的核心改进

**改进1：二进制分帧**

```
HTTP/1.1（文本协议）：
GET /index.html HTTP/1.1\r\n
Host: www.example.com\r\n
\r\n

HTTP/2（二进制协议）：
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+

优势：
- 解析更快（二进制）
- 更紧凑（节省空间）
- 更少的错误（严格的格式）
```

**改进2：多路复用（Multiplexing）**

```
HTTP/1.1（队头阻塞）：
TCP连接
┌─────────────────────────────────────────┐
│ 请求1 → 响应1 → 请求2 → 响应2 → 请求3 → 响应3 │
└─────────────────────────────────────────┘
响应必须按顺序返回

HTTP/2（多路复用）：
TCP连接
┌─────────────────────────────────────────┐
│ Stream 1: 请求1 ⇄ 响应1                  │
│ Stream 2: 请求2 ⇄ 响应2                  │
│ Stream 3: 请求3 ⇄ 响应3                  │
└─────────────────────────────────────────┘
多个Stream并行传输，互不影响

工作原理：
┌─────────────────────────────────────────┐
│ 1. 将请求/响应分成多个Frame              │
│ 2. 每个Frame标记Stream ID                │
│ 3. 多个Stream的Frame交错发送             │
│ 4. 接收方根据Stream ID重组               │
└─────────────────────────────────────────┘
```

**多路复用示例**：
```
发送顺序：
Frame1 (Stream 1, 请求1的头部)
Frame2 (Stream 2, 请求2的头部)
Frame3 (Stream 1, 请求1的数据)
Frame4 (Stream 3, 请求3的头部)
Frame5 (Stream 2, 请求2的数据)
Frame6 (Stream 1, 响应1的头部)
Frame7 (Stream 3, 请求3的数据)
Frame8 (Stream 1, 响应1的数据)
...

接收方重组：
Stream 1: Frame1 + Frame3 + Frame6 + Frame8 → 完整的请求1和响应1
Stream 2: Frame2 + Frame5 → 请求2
Stream 3: Frame4 + Frame7 → 请求3
```

**性能提升**：
```
场景：加载100个小图片

HTTP/1.1（6个并发连接）：
- 每批次6个
- 总批次：100 / 6 ≈ 17批
- 每批次50ms
- 总时间：17 × 50ms = 850ms

HTTP/2（1个连接，多路复用）：
- 所有请求并行
- 总时间：50ms

性能提升：17倍！
```

**改进3：头部压缩（HPACK）**

```
HTTP/1.1（无压缩）：
请求1：500字节头部
请求2：500字节头部（几乎完全重复）
请求3：500字节头部（几乎完全重复）
总计：1500字节

HTTP/2（HPACK压缩）：
请求1：500字节头部（完整发送）
请求2：50字节头部（只发送差异）
请求3：50字节头部（只发送差异）
总计：600字节

压缩率：60%！
```

**HPACK工作原理**：
```
1. 静态表（预定义的常用头部）
   索引2: :method GET
   索引3: :method POST
   索引4: :path /
   ...

2. 动态表（会话期间的头部）
   索引62: host: www.example.com
   索引63: user-agent: Mozilla/5.0 ...
   ...

3. 发送时只发送索引
   请求1：完整头部
   请求2：索引62, 索引63, ... （只发送索引）
   请求3：索引62, 索引63, ... （只发送索引）
```

**改进4：服务器推送（Server Push）**

```
传统方式：
客户端                                    服务器
  │                                         │
  │  请求 index.html                        │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应 index.html                        │
  │  （包含<link rel="stylesheet" href="style.css">）
  │←───────────────────────────────────── │
  │                                         │
  │  解析HTML，发现需要style.css            │
  │  请求 style.css                         │
  │─────────────────────────────────────→ │
  │                                         │
  │  响应 style.css                         │
  │←───────────────────────────────────── │

问题：需要两次往返

HTTP/2服务器推送：
客户端                                    服务器
  │                                         │
  │  请求 index.html                        │
  │─────────────────────────────────────→ │
  │                                         │
  │  推送 style.css（主动推送）             │
  │←───────────────────────────────────── │
  │  响应 index.html                        │
  │←───────────────────────────────────── │
  │                                         │
  │  解析HTML，发现需要style.css            │
  │  （已经有了，不需要请求）                │

优势：只需要一次往返
```

### 4.2 HTTP/2的问题

**问题：TCP层的队头阻塞**

```
HTTP/2解决了应用层的队头阻塞，但TCP层仍然有：

场景：丢包
┌─────────────────────────────────────────┐
│ TCP连接                                  │
│ ┌─────┬─────┬─────┬─────┬─────┐        │
│ │Pkt1 │Pkt2 │Pkt3 │Pkt4 │Pkt5 │        │
│ └─────┴─────┴─────┴─────┴─────┘        │
│           ↓ 丢失                         │
│                                         │
│ 问题：                                   │
│ - Pkt2丢失                              │
│ - TCP必须等待Pkt2重传                   │
│ - Pkt3、Pkt4、Pkt5都被阻塞              │
│ - 即使它们已经到达                       │
└─────────────────────────────────────────┘

这就是HTTP/3要解决的问题！
```

---

## 五、HTTP/3：基于QUIC的未来

### 5.1 为什么需要HTTP/3？

**HTTP/2的根本问题**：基于TCP

```
TCP的问题：
1. 队头阻塞（丢包时）
2. 握手延迟（三次握手）
3. 连接迁移困难（IP变化时）
4. 拥塞控制不够灵活
```

**HTTP/3的解决方案**：使用QUIC（基于UDP）

```
QUIC的优势：
1. 无队头阻塞（Stream独立）
2. 0-RTT连接建立
3. 连接迁移（Connection ID）
4. 改进的拥塞控制
```

### 5.2 HTTP/3的核心特性

**特性1：基于UDP**

```
为什么用UDP？
- TCP是内核实现，难以修改
- UDP是用户空间，灵活性高
- QUIC在UDP之上实现可靠传输

QUIC = UDP + 可靠性 + 拥塞控制 + 加密
```

**特性2：0-RTT连接建立**

```
TCP + TLS（3-RTT）：
客户端                                    服务器
  │                                         │
  │  1. TCP SYN                            │
  │─────────────────────────────────────→ │
  │  2. TCP SYN-ACK                        │
  │←───────────────────────────────────── │
  │  3. TCP ACK                            │
  │─────────────────────────────────────→ │
  │  4. TLS ClientHello                    │
  │─────────────────────────────────────→ │
  │  5. TLS ServerHello                    │
  │←───────────────────────────────────── │
  │  6. TLS Finished                       │
  │─────────────────────────────────────→ │
  │  7. 应用数据                            │
  │─────────────────────────────────────→ │

总计：3-RTT

QUIC（0-RTT）：
客户端                                    服务器
  │                                         │
  │  1. ClientHello + 应用数据              │
  │─────────────────────────────────────→ │
  │  2. ServerHello + 应用数据              │
  │←───────────────────────────────────── │

总计：0-RTT（首次连接1-RTT）

性能提升：3倍！
```

**特性3：无队头阻塞**

```
HTTP/2（TCP层队头阻塞）：
┌─────────────────────────────────────────┐
│ TCP连接                                  │
│ Stream1, Stream2, Stream3               │
│                                         │
│ 如果一个包丢失：                         │
│ - 所有Stream都被阻塞                    │
│ - 必须等待重传                          │
└─────────────────────────────────────────┘

HTTP/3（无队头阻塞）：
┌─────────────────────────────────────────┐
│ QUIC连接                                 │
│ Stream1, Stream2, Stream3               │
│                                         │
│ 如果Stream1的包丢失：                    │
│ - 只有Stream1被阻塞                     │
│ - Stream2和Stream3继续传输              │
└─────────────────────────────────────────┘
```

### 5.3 HTTP版本对比

```
HTTP版本对比表：

┌─────────────┬──────────┬──────────┬──────────┐
│ 特性         │ HTTP/1.1 │ HTTP/2   │ HTTP/3   │
├─────────────┼──────────┼──────────┼──────────┤
│ 传输协议     │ TCP      │ TCP      │ QUIC/UDP │
│ 多路复用     │ ✗        │ ✓        │ ✓        │
│ 头部压缩     │ ✗        │ ✓(HPACK) │ ✓(QPACK) │
│ 服务器推送   │ ✗        │ ✓        │ ✓        │
│ 队头阻塞     │ ✓        │ ✓(TCP层) │ ✗        │
│ 连接建立     │ 3-RTT    │ 3-RTT    │ 0-1 RTT  │
│ 连接迁移     │ ✗        │ ✗        │ ✓        │
│ 加密         │ 可选     │ 可选     │ 强制     │
└─────────────┴──────────┴──────────┴──────────┘
```

---

## 六、HTTPS：安全的HTTP

### 6.1 为什么需要HTTPS？

**HTTP的安全问题**：

```
HTTP（明文传输）：
客户端 ──→ 中间人 ──→ 服务器
        ↓
    可以窃听
    可以篡改
    可以伪造

问题：
1. 窃听：密码、信用卡号被截获
2. 篡改：网页内容被修改
3. 伪造：假冒服务器
```

**HTTPS的解决方案**：

```
HTTPS = HTTP + TLS/SSL

TLS提供：
1. 加密：防止窃听
2. 完整性：防止篡改
3. 认证：防止伪造
```

### 6.2 TLS握手过程

```
TLS 1.2握手（2-RTT）：

客户端                                    服务器
  │                                         │
  │  1. ClientHello                        │
  │  （支持的加密套件、随机数）              │
  │─────────────────────────────────────→ │
  │                                         │
  │  2. ServerHello                        │
  │  （选择的加密套件、随机数、证书）        │
  │←───────────────────────────────────── │
  │                                         │
  │  验证证书                               │
  │  生成预主密钥                           │
  │                                         │
  │  3. ClientKeyExchange                  │
  │  （加密的预主密钥）                      │
  │─────────────────────────────────────→ │
  │                                         │
  │  4. Finished                           │
  │─────────────────────────────────────→ │
  │                                         │
  │  5. Finished                           │
  │←───────────────────────────────────── │
  │                                         │
  │  6. 应用数据（加密）                    │
  │←─────────────────────────────────────→│

TLS 1.3握手（1-RTT）：
客户端                                    服务器
  │                                         │
  │  1. ClientHello + KeyShare             │
  │─────────────────────────────────────→ │
  │                                         │
  │  2. ServerHello + KeyShare + Finished  │
  │←───────────────────────────────────── │
  │                                         │
  │  3. Finished                           │
  │─────────────────────────────────────→ │
  │                                         │
  │  4. 应用数据（加密）                    │
  │←─────────────────────────────────────→│

性能提升：减少1-RTT
```

### 6.3 HTTPS性能优化

**优化1：会话复用**

```java
// 启用会话复用
SSLContext sslContext = SSLContext.getInstance("TLS");
sslContext.init(null, null, null);

// 会话缓存
SSLSessionContext sessionContext = sslContext.getServerSessionContext();
sessionContext.setSessionCacheSize(1000);  // 缓存1000个会话
sessionContext.setSessionTimeout(3600);    // 1小时超时

// 效果：
// - 首次连接：完整握手（2-RTT）
// - 后续连接：会话复用（1-RTT）
```

**优化2：OCSP Stapling**

```
问题：证书吊销检查
- 客户端需要向CA查询证书是否被吊销
- 增加延迟

解决：OCSP Stapling
- 服务器预先查询OCSP响应
- 在握手时一起发送给客户端
- 客户端不需要再查询

性能提升：减少1次网络请求
```

---

## 七、HTTP性能优化实战

### 7.1 启用HTTP/2

**Nginx配置**：
```nginx
server {
    listen 443 ssl http2;  # 启用HTTP/2
    server_name www.example.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    
    # 其他配置...
}
```

**Java客户端**：
```java
// 使用HTTP/2
HttpClient client = HttpClient.newBuilder()
    .version(HttpClient.Version.HTTP_2)
    .build();

HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://www.example.com"))
    .build();

HttpResponse<String> response = client.send(request, 
    HttpResponse.BodyHandlers.ofString());
```

### 7.2 资源合并与拆分

**HTTP/1.1时代：合并资源**
```html
<!-- 合并CSS -->
<link rel="stylesheet" href="all.css">  <!-- 包含所有CSS -->

<!-- 合并JS -->
<script src="all.js"></script>  <!-- 包含所有JS -->

<!-- 雪碧图 -->
<div class="icon icon-home"></div>  <!-- 所有图标在一张图上 -->

原因：减少HTTP请求数量
```

**HTTP/2时代：拆分资源**
```html
<!-- 拆分CSS -->
<link rel="stylesheet" href="header.css">
<link rel="stylesheet" href="content.css">
<link rel="stylesheet" href="footer.css">

<!-- 拆分JS -->
<script src="utils.js"></script>
<script src="app.js"></script>

<!-- 独立图标 -->
<img src="icon-home.png">
<img src="icon-user.png">

原因：
- HTTP/2支持多路复用
- 拆分后可以更好地缓存
- 只加载需要的资源
```

### 7.3 使用CDN

```
CDN的优势：
1. 就近访问（减少延迟）
2. 负载均衡（提高可用性）
3. 缓存静态资源（减少服务器压力）

配置示例：
<script src="https://cdn.example.com/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.example.com/style.css">
```

---

## 八、核心问题总结

### Q1：HTTP/1.1和HTTP/2的主要区别是什么？

**答**：
1. **多路复用**：HTTP/2支持，HTTP/1.1不支持
2. **头部压缩**：HTTP/2使用HPACK，HTTP/1.1无压缩
3. **服务器推送**：HTTP/2支持，HTTP/1.1不支持
4. **二进制协议**：HTTP/2是二进制，HTTP/1.1是文本

### Q2：HTTP/2解决了队头阻塞吗？

**答**：
- **应用层**：解决了（多路复用）
- **TCP层**：没有解决（丢包时仍然阻塞）
- **HTTP/3**：彻底解决（基于QUIC）

### Q3：什么时候应该使用HTTP/2？

**答**：
- ✅ 资源较多的网站（多路复用优势明显）
- ✅ 需要服务器推送的场景
- ✅ 移动网络环境（头部压缩节省流量）
- ❌ 资源很少的网站（优势不明显）

### Q4：HTTPS会影响性能吗？

**答**：
- **会影响**：增加握手延迟（1-2 RTT）
- **可优化**：会话复用、OCSP Stapling、TLS 1.3
- **整体影响**：现代优化后，影响很小（<10%）

---

## 九、下一步学习

在理解HTTP协议演进后，下一章我们将学习：

**第4章：WebSocket协议详解**
- WebSocket的握手过程
- 帧格式和消息类型
- 心跳保活机制
- WebSocket vs HTTP长轮询

---

**继续学习**：[04_WebSocket协议详解](./04_WebSocket协议详解.md)
