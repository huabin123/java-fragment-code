# 连接池与对象池

## 为什么需要池化技术

### 问题场景

在高并发场景下，频繁创建和销毁资源会带来严重的性能问题：

```java
// 每次请求都创建新连接
public void handleRequest() {
    Connection conn = DriverManager.getConnection(url);  // 耗时操作
    // 使用连接
    conn.close();  // 销毁连接
}
```

**问题分析**：
1. **创建开销大**：建立TCP连接需要三次握手，耗时较长
2. **资源浪费**：频繁创建销毁导致CPU和内存开销
3. **响应时间长**：每次请求都要等待连接建立
4. **系统负载高**：大量TIME_WAIT状态的连接占用系统资源

### 池化技术的优势

```
传统方式：
请求1: 创建 -> 使用 -> 销毁
请求2: 创建 -> 使用 -> 销毁
请求3: 创建 -> 使用 -> 销毁

池化方式：
初始化: 创建连接池(10个连接)
请求1: 获取 -> 使用 -> 归还
请求2: 获取 -> 使用 -> 归还
请求3: 获取 -> 使用 -> 归还
```

**优势**：
1. **减少创建开销**：连接预先创建，复用连接
2. **提高响应速度**：无需等待连接建立
3. **控制资源使用**：限制最大连接数，防止资源耗尽
4. **提升系统吞吐量**：减少等待时间，提高并发处理能力

## 连接池设计原理

### 核心组件

```
┌─────────────────────────────────────┐
│         连接池管理器                 │
├─────────────────────────────────────┤
│  核心参数:                           │
│  - coreSize: 核心连接数              │
│  - maxSize: 最大连接数               │
│  - maxWait: 最大等待时间             │
│  - maxIdleTime: 最大空闲时间         │
├─────────────────────────────────────┤
│  空闲连接队列                        │
│  [Conn1] [Conn2] [Conn3] ...        │
├─────────────────────────────────────┤
│  活跃连接集合                        │
│  {Conn4, Conn5, Conn6, ...}         │
└─────────────────────────────────────┘
```

### 连接状态转换

```
        创建
         ↓
    [空闲状态] ←─────┐
         ↓           │
      获取连接        │ 归还连接
         ↓           │
    [活跃状态] ───────┘
         ↓
      超时/异常
         ↓
    [销毁状态]
```

### 关键参数配置

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| coreSize | 核心连接数 | CPU核心数 * 2 |
| maxSize | 最大连接数 | coreSize * 4 |
| maxWait | 最大等待时间 | 3000ms |
| maxIdleTime | 最大空闲时间 | 60000ms |
| validationQuery | 连接验证SQL | SELECT 1 |
| testOnBorrow | 获取时验证 | true |
| testWhileIdle | 空闲时验证 | true |

## 连接池实现

### 简单连接池实现

```java
public class SimpleConnectionPool {
    private final int coreSize;
    private final int maxSize;
    private final long maxWait;
    
    // 空闲连接队列
    private final BlockingQueue<Connection> idleConnections;
    // 活跃连接集合
    private final Set<Connection> activeConnections;
    // 当前连接总数
    private final AtomicInteger totalConnections;
    
    private final String url;
    private final String username;
    private final String password;
    
    public SimpleConnectionPool(String url, String username, String password,
                               int coreSize, int maxSize, long maxWait) {
        this.url = url;
        this.username = username;
        this.password = password;
        this.coreSize = coreSize;
        this.maxSize = maxSize;
        this.maxWait = maxWait;
        
        this.idleConnections = new LinkedBlockingQueue<>();
        this.activeConnections = Collections.synchronizedSet(new HashSet<>());
        this.totalConnections = new AtomicInteger(0);
        
        // 初始化核心连接
        initCoreConnections();
    }
    
    /**
     * 初始化核心连接
     */
    private void initCoreConnections() {
        for (int i = 0; i < coreSize; i++) {
            try {
                Connection conn = createConnection();
                idleConnections.offer(conn);
                totalConnections.incrementAndGet();
            } catch (SQLException e) {
                throw new RuntimeException("初始化连接池失败", e);
            }
        }
    }
    
    /**
     * 创建新连接
     */
    private Connection createConnection() throws SQLException {
        return DriverManager.getConnection(url, username, password);
    }
    
    /**
     * 获取连接
     */
    public Connection getConnection() throws SQLException {
        // 1. 尝试从空闲队列获取
        Connection conn = idleConnections.poll();
        
        if (conn != null && isValid(conn)) {
            activeConnections.add(conn);
            return conn;
        }
        
        // 2. 如果没有空闲连接，尝试创建新连接
        if (totalConnections.get() < maxSize) {
            synchronized (this) {
                if (totalConnections.get() < maxSize) {
                    conn = createConnection();
                    totalConnections.incrementAndGet();
                    activeConnections.add(conn);
                    return conn;
                }
            }
        }
        
        // 3. 等待空闲连接
        try {
            conn = idleConnections.poll(maxWait, TimeUnit.MILLISECONDS);
            if (conn == null) {
                throw new SQLException("获取连接超时");
            }
            
            if (!isValid(conn)) {
                totalConnections.decrementAndGet();
                return getConnection();  // 递归重试
            }
            
            activeConnections.add(conn);
            return conn;
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new SQLException("获取连接被中断", e);
        }
    }
    
    /**
     * 归还连接
     */
    public void releaseConnection(Connection conn) {
        if (conn == null) {
            return;
        }
        
        activeConnections.remove(conn);
        
        if (isValid(conn)) {
            idleConnections.offer(conn);
        } else {
            // 连接无效，销毁并创建新连接
            closeConnection(conn);
            totalConnections.decrementAndGet();
            
            // 如果连接数少于核心数，创建新连接
            if (totalConnections.get() < coreSize) {
                try {
                    Connection newConn = createConnection();
                    idleConnections.offer(newConn);
                    totalConnections.incrementAndGet();
                } catch (SQLException e) {
                    // 记录日志
                }
            }
        }
    }
    
    /**
     * 验证连接是否有效
     */
    private boolean isValid(Connection conn) {
        try {
            return conn != null && !conn.isClosed() && conn.isValid(1);
        } catch (SQLException e) {
            return false;
        }
    }
    
    /**
     * 关闭连接
     */
    private void closeConnection(Connection conn) {
        try {
            if (conn != null && !conn.isClosed()) {
                conn.close();
            }
        } catch (SQLException e) {
            // 记录日志
        }
    }
    
    /**
     * 关闭连接池
     */
    public void shutdown() {
        // 关闭所有空闲连接
        Connection conn;
        while ((conn = idleConnections.poll()) != null) {
            closeConnection(conn);
        }
        
        // 关闭所有活跃连接
        for (Connection activeConn : activeConnections) {
            closeConnection(activeConn);
        }
        
        activeConnections.clear();
        totalConnections.set(0);
    }
}
```

### 使用示例

```java
// 创建连接池
SimpleConnectionPool pool = new SimpleConnectionPool(
    "jdbc:mysql://localhost:3306/test",
    "root",
    "password",
    10,    // 核心连接数
    50,    // 最大连接数
    3000   // 最大等待时间
);

// 使用连接
Connection conn = null;
try {
    conn = pool.getConnection();
    
    // 执行数据库操作
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery("SELECT * FROM users");
    
    // 处理结果
    while (rs.next()) {
        System.out.println(rs.getString("name"));
    }
    
} catch (SQLException e) {
    e.printStackTrace();
} finally {
    // 归还连接
    if (conn != null) {
        pool.releaseConnection(conn);
    }
}

// 关闭连接池
pool.shutdown();
```

## 对象池设计

### 为什么需要对象池

在高并发场景下，频繁创建对象会导致：
1. **GC压力大**：大量短生命周期对象增加GC频率
2. **内存抖动**：频繁分配和回收内存
3. **性能下降**：对象创建和初始化耗时

**适用场景**：
- 对象创建成本高（如ByteBuffer、线程等）
- 对象使用频繁
- 对象可以复用

### 通用对象池实现

```java
public class GenericObjectPool<T> {
    
    /**
     * 对象工厂接口
     */
    public interface ObjectFactory<T> {
        T create();
        boolean validate(T obj);
        void destroy(T obj);
    }
    
    private final ObjectFactory<T> factory;
    private final int maxSize;
    private final BlockingQueue<T> pool;
    private final AtomicInteger count;
    
    public GenericObjectPool(ObjectFactory<T> factory, int maxSize) {
        this.factory = factory;
        this.maxSize = maxSize;
        this.pool = new LinkedBlockingQueue<>(maxSize);
        this.count = new AtomicInteger(0);
    }
    
    /**
     * 获取对象
     */
    public T borrowObject() {
        T obj = pool.poll();
        
        if (obj != null && factory.validate(obj)) {
            return obj;
        }
        
        if (count.get() < maxSize) {
            synchronized (this) {
                if (count.get() < maxSize) {
                    obj = factory.create();
                    count.incrementAndGet();
                    return obj;
                }
            }
        }
        
        try {
            obj = pool.take();
            if (!factory.validate(obj)) {
                factory.destroy(obj);
                count.decrementAndGet();
                return borrowObject();
            }
            return obj;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException("获取对象被中断", e);
        }
    }
    
    /**
     * 归还对象
     */
    public void returnObject(T obj) {
        if (obj == null) {
            return;
        }
        
        if (factory.validate(obj)) {
            pool.offer(obj);
        } else {
            factory.destroy(obj);
            count.decrementAndGet();
        }
    }
    
    /**
     * 关闭对象池
     */
    public void close() {
        T obj;
        while ((obj = pool.poll()) != null) {
            factory.destroy(obj);
        }
        count.set(0);
    }
}
```

### ByteBuffer对象池示例

```java
// 创建ByteBuffer对象池
GenericObjectPool<ByteBuffer> bufferPool = new GenericObjectPool<>(
    new GenericObjectPool.ObjectFactory<ByteBuffer>() {
        @Override
        public ByteBuffer create() {
            return ByteBuffer.allocateDirect(1024);  // 创建直接内存缓冲区
        }
        
        @Override
        public boolean validate(ByteBuffer buffer) {
            return buffer != null && buffer.capacity() == 1024;
        }
        
        @Override
        public void destroy(ByteBuffer buffer) {
            // DirectByteBuffer会被GC自动回收
        }
    },
    100  // 最大100个ByteBuffer
);

// 使用对象池
ByteBuffer buffer = bufferPool.borrowObject();
try {
    // 使用buffer
    buffer.clear();
    buffer.put("Hello".getBytes());
    buffer.flip();
    
    // 处理数据
    
} finally {
    // 归还对象
    bufferPool.returnObject(buffer);
}

// 关闭对象池
bufferPool.close();
```

## Netty中的池化技术

### ByteBuf池化

Netty使用`PooledByteBufAllocator`实现ByteBuf池化：

```java
// 启用池化ByteBuf
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);

// 分配ByteBuf
ByteBuf buf = PooledByteBufAllocator.DEFAULT.buffer(1024);
try {
    // 使用buf
    buf.writeBytes("Hello".getBytes());
} finally {
    // 释放（归还到池中）
    buf.release();
}
```

**池化优势**：
1. 减少GC压力
2. 提高内存分配效率
3. 支持直接内存池化

### 线程池

Netty的EventLoopGroup就是一个线程池：

```java
// 创建线程池
EventLoopGroup bossGroup = new NioEventLoopGroup(1);        // Boss线程池
EventLoopGroup workerGroup = new NioEventLoopGroup(8);      // Worker线程池

// 配置线程池
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
    .channel(NioServerSocketChannel.class);

// 优雅关闭
bossGroup.shutdownGracefully();
workerGroup.shutdownGracefully();
```

## 常见连接池框架

### HikariCP（推荐）

```xml
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
    <version>5.0.1</version>
</dependency>
```

```java
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
config.setUsername("root");
config.setPassword("password");
config.setMaximumPoolSize(20);
config.setMinimumIdle(5);
config.setConnectionTimeout(30000);
config.setIdleTimeout(600000);
config.setMaxLifetime(1800000);

HikariDataSource dataSource = new HikariDataSource(config);

// 使用连接
try (Connection conn = dataSource.getConnection()) {
    // 执行数据库操作
}

// 关闭数据源
dataSource.close();
```

### Apache Commons Pool2

```xml
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.11.1</version>
</dependency>
```

```java
// 创建对象工厂
PooledObjectFactory<MyObject> factory = new BasePooledObjectFactory<MyObject>() {
    @Override
    public MyObject create() {
        return new MyObject();
    }
    
    @Override
    public PooledObject<MyObject> wrap(MyObject obj) {
        return new DefaultPooledObject<>(obj);
    }
};

// 创建对象池
GenericObjectPool<MyObject> pool = new GenericObjectPool<>(factory);
pool.setMaxTotal(100);
pool.setMaxIdle(20);
pool.setMinIdle(5);

// 使用对象
MyObject obj = pool.borrowObject();
try {
    // 使用obj
} finally {
    pool.returnObject(obj);
}

// 关闭对象池
pool.close();
```

## 最佳实践

### 1. 合理配置池大小

```java
// 计算公式
int coreSize = Runtime.getRuntime().availableProcessors() * 2;
int maxSize = coreSize * 4;

// 根据业务特点调整
// - IO密集型：增大池大小
// - CPU密集型：池大小接近CPU核心数
```

### 2. 连接验证

```java
// 获取时验证
config.setTestOnBorrow(true);
config.setValidationQuery("SELECT 1");

// 空闲时验证
config.setTestWhileIdle(true);
config.setTimeBetweenEvictionRunsMillis(60000);
```

### 3. 连接泄漏检测

```java
// HikariCP连接泄漏检测
config.setLeakDetectionThreshold(60000);  // 60秒未归还视为泄漏

// 使用try-with-resources自动关闭
try (Connection conn = dataSource.getConnection()) {
    // 使用连接
}  // 自动归还
```

### 4. 监控和统计

```java
// 获取连接池统计信息
HikariPoolMXBean poolMXBean = dataSource.getHikariPoolMXBean();
System.out.println("活跃连接数: " + poolMXBean.getActiveConnections());
System.out.println("空闲连接数: " + poolMXBean.getIdleConnections());
System.out.println("总连接数: " + poolMXBean.getTotalConnections());
System.out.println("等待线程数: " + poolMXBean.getThreadsAwaitingConnection());
```

## 性能对比

### 测试场景

```java
// 场景：1000次数据库查询
// 方式1：每次创建新连接
// 方式2：使用连接池
```

### 测试结果

| 方式 | 总耗时 | 平均耗时 | QPS |
|------|--------|----------|-----|
| 新建连接 | 15000ms | 15ms | 66 |
| 连接池 | 1000ms | 1ms | 1000 |

**结论**：连接池性能提升15倍！

## 总结

### 核心要点

1. **池化技术**：通过复用资源减少创建销毁开销
2. **连接池**：管理数据库连接，提高数据库访问性能
3. **对象池**：管理可复用对象，减少GC压力
4. **合理配置**：根据业务特点配置池大小和参数

### 使用建议

1. **优先使用成熟框架**：HikariCP、Commons Pool2
2. **合理配置参数**：根据业务压测结果调整
3. **监控池状态**：及时发现连接泄漏等问题
4. **正确释放资源**：使用try-with-resources或finally块

### 注意事项

1. 池大小不是越大越好，过大会浪费资源
2. 必须正确归还资源，否则会导致资源泄漏
3. 定期验证池中对象的有效性
4. 设置合理的超时时间，避免无限等待
