# 性能调优实战

## 性能调优方法论

### 调优流程

```
1. 确定性能目标
   ↓
2. 性能基准测试
   ↓
3. 性能分析定位
   ↓
4. 优化实施
   ↓
5. 验证效果
   ↓
6. 持续监控
```

### 性能指标

| 指标 | 说明 | 目标值 |
|------|------|--------|
| QPS | 每秒查询数 | 根据业务需求 |
| RT | 响应时间 | P99 < 100ms |
| 吞吐量 | 单位时间处理数据量 | 越高越好 |
| CPU使用率 | CPU占用百分比 | < 70% |
| 内存使用率 | 内存占用百分比 | < 80% |
| 网络带宽 | 网络传输速率 | 不超过物理上限 |
| 连接数 | 并发连接数 | 根据系统容量 |

## JVM调优

### 1. 堆内存配置

```bash
# 基本配置
-Xms4g                    # 初始堆大小
-Xmx4g                    # 最大堆大小（建议与Xms相同）
-Xmn2g                    # 年轻代大小（建议堆的1/3到1/2）
-XX:MetaspaceSize=256m    # 元空间初始大小
-XX:MaxMetaspaceSize=512m # 元空间最大大小

# 直接内存
-XX:MaxDirectMemorySize=1g  # 直接内存大小（用于NIO）
```

**配置原则**：
- 堆大小 = 年轻代 + 老年代
- 年轻代过小：频繁Minor GC
- 年轻代过大：Minor GC耗时长
- 老年代过小：频繁Full GC
- 老年代过大：Full GC耗时长

### 2. GC选择与配置

#### G1 GC（推荐）

```bash
# G1 GC配置
-XX:+UseG1GC                          # 使用G1垃圾回收器
-XX:MaxGCPauseMillis=200              # 最大GC停顿时间目标
-XX:G1HeapRegionSize=16m              # Region大小
-XX:InitiatingHeapOccupancyPercent=45 # 触发并发GC的堆占用阈值
-XX:G1ReservePercent=10               # 保留空间百分比
-XX:ConcGCThreads=4                   # 并发GC线程数
```

**适用场景**：
- 堆内存较大（>4GB）
- 需要可预测的停顿时间
- 吞吐量和延迟都有要求

#### ZGC（低延迟）

```bash
# ZGC配置（JDK 11+）
-XX:+UseZGC                    # 使用ZGC
-XX:ZCollectionInterval=120    # GC间隔（秒）
-XX:ZAllocationSpikeTolerance=5 # 分配峰值容忍度
```

**适用场景**：
- 超大堆内存（>100GB）
- 极低延迟要求（<10ms）
- JDK 11+

### 3. GC日志配置

```bash
# GC日志（JDK 8）
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-XX:+PrintGCTimeStamps
-Xloggc:/var/log/gc.log
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=10
-XX:GCLogFileSize=100M

# GC日志（JDK 9+）
-Xlog:gc*:file=/var/log/gc.log:time,uptime,level,tags:filecount=10,filesize=100M
```

### 4. 其他JVM参数

```bash
# 性能优化
-XX:+AlwaysPreTouch           # 启动时预分配内存
-XX:+UseLargePages            # 使用大页内存
-XX:+DisableExplicitGC        # 禁用System.gc()

# 故障排查
-XX:+HeapDumpOnOutOfMemoryError           # OOM时生成堆转储
-XX:HeapDumpPath=/var/log/heapdump.hprof  # 堆转储路径
-XX:ErrorFile=/var/log/hs_err_pid%p.log   # 错误日志路径

# 监控
-Dcom.sun.management.jmxremote                    # 启用JMX
-Dcom.sun.management.jmxremote.port=9999          # JMX端口
-Dcom.sun.management.jmxremote.authenticate=false # 不需要认证
-Dcom.sun.management.jmxremote.ssl=false          # 不使用SSL
```

## Netty调优

### 1. EventLoopGroup配置

```java
// Boss线程组：处理连接
EventLoopGroup bossGroup = new NioEventLoopGroup(1);

// Worker线程组：处理I/O
// 线程数 = CPU核心数 * 2（IO密集型）
int workerThreads = Runtime.getRuntime().availableProcessors() * 2;
EventLoopGroup workerGroup = new NioEventLoopGroup(workerThreads);

// 自定义线程工厂
EventLoopGroup customGroup = new NioEventLoopGroup(
    workerThreads,
    new ThreadFactory() {
        private AtomicInteger counter = new AtomicInteger(0);
        
        @Override
        public Thread newThread(Runnable r) {
            Thread thread = new Thread(r);
            thread.setName("netty-worker-" + counter.incrementAndGet());
            thread.setDaemon(false);
            return thread;
        }
    }
);
```

**配置原则**：
- Boss线程：1个即可（只负责accept）
- Worker线程：CPU核心数 * 2（IO密集型）
- CPU密集型：CPU核心数 + 1
- 混合型：根据压测结果调整

### 2. Channel配置

```java
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
    .channel(NioServerSocketChannel.class)
    
    // 服务器端配置
    .option(ChannelOption.SO_BACKLOG, 1024)           // 连接队列大小
    .option(ChannelOption.SO_REUSEADDR, true)         // 地址复用
    
    // 客户端连接配置
    .childOption(ChannelOption.SO_KEEPALIVE, true)    // 保持连接
    .childOption(ChannelOption.TCP_NODELAY, true)     // 禁用Nagle算法
    .childOption(ChannelOption.SO_RCVBUF, 32 * 1024)  // 接收缓冲区
    .childOption(ChannelOption.SO_SNDBUF, 32 * 1024)  // 发送缓冲区
    
    // 写缓冲区水位线
    .childOption(ChannelOption.WRITE_BUFFER_WATER_MARK,
        new WriteBufferWaterMark(32 * 1024, 64 * 1024))
    
    // ByteBuf分配器（使用池化）
    .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
    
    // 接收缓冲区分配器
    .childOption(ChannelOption.RCVBUF_ALLOCATOR,
        new AdaptiveRecvByteBufAllocator(64, 1024, 65536));
```

**参数说明**：

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| SO_BACKLOG | 连接队列大小 | 1024-2048 |
| SO_KEEPALIVE | TCP保活机制 | true |
| TCP_NODELAY | 禁用Nagle算法 | true（低延迟） |
| SO_RCVBUF | 接收缓冲区 | 32KB-64KB |
| SO_SNDBUF | 发送缓冲区 | 32KB-64KB |

### 3. ByteBuf优化

```java
// 1. 使用池化ByteBuf
ByteBuf buf = PooledByteBufAllocator.DEFAULT.buffer(1024);
try {
    // 使用buf
} finally {
    buf.release();  // 必须释放
}

// 2. 使用直接内存（零拷贝）
ByteBuf directBuf = PooledByteBufAllocator.DEFAULT.directBuffer(1024);

// 3. 使用CompositeByteBuf避免拷贝
CompositeByteBuf composite = Unpooled.compositeBuffer();
composite.addComponents(true, header, body);

// 4. 使用slice共享内存
ByteBuf slice = buffer.slice(0, 100);

// 5. 预估容量，避免扩容
ByteBuf buf = ctx.alloc().buffer(estimatedSize);
```

### 4. Pipeline优化

```java
// 合理组织Handler顺序
pipeline.addLast("decoder", new MyDecoder());        // 解码器
pipeline.addLast("encoder", new MyEncoder());        // 编码器
pipeline.addLast("idle", new IdleStateHandler(30, 0, 0));  // 空闲检测
pipeline.addLast("business", new BusinessHandler()); // 业务处理

// 使用@Sharable共享无状态Handler
@ChannelHandler.Sharable
public class SharedHandler extends ChannelInboundHandlerAdapter {
    // 无状态Handler可以被多个Channel共享
}

// 耗时操作使用业务线程池
private static final ExecutorService businessExecutor = 
    Executors.newFixedThreadPool(20);

@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    businessExecutor.submit(() -> {
        // 耗时的业务处理
        processBusinessLogic(msg);
    });
}
```

## 操作系统调优

### 1. TCP参数调优

```bash
# 查看当前配置
sysctl -a | grep tcp

# 临时修改
sysctl -w net.ipv4.tcp_fin_timeout=30

# 永久修改（编辑/etc/sysctl.conf）
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 3
net.ipv4.tcp_max_syn_backlog = 8192
net.core.somaxconn = 32768
net.core.netdev_max_backlog = 16384
net.ipv4.tcp_max_tw_buckets = 5000

# 应用配置
sysctl -p
```

**参数说明**：

| 参数 | 说明 | 推荐值 |
|------|------|--------|
| tcp_fin_timeout | FIN_WAIT_2超时时间 | 30s |
| tcp_tw_reuse | TIME_WAIT复用 | 1 |
| tcp_keepalive_time | 保活探测间隔 | 600s |
| tcp_max_syn_backlog | SYN队列大小 | 8192 |
| somaxconn | 监听队列大小 | 32768 |

### 2. 文件描述符限制

```bash
# 查看当前限制
ulimit -n

# 临时修改
ulimit -n 65535

# 永久修改（编辑/etc/security/limits.conf）
* soft nofile 65535
* hard nofile 65535

# 系统级别限制（编辑/etc/sysctl.conf）
fs.file-max = 2097152

# 应用配置
sysctl -p
```

### 3. 内存配置

```bash
# 虚拟内存配置
vm.swappiness = 10              # 降低swap使用
vm.overcommit_memory = 1        # 允许内存过度分配
vm.max_map_count = 262144       # mmap数量限制

# 透明大页（建议禁用）
echo never > /sys/kernel/mm/transparent_hugepage/enabled
```

## 性能测试

### 1. 压测工具

#### wrk（HTTP压测）

```bash
# 安装
git clone https://github.com/wg/wrk.git
cd wrk
make

# 使用
wrk -t12 -c400 -d30s http://localhost:8080/api/test

# 参数说明：
# -t12: 12个线程
# -c400: 400个并发连接
# -d30s: 持续30秒

# 输出示例：
Running 30s test @ http://localhost:8080/api/test
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    10.50ms    5.20ms  50.00ms   75.00%
    Req/Sec     3.20k   500.00     4.50k    80.00%
  1152000 requests in 30.00s, 200.00MB read
Requests/sec:  38400.00
Transfer/sec:     6.67MB
```

#### JMeter

```java
// JMeter测试计划配置
ThreadGroup threadGroup = new ThreadGroup();
threadGroup.setNumThreads(100);        // 100个线程
threadGroup.setRampUp(10);             // 10秒启动完成
threadGroup.setDuration(300);          // 持续5分钟

HTTPSamplerProxy sampler = new HTTPSamplerProxy();
sampler.setDomain("localhost");
sampler.setPort(8080);
sampler.setPath("/api/test");
sampler.setMethod("GET");
```

### 2. 性能监控

#### JVM监控

```java
// 使用JMX监控
MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();

// 内存使用
MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean();
MemoryUsage heapUsage = memoryMXBean.getHeapMemoryUsage();
System.out.println("堆内存使用: " + heapUsage.getUsed() / 1024 / 1024 + "MB");

// GC统计
List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
for (GarbageCollectorMXBean gcBean : gcBeans) {
    System.out.println(gcBean.getName() + " - 次数: " + gcBean.getCollectionCount() +
        ", 耗时: " + gcBean.getCollectionTime() + "ms");
}

// 线程统计
ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
System.out.println("线程数: " + threadMXBean.getThreadCount());
System.out.println("峰值线程数: " + threadMXBean.getPeakThreadCount());
```

#### Netty监控

```java
// Channel统计
public class ChannelMonitor extends ChannelInboundHandlerAdapter {
    private static final AtomicLong activeConnections = new AtomicLong(0);
    private static final AtomicLong totalConnections = new AtomicLong(0);
    private static final AtomicLong totalBytes = new AtomicLong(0);
    
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        activeConnections.incrementAndGet();
        totalConnections.incrementAndGet();
        ctx.fireChannelActive();
    }
    
    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        activeConnections.decrementAndGet();
        ctx.fireChannelInactive();
    }
    
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        if (msg instanceof ByteBuf) {
            totalBytes.addAndGet(((ByteBuf) msg).readableBytes());
        }
        ctx.fireChannelRead(msg);
    }
    
    public static void printStats() {
        System.out.println("活跃连接: " + activeConnections.get());
        System.out.println("总连接数: " + totalConnections.get());
        System.out.println("总字节数: " + totalBytes.get());
    }
}
```

### 3. 性能分析工具

#### JProfiler

```bash
# 启动JVM时添加参数
-agentpath:/path/to/jprofiler/bin/linux-x64/libjprofilerti.so=port=8849
```

#### Arthas

```bash
# 下载
wget https://arthas.aliyun.com/arthas-boot.jar

# 启动
java -jar arthas-boot.jar

# 常用命令
dashboard          # 实时数据面板
thread            # 线程信息
jvm               # JVM信息
memory            # 内存信息
gc                # GC信息
trace             # 方法调用追踪
monitor           # 方法调用监控
```

## 实战案例

### 案例1：高并发HTTP服务优化

**问题**：QPS只有5000，CPU使用率80%，响应时间P99达到500ms。

**分析**：
1. 使用JProfiler分析，发现大量时间在JSON序列化
2. 使用Arthas trace，发现业务逻辑在EventLoop线程执行
3. GC日志显示频繁Young GC

**优化方案**：

```java
// 1. 使用高性能JSON库
// 替换Jackson为FastJson
private static final ObjectMapper mapper = new ObjectMapper();
// 改为
private static final JSON fastJson = JSON.parseObject();

// 2. 业务逻辑移到业务线程池
private static final ExecutorService businessExecutor = 
    new ThreadPoolExecutor(
        20, 50, 60L, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(1000),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );

@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    businessExecutor.submit(() -> {
        // 业务处理
        String result = processBusinessLogic(msg);
        ctx.writeAndFlush(result);
    });
}

// 3. 使用对象池减少GC
private static final GenericObjectPool<Response> responsePool = 
    new GenericObjectPool<>(new ResponseFactory());

Response response = responsePool.borrowObject();
try {
    // 使用response
} finally {
    responsePool.returnObject(response);
}

// 4. 使用池化ByteBuf
bootstrap.childOption(ChannelOption.ALLOCATOR, 
    PooledByteBufAllocator.DEFAULT);
```

**优化效果**：
- QPS：5000 → 20000（提升4倍）
- CPU使用率：80% → 40%
- 响应时间P99：500ms → 50ms

### 案例2：文件传输服务优化

**问题**：传输1GB文件需要60秒，CPU使用率90%。

**分析**：
1. 使用传统IO读取文件
2. 数据在用户空间和内核空间多次拷贝
3. 没有使用零拷贝技术

**优化方案**：

```java
// 使用FileRegion零拷贝
@Override
public void channelRead(ChannelHandlerContext ctx, String fileName) {
    File file = new File(fileName);
    
    try {
        RandomAccessFile raf = new RandomAccessFile(file, "r");
        FileChannel fileChannel = raf.getChannel();
        
        // 使用FileRegion实现零拷贝
        DefaultFileRegion fileRegion = new DefaultFileRegion(
            fileChannel, 0, fileChannel.size());
        
        ctx.writeAndFlush(fileRegion).addListener(future -> {
            fileChannel.close();
            raf.close();
        });
        
    } catch (IOException e) {
        e.printStackTrace();
    }
}

// 配置直接内存
-XX:MaxDirectMemorySize=2g
```

**优化效果**：
- 传输时间：60s → 15s（提升4倍）
- CPU使用率：90% → 20%
- 内存占用：500MB → 100MB

### 案例3：WebSocket聊天室优化

**问题**：1000个在线用户时，消息延迟达到2秒。

**分析**：
1. 广播消息时遍历所有Channel
2. 每次都创建新的消息对象
3. 没有使用ChannelGroup

**优化方案**：

```java
// 1. 使用ChannelGroup管理连接
private static final ChannelGroup channels = 
    new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

@Override
public void channelActive(ChannelHandlerContext ctx) {
    channels.add(ctx.channel());
}

// 2. 广播消息使用ChannelGroup
public void broadcast(String message) {
    TextWebSocketFrame frame = new TextWebSocketFrame(message);
    // 自动处理并发和异常
    channels.writeAndFlush(frame);
}

// 3. 使用对象池复用消息对象
private static final ObjectPool<Message> messagePool = 
    new GenericObjectPool<>(new MessageFactory());

// 4. 消息分组，减少广播范围
private static final Map<String, ChannelGroup> roomChannels = 
    new ConcurrentHashMap<>();

public void broadcastToRoom(String roomId, String message) {
    ChannelGroup room = roomChannels.get(roomId);
    if (room != null) {
        room.writeAndFlush(new TextWebSocketFrame(message));
    }
}
```

**优化效果**：
- 消息延迟：2s → 50ms
- 支持在线用户：1000 → 10000
- CPU使用率：70% → 30%

## 性能优化清单

### JVM层面
- [ ] 合理配置堆内存大小
- [ ] 选择合适的GC算法
- [ ] 配置GC日志
- [ ] 启用堆转储
- [ ] 配置直接内存大小

### Netty层面
- [ ] 合理配置EventLoopGroup线程数
- [ ] 启用池化ByteBuf
- [ ] 配置TCP参数
- [ ] 使用零拷贝技术
- [ ] 优化Pipeline结构
- [ ] 耗时操作使用业务线程池

### 操作系统层面
- [ ] 调整TCP参数
- [ ] 增加文件描述符限制
- [ ] 配置虚拟内存
- [ ] 禁用透明大页

### 应用层面
- [ ] 使用连接池
- [ ] 使用对象池
- [ ] 减少对象创建
- [ ] 异步处理
- [ ] 批量操作

### 监控层面
- [ ] JVM监控
- [ ] GC监控
- [ ] 连接数监控
- [ ] 响应时间监控
- [ ] 错误率监控

## 总结

### 核心要点

1. **性能调优是系统工程**：需要从JVM、Netty、OS、应用多个层面综合优化
2. **先测量后优化**：基于数据分析，不要盲目优化
3. **持续监控**：建立监控体系，及时发现性能问题
4. **压测验证**：每次优化后都要压测验证效果

### 优化原则

1. **二八原则**：80%的性能问题由20%的代码引起
2. **避免过早优化**：先保证功能正确，再优化性能
3. **权衡取舍**：性能、可维护性、开发成本需要平衡
4. **持续改进**：性能优化是持续的过程

### 常见误区

1. 盲目增加线程数
2. 过度优化不重要的代码
3. 忽略GC影响
4. 不做性能测试
5. 忽略操作系统层面优化
